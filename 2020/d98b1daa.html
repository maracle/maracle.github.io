<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>python语言参考 | 彭彭和丁满</title><meta name="description" content="python语言参考"><meta name="keywords" content="python"><meta name="author" content="蕾米亚"><meta name="copyright" content="蕾米亚"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="python语言参考"><meta name="twitter:description" content="python语言参考"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover4.gif"><meta property="og:type" content="article"><meta property="og:title" content="python语言参考"><meta property="og:url" content="http://omimo.ga/2020/d98b1daa.html"><meta property="og:site_name" content="彭彭和丁满"><meta property="og:description" content="python语言参考"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover4.gif"><meta property="article:published_time" content="2020-03-24T09:41:39.000Z"><meta property="article:modified_time" content="2020-03-24T09:41:39.000Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://omimo.ga/2020/d98b1daa.html"><link rel="prev" title="20200325疫情信息" href="http://omimo.ga/2020/8a2b378.html"><link rel="next" title="python入门教程" href="http://omimo.ga/2020/b23cbeff.html"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?568a96aacae5c6fda285d9376b556b06";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://www.omimo.ga","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/img/longmao.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">150</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">56</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">28</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-folder-open"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/front/"><i class="fa-fw fa fa-link"></i><span> 导航</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-其他实现"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 其他实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-标注"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 标注</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-词法分析"><span class="toc-number">2.</span> <span class="toc-text">2. 词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-行结构"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 行结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-逻辑行"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. 逻辑行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-物理行"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. 物理行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-注释"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3. 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-编码声明"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4. 编码声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-显式的行拼接"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5. 显式的行拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-隐式的行拼接"><span class="toc-number">2.1.6.</span> <span class="toc-text">2.1.6. 隐式的行拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7-空白行"><span class="toc-number">2.1.7.</span> <span class="toc-text">2.1.7. 空白行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-8-缩进"><span class="toc-number">2.1.8.</span> <span class="toc-text">2.1.8. 缩进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-9-形符之间的空白"><span class="toc-number">2.1.9.</span> <span class="toc-text">2.1.9. 形符之间的空白</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-其他形符"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 其他形符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-标识符和关键字"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 标识符和关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-关键字"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-保留的标识符类"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 保留的标识符类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-字面值"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. 字面值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-字符串和字节串字面值"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 字符串和字节串字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-字符串字面值拼接"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. 字符串字面值拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-格式化字符串字面值"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3. 格式化字符串字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-数字字面值"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.4. 数字字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-整型数字面值"><span class="toc-number">2.4.5.</span> <span class="toc-text">2.4.5. 整型数字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-浮点数字面值"><span class="toc-number">2.4.6.</span> <span class="toc-text">2.4.6. 浮点数字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-虚数字面值"><span class="toc-number">2.4.7.</span> <span class="toc-text">2.4.7. 虚数字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-运算符"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-分隔符"><span class="toc-number">2.6.</span> <span class="toc-text">2.6. 分隔符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-数据模型"><span class="toc-number">3.</span> <span class="toc-text">3. 数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-对象、值与类型"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 对象、值与类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-标准类型层级结构"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 标准类型层级结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-特殊方法名称"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 特殊方法名称</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-基本定制"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 基本定制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-自定义属性访问"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2. 自定义属性访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1-自定义模块属性访问"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">3.3.2.1. 自定义模块属性访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-2-实现描述器"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">3.3.2.2. 实现描述器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-3-发起调用描述器"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">3.3.2.3. 发起调用描述器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-4-slots"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">3.3.2.4. slots</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-4-1-使用-slots-的注意事项"><span class="toc-number">3.3.2.4.1.</span> <span class="toc-text">3.3.2.4.1. 使用 slots 的注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-自定义类创建"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3. 自定义类创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-1-元类"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">3.3.3.1. 元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-2-解析-MRO-条目"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">3.3.3.2. 解析 MRO 条目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-3-确定适当的元类"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">3.3.3.3. 确定适当的元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-4-准备类命名空间"><span class="toc-number">3.3.3.4.</span> <span class="toc-text">3.3.3.4. 准备类命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-5-执行类主体"><span class="toc-number">3.3.3.5.</span> <span class="toc-text">3.3.3.5. 执行类主体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-6-创建类对象"><span class="toc-number">3.3.3.6.</span> <span class="toc-text">3.3.3.6. 创建类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-7-元类的作用"><span class="toc-number">3.3.3.7.</span> <span class="toc-text">3.3.3.7. 元类的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-自定义实例及子类检查"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3.4. 自定义实例及子类检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5-模拟泛型类型"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.3.5. 模拟泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-6-模拟可调用对象"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.3.6. 模拟可调用对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-7-模拟容器类型"><span class="toc-number">3.3.7.</span> <span class="toc-text">3.3.7. 模拟容器类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-8-模拟数字类型"><span class="toc-number">3.3.8.</span> <span class="toc-text">3.3.8. 模拟数字类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-9-with-语句上下文管理器"><span class="toc-number">3.3.9.</span> <span class="toc-text">3.3.9. with 语句上下文管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-10-特殊方法查找"><span class="toc-number">3.3.10.</span> <span class="toc-text">3.3.10. 特殊方法查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-协程"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-可等待对象"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 可等待对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-协程对象"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2. 协程对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-异步迭代器"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3. 异步迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-异步上下文管理器"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4. 异步上下文管理器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-执行模型"><span class="toc-number">4.</span> <span class="toc-text">4. 执行模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-程序的结构"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 程序的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-命名与绑定"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 命名与绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-名称的绑定"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. 名称的绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-名称的解析"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. 名称的解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-内置命名空间和受限的执行"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. 内置命名空间和受限的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-与动态特性的交互"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4. 与动态特性的交互</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-异常"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-导入系统"><span class="toc-number">5.</span> <span class="toc-text">5. 导入系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-importlib"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. importlib</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-包"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-常规包"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1. 常规包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-命名空间包"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2. 命名空间包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-搜索"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-模块缓存"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1. 模块缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-查找器和加载器"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2. 查找器和加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-导入钩子"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3. 导入钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-元路径"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4. 元路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-加载"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-加载器"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1. 加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-子模块"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2. 子模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-模块规格说明"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3. 模块规格说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-导入相关的模块属性"><span class="toc-number">5.4.4.</span> <span class="toc-text">5.4.4. 导入相关的模块属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-5-module-path"><span class="toc-number">5.4.5.</span> <span class="toc-text">5.4.5. module.path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-6-模块的-repr"><span class="toc-number">5.4.6.</span> <span class="toc-text">5.4.6. 模块的 repr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-7-已缓存字节码的失效"><span class="toc-number">5.4.7.</span> <span class="toc-text">5.4.7. 已缓存字节码的失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-基于路径的查找器"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 基于路径的查找器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1-路径条目查找器"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1. 路径条目查找器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2-路径条目查找器协议"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2. 路径条目查找器协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-替换标准导入系统"><span class="toc-number">5.6.</span> <span class="toc-text">5.6. 替换标准导入系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-包相对导入"><span class="toc-number">5.7.</span> <span class="toc-text">5.7. 包相对导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-有关-main-的特殊事项"><span class="toc-number">5.8.</span> <span class="toc-text">5.8. 有关 main 的特殊事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-1-main-spec"><span class="toc-number">5.8.1.</span> <span class="toc-text">5.8.1. main.spec</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-开放问题项"><span class="toc-number">5.9.</span> <span class="toc-text">5.9. 开放问题项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-参考文献"><span class="toc-number">5.10.</span> <span class="toc-text">5.10. 参考文献</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-表达式"><span class="toc-number">6.</span> <span class="toc-text">6. 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-算术转换"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 算术转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-原子"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 原子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-标识符（名称）"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1. 标识符（名称）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-字面值"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2. 字面值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-带圆括号的形式"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3. 带圆括号的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-列表、集合与字典的显示"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.2.4. 列表、集合与字典的显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-列表显示"><span class="toc-number">6.2.5.</span> <span class="toc-text">6.2.5. 列表显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6-集合显示"><span class="toc-number">6.2.6.</span> <span class="toc-text">6.2.6. 集合显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7-字典显示"><span class="toc-number">6.2.7.</span> <span class="toc-text">6.2.7. 字典显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-8-生成器表达式"><span class="toc-number">6.2.8.</span> <span class="toc-text">6.2.8. 生成器表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-9-yield-表达式"><span class="toc-number">6.2.9.</span> <span class="toc-text">6.2.9. yield 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-9-1-生成器-迭代器的方法"><span class="toc-number">6.2.9.1.</span> <span class="toc-text">6.2.9.1. 生成器-迭代器的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-9-2-示例"><span class="toc-number">6.2.9.2.</span> <span class="toc-text">6.2.9.2. 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-9-3-异步生成器函数"><span class="toc-number">6.2.9.3.</span> <span class="toc-text">6.2.9.3. 异步生成器函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-9-4-异步生成器-迭代器方法"><span class="toc-number">6.2.9.4.</span> <span class="toc-text">6.2.9.4. 异步生成器-迭代器方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-原型"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. 原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-属性引用"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1. 属性引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-抽取"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2. 抽取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-切片"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3. 切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4-调用"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.3.4. 调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-await-表达式"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. await 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-幂运算符"><span class="toc-number">6.5.</span> <span class="toc-text">6.5. 幂运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-一元算术和位运算"><span class="toc-number">6.6.</span> <span class="toc-text">6.6. 一元算术和位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-二元算术运算符"><span class="toc-number">6.7.</span> <span class="toc-text">6.7. 二元算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-移位运算"><span class="toc-number">6.8.</span> <span class="toc-text">6.8. 移位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-二元位运算"><span class="toc-number">6.9.</span> <span class="toc-text">6.9. 二元位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-比较运算"><span class="toc-number">6.10.</span> <span class="toc-text">6.10. 比较运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1-值比较"><span class="toc-number">6.10.1.</span> <span class="toc-text">6.10.1. 值比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2-成员检测运算"><span class="toc-number">6.10.2.</span> <span class="toc-text">6.10.2. 成员检测运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-3-标识号比较"><span class="toc-number">6.10.3.</span> <span class="toc-text">6.10.3. 标识号比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-布尔运算"><span class="toc-number">6.11.</span> <span class="toc-text">6.11. 布尔运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-12-赋值表达式"><span class="toc-number">6.12.</span> <span class="toc-text">6.12. 赋值表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-13-条件表达式"><span class="toc-number">6.13.</span> <span class="toc-text">6.13. 条件表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-14-lambda-表达式"><span class="toc-number">6.14.</span> <span class="toc-text">6.14. lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-15-表达式列表"><span class="toc-number">6.15.</span> <span class="toc-text">6.15. 表达式列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-16-求值顺序"><span class="toc-number">6.16.</span> <span class="toc-text">6.16. 求值顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-17-运算符优先级"><span class="toc-number">6.17.</span> <span class="toc-text">6.17. 运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-简单语句"><span class="toc-number">7.</span> <span class="toc-text">7. 简单语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-表达式语句"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 表达式语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-赋值语句"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 赋值语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-增强赋值语句"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1. 增强赋值语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-带标注的赋值语句"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2. 带标注的赋值语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-assert-语句"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. assert 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-pass-语句"><span class="toc-number">7.4.</span> <span class="toc-text">7.4. pass 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-del-语句"><span class="toc-number">7.5.</span> <span class="toc-text">7.5. del 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-return-语句"><span class="toc-number">7.6.</span> <span class="toc-text">7.6. return 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-yield-语句"><span class="toc-number">7.7.</span> <span class="toc-text">7.7. yield 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-raise-语句"><span class="toc-number">7.8.</span> <span class="toc-text">7.8. raise 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-break-语句"><span class="toc-number">7.9.</span> <span class="toc-text">7.9. break 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10-continue-语句"><span class="toc-number">7.10.</span> <span class="toc-text">7.10. continue 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-import-语句"><span class="toc-number">7.11.</span> <span class="toc-text">7.11. import 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-1-future-语句"><span class="toc-number">7.11.1.</span> <span class="toc-text">7.11.1. future 语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-12-global-语句"><span class="toc-number">7.12.</span> <span class="toc-text">7.12. global 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-13-nonlocal-语句"><span class="toc-number">7.13.</span> <span class="toc-text">7.13. nonlocal 语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-复合语句"><span class="toc-number">8.</span> <span class="toc-text">8. 复合语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-if-语句"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-while-语句"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. while 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-for-语句"><span class="toc-number">8.3.</span> <span class="toc-text">8.3. for 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-try-语句"><span class="toc-number">8.4.</span> <span class="toc-text">8.4. try 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-with-语句"><span class="toc-number">8.5.</span> <span class="toc-text">8.5. with 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-函数定义"><span class="toc-number">8.6.</span> <span class="toc-text">8.6. 函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-类定义"><span class="toc-number">8.7.</span> <span class="toc-text">8.7. 类定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-协程"><span class="toc-number">8.8.</span> <span class="toc-text">8.8. 协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-1-协程函数定义"><span class="toc-number">8.8.1.</span> <span class="toc-text">8.8.1. 协程函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-2-async-for-语句"><span class="toc-number">8.8.2.</span> <span class="toc-text">8.8.2. async for 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-3-async-with-语句"><span class="toc-number">8.8.3.</span> <span class="toc-text">8.8.3. async with 语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-最高层级组件"><span class="toc-number">9.</span> <span class="toc-text">9. 最高层级组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-完整的-Python-程序"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. 完整的 Python 程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-文件输入"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. 文件输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-交互式输入"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. 交互式输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-表达式输入"><span class="toc-number">9.4.</span> <span class="toc-text">9.4. 表达式输入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-完整的语法规范"><span class="toc-number">10.</span> <span class="toc-text">10. 完整的语法规范</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover4.gif)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">彭彭和丁满</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-folder-open"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/front/"><i class="fa-fw fa fa-link"></i><span> 导航</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">python语言参考</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-24 17:41:39"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-03-24 17:41:39"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-03-24</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">74.5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 249 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/d98b1daa.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/d98b1daa.html" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>转自python管方文档：<a href="https://docs.python.org/zh-cn/3/library/index.html#library-index" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/index.html#library-index</a></p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本参考手册是对 Python 编程语言的描述。并不适宜作为教程使用。</p>
<p>我希望尽可能地保证内容精确无误，但还是选择使用自然词句进行描述，正式的规格定义仅用于句法和词法解析。这样应该能使文档对于普通人来说更易理解，但也可能导致一些歧义。因此，如果你是来自火星并且想凭借这份文档把 Python 重新实现一遍，也许有时需要自行猜测，实际上最终大概会得到一个十分不同的语言。而在另一方面，如果你正在使用 Python 并且想了解有关该语言特定领域的精确规则，你应该能够在这里找到它们。如果你希望查看对该语言更正式的定义，也许你可以花些时间自己写上一份 — 或者发明一台克隆机器 :-)</p>
<p>在语言参考文档里加入过多的实现细节是很危险的 — 具体实现可能发生改变，对同一语言的其他实现可能使用不同的方式。而在另一方面，CPython 是得到广泛使用的 Python 实现 (然而其他一些实现的拥护者也在增加)，其中的特殊细节有时也值得一提，特别是当其实现方式导致额外的限制时。因此，你会发现在正文里不时会跳出来一些简短的 “实现注释”。</p>
<p>每种 Python 实现都带有一些内置和标准的模块。相关的文档可参见 <a href="https://docs.python.org/zh-cn/3/library/index.html#library-index" target="_blank" rel="noopener">Python 标准库</a> 索引。少数内置模块也会在此提及，如果它们同语言描述存在明显的关联。</p>
<h2 id="1-1-其他实现"><a href="#1-1-其他实现" class="headerlink" title="1.1. 其他实现"></a>1.1. 其他实现</h2><p>虽然官方 Python 实现差不多得到最广泛的欢迎，但也有一些其他实现对特定领域的用户来说更具吸引力。</p>
<p>知名的实现包括:</p>
<ul>
<li><p>CPython</p>
<p>这是最早出现并持续维护的 Python 实现，以 C 语言编写。新的语言特性通常在此率先添加。</p>
</li>
<li><p>Jython</p>
<p>以 Java 语言编写的 Python 实现。此实现可以作为 Java 应用的一个脚本语言，或者可以用来创建需要 Java 类库支持的应用。想了解更多信息可访问 <a href="http://www.jython.org/" target="_blank" rel="noopener">Jython 网站</a>。</p>
</li>
<li><p>Python for .NET</p>
<p>此实现实际上使用了 CPython 实现，但是属于 .NET 托管应用并且可以引入 .NET 类库。它的创造者是 Brian Lloyd。想了解详情可访问 <a href="https://pythonnet.github.io/" target="_blank" rel="noopener">Python for .NET 主页</a>。</p>
</li>
<li><p>IronPython</p>
<p>另一个 .NET 的 Python 实现，与 Python.NET 不同点在于它是生成 IL 的完全 Python 实现，并且将 Python 代码直接编译为 .NET 程序集。它的创造者就是当初创造 Jython 的 Jim Hugunin。想了解详情可访问 <a href="http://ironpython.net/" target="_blank" rel="noopener">IronPython 网站</a>。</p>
</li>
<li><p>PyPy</p>
<p>完全使用 Python 语言编写的 Python 实现。它支持多个其他实现所没有的高级特性，例如非栈式支持和 JIT 编译器等。此项目的目标之一是通过允许方便地修改解释器 (因为它是用 Python 编写的)，鼓励该对语言本身进行试验。想了解详情可访问 <a href="http://pypy.org/" target="_blank" rel="noopener">PyPy 项目主页</a>。</p>
</li>
</ul>
<p>以上这些实现都可能在某些方面与此参考文档手册的描述有所差异，或是引入了超出标准 Python 文档范围的特定信息。请参考它们各自的专门文档，以确定你正在使用的这个实现有哪些你需要了解的东西。</p>
<h2 id="1-2-标注"><a href="#1-2-标注" class="headerlink" title="1.2. 标注"></a>1.2. 标注</h2><p>句法和词法解析的描述采用经过改进的 BNF 语法标注。这包含以下定义样式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name      ::&#x3D;  lc_letter (lc_letter | &quot;_&quot;)*</span><br><span class="line">lc_letter ::&#x3D;  &quot;a&quot;...&quot;z&quot;</span><br></pre></td></tr></table></figure>

<p>第一行表示 <code>name</code> 是一个 <code>lc_letter</code> 之后跟零个或多个 <code>lc_letter</code> 和下划线。而一个 <code>lc_letter</code> 则是任意单个 <code>&#39;a&#39;</code> 至 <code>&#39;z&#39;</code> 字符。(实际上在本文档中始终采用此规则来定义词法和语法规则的名称。)</p>
<p>每条规则的开头是一个名称 (即该规则所定义的名称) 加上 <code>::=</code>。竖线 (<code>|</code>) 被用来分隔可选项；它是此标注中最灵活的操作符。星号 (<code>*</code>) 表示前一项的零次或多次重复；类似地，加号 (<code>+</code>) 表示一次或多次重复，而由方括号括起的内容 (<code>[ ]</code>) 表示出现零次或一次 (或者说，这部分内容是可选的)。<code>*</code> 和 <code>+</code> 操作符的绑定是最紧密的；圆括号用于分组。固定字符串包含在引号内。空格的作用仅限于分隔形符。每条规则通常为一行；有许多个可选项的规则可能会以竖线为界分为多行。</p>
<p>在词法定义中 (如上述示例)，还额外使用了两个约定: 由三个点号分隔的两个字符字面值表示在指定 (闭) 区间范围内的任意单个 ASCII 字符。由尖括号 (<code>&lt;...&gt;</code>) 括起来的内容是对于所定义符号的非正式描述；即可以在必要时用来说明 ‘控制字符’ 的意图。</p>
<p>虽然所用的标注方式几乎相同，但是词法定义和句法定义是存在很大区别的: 词法定义作用于输入源中单独的字符，而句法定义则作用于由词法分析所生成的形符流。在下一章节 (“词法分析”) 中使用的 BNF 全部都是词法定义；在之后的章节中使用的则是句法定义。</p>
<h1 id="2-词法分析"><a href="#2-词法分析" class="headerlink" title="2. 词法分析"></a>2. 词法分析</h1><p>Python 程序由一个 <em>解析器</em> 读取。输入到解析器的是一个由 <em>词法分析器</em> 所生成的 <em>形符</em> 流，本章将描述词法分析器是如何将一个文件拆分为一个个形符的。</p>
<p>Python 会将读取的程序文本转为 Unicode 码点；源文件的文本编码可由编码声明指定，默认为 UTF-8，详情见 <a href="https://www.python.org/dev/peps/pep-3120" target="_blank" rel="noopener"><strong>PEP 3120</strong></a>。如果源文件无法被解码，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。</p>
<h2 id="2-1-行结构"><a href="#2-1-行结构" class="headerlink" title="2.1. 行结构"></a>2.1. 行结构</h2><p>一个 Python 程序可分为许多 <em>逻辑行</em>。</p>
<h3 id="2-1-1-逻辑行"><a href="#2-1-1-逻辑行" class="headerlink" title="2.1.1. 逻辑行"></a>2.1.1. 逻辑行</h3><p>逻辑行的结束是以 NEWLINE 形符表示的。语句不能跨越逻辑行的边界，除非其语法允许包含 NEWLINE (例如复合语句可由多行子语句组成)。一个逻辑行可由一个或多个 <em>物理行</em> 按照明确或隐含的 <em>行拼接</em> 规则构成。</p>
<h3 id="2-1-2-物理行"><a href="#2-1-2-物理行" class="headerlink" title="2.1.2. 物理行"></a>2.1.2. 物理行</h3><p>物理行是以一个行终止序列结束的字符序列。在源文件和字符串中，可以使用任何标准平台上的行终止序列 - Unix 所用的 ASCII 字符 LF (换行), Windows 所用的 ASCII 字符序列 CR LF (回车加换行), 或者旧 Macintosh 所用的 ASCII 字符 CR (回车)。所有这些形式均可使用，无论具体平台。输入的结束也会被作为最后一个物理行的隐含终止标志。</p>
<p>当嵌入 Python 时，源码字符串传入 Python API 应使用标准 C 的传统换行符 (即 <code>\n</code>，表示 ASCII 字符 LF 作为行终止标志)。</p>
<h3 id="2-1-3-注释"><a href="#2-1-3-注释" class="headerlink" title="2.1.3. 注释"></a>2.1.3. 注释</h3><p>一条注释以不包含在字符串字面值内的井号 (<code>#</code>) 开头，并在物理行的末尾结束。 一条注释标志着逻辑行的结束，除非存在隐含的行拼接规则。 注释在语法分析中会被忽略。</p>
<h3 id="2-1-4-编码声明"><a href="#2-1-4-编码声明" class="headerlink" title="2.1.4. 编码声明"></a>2.1.4. 编码声明</h3><p>如果一条注释位于 Python 脚本的第一或第二行，并且匹配正则表达式 <code>coding[=:]\s*([-\w.]+)</code>，这条注释会被作为编码声明来处理；上述表达式的第一组指定了源码文件的编码。编码声明必须独占一行。如果它是在第二行，则第一行也必须是注释。推荐的编码声明形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: &lt;encoding-name&gt; -*-</span><br></pre></td></tr></table></figure>

<p>这也是 GNU Emacs 认可的形式，以及</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># vim:fileencoding&#x3D;&lt;encoding-name&gt;</span><br></pre></td></tr></table></figure>

<p>这是 Bram Moolenaar 的 VIM 认可的形式。</p>
<p>如果没有编码声明，则默认编码为 UTF-8。此外，如果文件的首字节为 UTF-8 字节顺序标志 (<code>b&#39;\xef\xbb\xbf&#39;</code>)，文件编码也声明为 UTF-8 (这是 Microsoft 的 <strong>notepad</strong> 等软件支持的形式)。</p>
<p>编码声明指定的编码名称必须是 Python 所认可的编码。所有词法分析将使用此编码，包括语义字符串、注释和标识符。</p>
<h3 id="2-1-5-显式的行拼接"><a href="#2-1-5-显式的行拼接" class="headerlink" title="2.1.5. 显式的行拼接"></a>2.1.5. 显式的行拼接</h3><p>两个或更多个物理行可使用反斜杠字符 (<code>\</code>) 拼接为一个逻辑行，规则如下: 当一个物理行以一个不在字符串或注释内的反斜杠结尾时，它将与下一行拼接构成一个单独的逻辑行，反斜杠及其后的换行符会被删除。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 1900 &lt; year &lt; 2100 and 1 &lt;&#x3D; month &lt;&#x3D; 12 \</span><br><span class="line">   and 1 &lt;&#x3D; day &lt;&#x3D; 31 and 0 &lt;&#x3D; hour &lt; 24 \</span><br><span class="line">   and 0 &lt;&#x3D; minute &lt; 60 and 0 &lt;&#x3D; second &lt; 60:   # Looks like a valid date</span><br><span class="line">        return 1</span><br></pre></td></tr></table></figure>

<p>以反斜杠结束的行不能带有注释。反斜杠不能用来拼接注释。反斜杠不能用来拼接形符，字符串除外 (即原文字符串以外的形符不能用反斜杠分隔到两个物理行)。不允许有原文字符串以外的反斜杠存在于物理行的其他位置。</p>
<h3 id="2-1-6-隐式的行拼接"><a href="#2-1-6-隐式的行拼接" class="headerlink" title="2.1.6. 隐式的行拼接"></a>2.1.6. 隐式的行拼接</h3><p>圆括号、方括号或花括号以内的表达式允许分成多个物理行，无需使用反斜杠。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">month_names &#x3D; [&#39;Januari&#39;, &#39;Februari&#39;, &#39;Maart&#39;,      # These are the</span><br><span class="line">               &#39;April&#39;,   &#39;Mei&#39;,      &#39;Juni&#39;,       # Dutch names</span><br><span class="line">               &#39;Juli&#39;,    &#39;Augustus&#39;, &#39;September&#39;,  # for the months</span><br><span class="line">               &#39;Oktober&#39;, &#39;November&#39;, &#39;December&#39;]   # of the year</span><br></pre></td></tr></table></figure>

<p>隐式的行拼接可以带有注释。后续行的缩进不影响程序结构。后续行也允许为空白行。隐式拼接的行之间不会有 NEWLINE 形符。隐式拼接的行也可以出现于三引号字符串中 (见下)；此情况下这些行不允许带有注释。</p>
<h3 id="2-1-7-空白行"><a href="#2-1-7-空白行" class="headerlink" title="2.1.7. 空白行"></a>2.1.7. 空白行</h3><p>一个只包含空格符，制表符，进纸符或者注释的逻辑行会被忽略 (即不生成 NEWLINE 形符)。在交互模式输入语句时，对空白行的处理可能会因读取-求值-打印循环的具体实现方式而存在差异。在标准交互模式解释器中，一个完全空白的逻辑行 (即连空格或注释都没有) 将会结束一条多行复合语句。</p>
<h3 id="2-1-8-缩进"><a href="#2-1-8-缩进" class="headerlink" title="2.1.8. 缩进"></a>2.1.8. 缩进</h3><p>一个逻辑行开头处的空白 (空格符和制表符) 被用来计算该行的缩进等级，以决定语句段落的组织结构。</p>
<p>制表符会被 (从左至右) 替换为一至八个空格，这样缩进的空格总数为八的倍数 (这是为了与 Unix 所用的规则一致)。首个非空白字符之前的空格总数将确定该行的缩进层次。一个缩进不可使用反斜杠进行多行拼接；首个反斜杠之前的空格将确定缩进层次。</p>
<p>在一个源文件中如果混合使用制表符和空格符缩进，并使得确定缩进层次需要依赖于制表符对应的空格数量设置，则被视为不合规则；此情况将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TabError" target="_blank" rel="noopener"><code>TabError</code></a>。</p>
<p><strong>跨平台兼容性注释:</strong> 由于非 UNIX 平台上文本编辑器本身的特性，在一个源文件中混合使用制表符和空格符是不明智的。另外也要注意不同平台还可能会显式地限制最大缩进层级。</p>
<p>行首有时可能会有一个进纸符；它在上述缩进层级计算中会被忽略。处于行首空格内其他位置的进纸符的效果未定义 (例如它可能导致空格计数重置为零)。</p>
<p>多个连续行各自的缩进层级将会被放入一个堆栈用来生成 INDENT 和 DEDENT 形符，具体说明如下。</p>
<p>在读取文件的第一行之前，先向堆栈推入一个零值；它将不再被弹出。被推入栈的层级数值从底至顶持续增加。每个逻辑行开头的行缩进层级将与栈顶行比较。如果相同，则不做处理。如果新行层级较高，则会被推入栈顶，并生成一个 INDENT 形符。如果新行层级较低，则 <em>应当</em> 是栈中的层级数值之一；栈中高于该层级的所有数值都将被弹出，每弹出一级数值生成一个 DEDENT 形符。在文件末尾，栈中剩余的每个大于零的数值生成一个 DEDENT 形符。</p>
<p>这是一个正确 (但令人迷惑) 的Python 代码缩进示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def perm(l):</span><br><span class="line">        # Compute the list of all permutations of l</span><br><span class="line">    if len(l) &lt;&#x3D; 1:</span><br><span class="line">                  return [l]</span><br><span class="line">    r &#x3D; []</span><br><span class="line">    for i in range(len(l)):</span><br><span class="line">             s &#x3D; l[:i] + l[i+1:]</span><br><span class="line">             p &#x3D; perm(s)</span><br><span class="line">             for x in p:</span><br><span class="line">              r.append(l[i:i+1] + x)</span><br><span class="line">    return r</span><br></pre></td></tr></table></figure>

<p>以下示例显示了各种缩进错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> def perm(l):                       # error: first line indented</span><br><span class="line">for i in range(len(l)):             # error: not indented</span><br><span class="line">    s &#x3D; l[:i] + l[i+1:]</span><br><span class="line">        p &#x3D; perm(l[:i] + l[i+1:])   # error: unexpected indent</span><br><span class="line">        for x in p:</span><br><span class="line">                r.append(l[i:i+1] + x)</span><br><span class="line">            return r                # error: inconsistent dedent</span><br></pre></td></tr></table></figure>

<p>(实际上，前三个错误会被解析器发现；只有最后一个错误是由词法分析器发现的 — <code>return r</code> 的缩进无法匹配弹出栈的缩进层级。)</p>
<h3 id="2-1-9-形符之间的空白"><a href="#2-1-9-形符之间的空白" class="headerlink" title="2.1.9. 形符之间的空白"></a>2.1.9. 形符之间的空白</h3><p>除非是在逻辑行的开头或字符串内，空格符、制表符和进纸符等空白符都同样可以用来分隔形符。如果两个形符彼此相连会被解析为一个不同的形符，则需要使用空白来分隔 (例如 ab 是一个形符，而 a b 是两个形符)。</p>
<h2 id="2-2-其他形符"><a href="#2-2-其他形符" class="headerlink" title="2.2. 其他形符"></a>2.2. 其他形符</h2><p>除了 NEWLINE, INDENT 和 DEDENT，还存在以下类别的形符: <em>标识符</em>, <em>关键字</em>, <em>字面值</em>, <em>运算符</em> 以及 <em>分隔符</em>。 空白字符 (之前讨论过的行终止符除外) 不属于形符，而是用来分隔形符。如果存在二义性，将从左至右读取尽可能长的合法字符串组成一个形符。</p>
<h2 id="2-3-标识符和关键字"><a href="#2-3-标识符和关键字" class="headerlink" title="2.3. 标识符和关键字"></a>2.3. 标识符和关键字</h2><p>标识符 (或者叫做 <em>名称</em>) 由以下词法定义进行描述。</p>
<p>Python 中的标识符语法是基于 Unicode 标准附件 UAX-31，并加入了下文所定义的细化与修改；更多细节还可参见 <a href="https://www.python.org/dev/peps/pep-3131" target="_blank" rel="noopener"><strong>PEP 3131</strong></a> 。</p>
<p>在 ASCII 范围内 (U+0001..U+007F)，可用于标识符的字符与 Python 2.x 一致: 大写和小写字母 <code>A</code> 至 <code>Z</code>，下划线 <code>_</code> 以及数字 <code>0</code> 至 <code>9</code>，但不可以数字打头。</p>
<p>Python 3.0 引入了 ASCII 范围以外的额外字符 (见 <a href="https://www.python.org/dev/peps/pep-3131" target="_blank" rel="noopener"><strong>PEP 3131</strong></a>)。这些字符的分类使用包含于 <a href="https://docs.python.org/zh-cn/3/library/unicodedata.html#module-unicodedata" target="_blank" rel="noopener"><code>unicodedata</code></a> 模块中的 Unicode 字符数据库版本。</p>
<p>标识符的长度没有限制。对大小写敏感。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">identifier   ::&#x3D;  xid_start xid_continue*</span><br><span class="line">id_start     ::&#x3D;  &lt;all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property&gt;</span><br><span class="line">id_continue  ::&#x3D;  &lt;all characters in id_start, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property&gt;</span><br><span class="line">xid_start    ::&#x3D;  &lt;all characters in id_start whose NFKC normalization is in &quot;id_start xid_continue*&quot;&gt;</span><br><span class="line">xid_continue ::&#x3D;  &lt;all characters in id_continue whose NFKC normalization is in &quot;id_continue*&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>上文所用 Unicode 类别码的含义:</p>
<ul>
<li><em>Lu</em> - 大写字母</li>
<li><em>Ll</em> - 小写字母</li>
<li><em>Lt</em> - 词首大写字母</li>
<li><em>Lm</em> - 修饰字母</li>
<li><em>Lo</em> - 其他字母</li>
<li><em>Nl</em> - 字母数字</li>
<li><em>Mn</em> - 非空白标识</li>
<li><em>Mc</em> - 含空白标识</li>
<li><em>Nd</em> - 十进制数字</li>
<li><em>Pc</em> - 连接标点</li>
<li><em>Other_ID_Start</em> - 由 <a href="http://www.unicode.org/Public/12.1.0/ucd/PropList.txt" target="_blank" rel="noopener">PropList.txt</a> 定义的显式字符列表，用来支持向下兼容</li>
<li><em>Other_ID_Continue</em> - 同上</li>
</ul>
<p>所有标识符在解析时会被转换为规范形式 NFKC；标识符的比较都是基于 NFKC。</p>
<p>Unicode 4.1 中的所有可用标识符字符列表参见以下非规范 HTML 文件链接 <a href="https://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html" target="_blank" rel="noopener">https://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html</a></p>
<h3 id="2-3-1-关键字"><a href="#2-3-1-关键字" class="headerlink" title="2.3.1. 关键字"></a>2.3.1. 关键字</h3><p>以下标识符被作为语言的保留字或称 <em>关键字</em>，不可被用作普通标识符。关键字的拼写必须与这里列出的完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">False      await      else       import     pass</span><br><span class="line">None       break      except     in         raise</span><br><span class="line">True       class      finally    is         return</span><br><span class="line">and        continue   for        lambda     try</span><br><span class="line">as         def        from       nonlocal   while</span><br><span class="line">assert     del        global     not        with</span><br><span class="line">async      elif       if         or         yield</span><br></pre></td></tr></table></figure>



<h3 id="2-3-2-保留的标识符类"><a href="#2-3-2-保留的标识符类" class="headerlink" title="2.3.2. 保留的标识符类"></a>2.3.2. 保留的标识符类</h3><p>某些标识符类 (除了关键字) 具有特殊的含义。这些标识符类的命名模式是以下划线字符打头和结尾:</p>
<ul>
<li><p><code>_*</code></p>
<p>不会被 <code>from module import *</code> 导入。特殊标识符 <code>_</code> 在交互式解释器中被用来存放最近一次求值结果；它保存在 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块中。当不处于交互模式时，<code>_</code> 无特殊含义也没有预定义。参见 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener">import 语句</a>。注解 <code>_</code> 作为名称常用于连接国际化文本；请参看 <a href="https://docs.python.org/zh-cn/3/library/gettext.html#module-gettext" target="_blank" rel="noopener"><code>gettext</code></a> 模块文档了解有关此约定的详情。</p>
</li>
<li><p><code>__*__</code></p>
<p>系统定义的名称。这些名称由解释器及其实现 (包括标准库) 所定义。现有系统定义名称相关讨论参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#specialnames" target="_blank" rel="noopener">特殊方法名称</a> 等章节。未来的 Python 版本中还将定义更多此类名称。<em>任何</em> 不遵循文档指定方式使用 <code>__*__</code> 名称的行为都可能导致无警告的出错。</p>
</li>
<li><p><code>__*</code></p>
<p>类的私有名称。这种名称在类定义中使用时，会以一种混合形式重写以避免在基类及派生类的 “私有” 属性之间出现名称冲突。参见 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#atom-identifiers" target="_blank" rel="noopener">标识符（名称）</a>。</p>
</li>
</ul>
<h2 id="2-4-字面值"><a href="#2-4-字面值" class="headerlink" title="2.4. 字面值"></a>2.4. 字面值</h2><p>字面值用于表示一些内置类型的常量。</p>
<h3 id="2-4-1-字符串和字节串字面值"><a href="#2-4-1-字符串和字节串字面值" class="headerlink" title="2.4.1. 字符串和字节串字面值"></a>2.4.1. 字符串和字节串字面值</h3><p>字符串字面值由以下词法定义进行描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">stringliteral   ::&#x3D;  [stringprefix](shortstring | longstring)</span><br><span class="line">stringprefix    ::&#x3D;  &quot;r&quot; | &quot;u&quot; | &quot;R&quot; | &quot;U&quot; | &quot;f&quot; | &quot;F&quot;</span><br><span class="line">                     | &quot;fr&quot; | &quot;Fr&quot; | &quot;fR&quot; | &quot;FR&quot; | &quot;rf&quot; | &quot;rF&quot; | &quot;Rf&quot; | &quot;RF&quot;</span><br><span class="line">shortstring     ::&#x3D;  &quot;&#39;&quot; shortstringitem* &quot;&#39;&quot; | &#39;&quot;&#39; shortstringitem* &#39;&quot;&#39;</span><br><span class="line">longstring      ::&#x3D;  &quot;&#39;&#39;&#39;&quot; longstringitem* &quot;&#39;&#39;&#39;&quot; | &#39;&quot;&quot;&quot;&#39; longstringitem* &#39;&quot;&quot;&quot;&#39;</span><br><span class="line">shortstringitem ::&#x3D;  shortstringchar | stringescapeseq</span><br><span class="line">longstringitem  ::&#x3D;  longstringchar | stringescapeseq</span><br><span class="line">shortstringchar ::&#x3D;  &lt;any source character except &quot;\&quot; or newline or the quote&gt;</span><br><span class="line">longstringchar  ::&#x3D;  &lt;any source character except &quot;\&quot;&gt;</span><br><span class="line">stringescapeseq ::&#x3D;  &quot;\&quot; &lt;any source character&gt;</span><br><span class="line">bytesliteral   ::&#x3D;  bytesprefix(shortbytes | longbytes)</span><br><span class="line">bytesprefix    ::&#x3D;  &quot;b&quot; | &quot;B&quot; | &quot;br&quot; | &quot;Br&quot; | &quot;bR&quot; | &quot;BR&quot; | &quot;rb&quot; | &quot;rB&quot; | &quot;Rb&quot; | &quot;RB&quot;</span><br><span class="line">shortbytes     ::&#x3D;  &quot;&#39;&quot; shortbytesitem* &quot;&#39;&quot; | &#39;&quot;&#39; shortbytesitem* &#39;&quot;&#39;</span><br><span class="line">longbytes      ::&#x3D;  &quot;&#39;&#39;&#39;&quot; longbytesitem* &quot;&#39;&#39;&#39;&quot; | &#39;&quot;&quot;&quot;&#39; longbytesitem* &#39;&quot;&quot;&quot;&#39;</span><br><span class="line">shortbytesitem ::&#x3D;  shortbyteschar | bytesescapeseq</span><br><span class="line">longbytesitem  ::&#x3D;  longbyteschar | bytesescapeseq</span><br><span class="line">shortbyteschar ::&#x3D;  &lt;any ASCII character except &quot;\&quot; or newline or the quote&gt;</span><br><span class="line">longbyteschar  ::&#x3D;  &lt;any ASCII character except &quot;\&quot;&gt;</span><br><span class="line">bytesescapeseq ::&#x3D;  &quot;\&quot; &lt;any ASCII character&gt;</span><br></pre></td></tr></table></figure>

<p>这些条目中未提及的一个语法限制是 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#grammar-token-stringprefix" target="_blank" rel="noopener"><code>stringprefix</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#grammar-token-bytesprefix" target="_blank" rel="noopener"><code>bytesprefix</code></a> 与字面值的剩余部分之间不允许有空白。源字符集是由编码声明定义的；如果源文件中没有编码声明则默认为 UTF-8；参见 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#encodings" target="_blank" rel="noopener">编码声明</a>。</p>
<p>自然语言描述: 两种字面值都可以用成对单引号 (<code>&#39;</code>) 或双引号 (<code>&quot;</code>) 来标示首尾。它们也可以用成对的连续三个单引号或双引号来标示首尾 (这通常被称为 <em>三引号字符串</em>)。反斜杠 (<code>\</code>) 字符被用来对特殊含义的字符进行转义，例如换行，反斜杠本身或是引号等字符。</p>
<p>字节串字面值总是带有前缀 <code>&#39;b&#39;</code> 或 <code>&#39;B&#39;</code>；它们生成 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型而非 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 类型的实例。它们只能包含 ASCII 字符；字节对应数值在128及以上必须以转义形式来表示。</p>
<p>字符串和字节串字面值都可以带有前缀 <code>&#39;r&#39;</code> 或 <code>&#39;R&#39;</code>；这种字符串被称为 <em>原始字符串</em> 其中的反斜杠会被当作其本身的字面字符来处理。因此在原始字符串字面值中，<code>&#39;\U&#39;</code> 和 <code>&#39;\u&#39;</code> 转义形式不会被特殊对待。由于 Python 2.x 的原始统一码字面值的特性与 Python 3.x 不一致，<code>&#39;ur&#39;</code> 语法已不再被支持。</p>
<p><em>3.3 新版功能:</em> 新加入了表示原始字节串的 <code>&#39;rb&#39;</code> 前缀，与 <code>&#39;br&#39;</code> 的意义相同。</p>
<p><em>3.3 新版功能:</em> 对旧式统一码字面值 (<code>u&#39;value&#39;</code>) 的支持被重新引入以简化 Python 2.x 和 3.x 代码库的同步维护。详情见 <a href="https://www.python.org/dev/peps/pep-0414" target="_blank" rel="noopener"><strong>PEP 414</strong></a>。</p>
<p>包含 <code>&#39;f&#39;</code> 或 <code>&#39;F&#39;</code> 前缀的字符串字面值称为 <em>格式化字符串字面值</em>；参见 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings" target="_blank" rel="noopener">格式化字符串字面值</a>。<code>&#39;f&#39;</code> 可与 <code>&#39;r&#39;</code> 连用，但不能与 <code>&#39;b&#39;</code> 或 <code>&#39;u&#39;</code> 连用，因此存在原始格式化字符串，但不存在格式化字节串字面值。</p>
<p>在三引号字面值中，允许存在未经转义的换行和引号 (并原样保留)，除非是未经转义的连续三引号，这标示着字面值的结束。 (“引号” 是用来标示字面值的字符，即 <code>&#39;</code> 或 <code>&quot;</code>。)</p>
<p>除非带有 <code>&#39;r&#39;</code> 或 <code>&#39;R&#39;</code> 前缀，字符串和字节串字面值中的转义序列会基于类似标准 C 中的转义规则来解读。可用的转义序列如下:</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">意义</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\newline</code></td>
<td align="left">反斜杠加换行全被忽略</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\\</code></td>
<td align="left">反斜杠 (<code>\</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\&#39;</code></td>
<td align="left">单引号 (<code>&#39;</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\&quot;</code></td>
<td align="left">双引号 (<code>&quot;</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\a</code></td>
<td align="left">ASCII 响铃 (BEL)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\b</code></td>
<td align="left">ASCII 退格 (BS)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\f</code></td>
<td align="left">ASCII 进纸 (FF)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\n</code></td>
<td align="left">ASCII 换行 (LF)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">ASCII 回车 (CR)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">ASCII 水平制表 (TAB)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\v</code></td>
<td align="left">ASCII 垂直制表 (VT)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\ooo</code></td>
<td align="left">八进制数 <em>ooo</em> 码位的字符</td>
<td align="left">(1,3)</td>
</tr>
<tr>
<td align="left"><code>\xhh</code></td>
<td align="left">十六进制数 <em>hh</em> 码位的字符</td>
<td align="left">(2,3)</td>
</tr>
</tbody></table>
<p>仅在字符串字面值中可用的转义序列如下:</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">意义</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\N{name}</code></td>
<td align="left">Unicode 数据库中名称为 <em>name</em> 的字符</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>\uxxxx</code></td>
<td align="left">16位十六进制数 <em>xxxx</em> 码位的字符</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>\Uxxxxxxxx</code></td>
<td align="left">32位16进制数 <em>xxxxxxxx</em> 码位的字符</td>
<td align="left">(6)</td>
</tr>
</tbody></table>
<p>注释:</p>
<ol>
<li>与标准 C 一致，接受最多三个八进制数码。</li>
<li>与标准 C 不同，要求必须为两个十六进制数码。</li>
<li>在字节串字面值中，十六进制数和八进制数转义码以相应数值代表每个字节。在字符串字面值中，这些转义码以相应数值代表每个 Unicode 字符。</li>
<li><em>在 3.3 版更改:</em> 加入了对别名 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#id13" target="_blank" rel="noopener">1</a> 的支持。</li>
<li>要求必须为四个十六进制数码。</li>
<li>此方式可用来表示任意 Unicode 字符。要求必须为八个十六进制数码。</li>
</ol>
<p>与标准 C 不同，所有无法识别的转义序列将原样保留在字符串中，也就是说，<em>反斜杠会在结果中保留</em>。(这种方式在调试时很有用: 如果输错了一个转义序列，更容易在输出结果中识别错误。) 另外要注意的一个关键点是：专用于字符串字面值中的转义序列如果在字节串字面值中出现，会被归类为无法识别的转义序列。</p>
<blockquote>
<p><em>在 3.6 版更改:</em> 无法识别的转义序列将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a>。 在某个未来的 Python 版本中它们将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxWarning" target="_blank" rel="noopener"><code>SyntaxWarning</code></a> 并最终将改为引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。</p>
</blockquote>
<p>即使在原始字面值中，引号也可以加上反斜杠转义符，但反斜杠会保留在输出结果中；例如 <code>r&quot;\&quot;&quot;</code> 是一个有效的字符串字面值，包含两个字符: 一个反斜杠和一个双引号；而 <code>r&quot;\&quot;</code> 不是一个有效的字符串字面值 (即便是原始字符串也不能以奇数个反斜杠结束)。特别地，<em>一个原始字面值不能以单个反斜杠结束</em> (因为此反斜杠会转义其后的引号字符)。还要注意一个反斜杠加一个换行在字面值中会被解释为两个字符，而 <em>不是</em> 一个连续行。</p>
<h3 id="2-4-2-字符串字面值拼接"><a href="#2-4-2-字符串字面值拼接" class="headerlink" title="2.4.2. 字符串字面值拼接"></a>2.4.2. 字符串字面值拼接</h3><p>多个相邻的字符串或字节串字面值 (以空白符分隔)，所用的引号可以彼此不同，其含义等同于全部拼接为一体。因此， <code>&quot;hello&quot; &#39;world&#39;</code> 等同于 <code>&quot;helloworld&quot;</code>。此特性可以减少反斜杠的使用，以方便地将很长的字符串分成多个物理行，甚至每部分字符串还可分别加注释，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">re.compile(&quot;[A-Za-z_]&quot;       # letter or underscore</span><br><span class="line">           &quot;[A-Za-z0-9_]*&quot;   # letter, digit or underscore</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>

<p>注意此特性是在句法层面定义的，但是在编译时实现。在运行时拼接字符串表达式必须使用 ‘+’ 运算符。还要注意字面值拼接时每个部分可以使用不同的引号风格 (甚至混合使用原始字符串和三引号字符串)，格式化字符串字面值也可与普通字符串字面值拼接。</p>
<h3 id="2-4-3-格式化字符串字面值"><a href="#2-4-3-格式化字符串字面值" class="headerlink" title="2.4.3. 格式化字符串字面值"></a>2.4.3. 格式化字符串字面值</h3><p><em>3.6 新版功能.</em></p>
<p><em>格式化字符串字面值</em> 或称 <em>f-string</em> 是带有 <code>&#39;f&#39;</code> 或 <code>&#39;F&#39;</code> 前缀的字符串字面值。这种字符串可包含替换字段，即以 <code>{}</code> 标示的表达式。而其他字符串字面值总是一个常量，格式化字符串字面值实际上是会在运行时被求值的表达式。</p>
<p>转义序列会像在普通字符串字面值中一样被解码 (除非字面值还被标示为原始字符串)。解码之后，字符串内容所用的语法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f_string          ::&#x3D;  (literal_char | &quot;&#123;&#123;&quot; | &quot;&#125;&#125;&quot; | replacement_field)*</span><br><span class="line">replacement_field ::&#x3D;  &quot;&#123;&quot; f_expression [&quot;!&quot; conversion] [&quot;:&quot; format_spec] &quot;&#125;&quot;</span><br><span class="line">f_expression      ::&#x3D;  (conditional_expression | &quot;*&quot; or_expr)</span><br><span class="line">                         (&quot;,&quot; conditional_expression | &quot;,&quot; &quot;*&quot; or_expr)* [&quot;,&quot;]</span><br><span class="line">                       | yield_expression</span><br><span class="line">conversion        ::&#x3D;  &quot;s&quot; | &quot;r&quot; | &quot;a&quot;</span><br><span class="line">format_spec       ::&#x3D;  (literal_char | NULL | replacement_field)*</span><br><span class="line">literal_char      ::&#x3D;  &lt;any code point except &quot;&#123;&quot;, &quot;&#125;&quot; or NULL&gt;</span><br></pre></td></tr></table></figure>

<p>字符串在花括号以外的部分按其字面值处理，除了双重花括号 <code>&#39;` 或 `&#39;</code> 会被替换为相应的单个花括号。单个左花括号 <code>&#39;{&#39;</code> 标示一个替换字段，它以一个 Python 表达式打头，表达式之后可能有一个以叹号 <code>&#39;!&#39;</code> 标示的转换字段。之后还可能带有一个以冒号 <code>&#39;:&#39;</code> 标示的格式说明符。替换字段以一个右花括号 <code>&#39;}&#39;</code> 作为结束。</p>
<p>格式化字符串字面值中的表达式会被当作包含在圆括号中的普通 Python 表达式一样处理，但有少数例外。 空表达式不被允许，<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 和赋值表达式 <code>:=</code> 必须显式地加上圆括号。 替换表达式可以包含换行（例如在三重引号字符串中），但是不能包含注释。 每个表达式会在格式化字符串字面值所包含的位置按照从左至右的顺序被求值。</p>
<p><em>在 3.7 版更改:</em> 在 Python 3.7 之前， <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式包含 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 子句的推导式不允许在格式化字符串字面值表达式中使用，这是因为具体实现存在一个问题。</p>
<p>如果指定了转换符，表达式的求值结果会先转换再格式化。转换符 <code>&#39;!s&#39;</code> 即对结果调用 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，<code>&#39;!r&#39;</code> 为调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>，而 <code>&#39;!a&#39;</code> 为调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#ascii" target="_blank" rel="noopener"><code>ascii()</code></a>。</p>
<p>在此之后结果会使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#format" target="_blank" rel="noopener"><code>format()</code></a> 协议进行格式化。格式说明符会被传入表达式或转换结果的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__format__" target="_blank" rel="noopener"><code>__format__()</code></a> 方法。如果省略格式说明符则会传入一个空字符串。然后格式化结果会包含在整个字符串最终的值当中。</p>
<p>顶层的格式说明符可以包含有嵌套的替换字段。这些嵌套字段也可以包含有自己的转换字段和 <a href="https://docs.python.org/zh-cn/3/library/string.html#formatspec" target="_blank" rel="noopener">格式说明符</a>，但不可再包含更深层嵌套的替换字段。这里的 <a href="https://docs.python.org/zh-cn/3/library/string.html#formatspec" target="_blank" rel="noopener">格式说明符微型语言</a> 与字符串 .format() 方法所使用的相同。</p>
<p>格式化字符串字面值可以拼接，但是一个替换字段不能拆分到多个字面值。</p>
<p>一些格式化字符串字面值的示例:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name &#x3D; &quot;Fred&quot;</span><br><span class="line">&gt;&gt;&gt; f&quot;He said his name is &#123;name!r&#125;.&quot;</span><br><span class="line">&quot;He said his name is &#39;Fred&#39;.&quot;</span><br><span class="line">&gt;&gt;&gt; f&quot;He said his name is &#123;repr(name)&#125;.&quot;  # repr() is equivalent to !r</span><br><span class="line">&quot;He said his name is &#39;Fred&#39;.&quot;</span><br><span class="line">&gt;&gt;&gt; width &#x3D; 10</span><br><span class="line">&gt;&gt;&gt; precision &#x3D; 4</span><br><span class="line">&gt;&gt;&gt; value &#x3D; decimal.Decimal(&quot;12.34567&quot;)</span><br><span class="line">&gt;&gt;&gt; f&quot;result: &#123;value:&#123;width&#125;.&#123;precision&#125;&#125;&quot;  # nested fields</span><br><span class="line">&#39;result:      12.35&#39;</span><br><span class="line">&gt;&gt;&gt; today &#x3D; datetime(year&#x3D;2017, month&#x3D;1, day&#x3D;27)</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;today:%B %d, %Y&#125;&quot;  # using date format specifier</span><br><span class="line">&#39;January 27, 2017&#39;</span><br><span class="line">&gt;&gt;&gt; number &#x3D; 1024</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;number:#0x&#125;&quot;  # using integer format specifier</span><br><span class="line">&#39;0x400&#39;</span><br></pre></td></tr></table></figure>

<p>与正常字符串字面值采用相同语法导致的一个结果就是替换字段中的字符不能与外部的格式化字符串字面值所用的引号相冲突:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f&quot;abc &#123;a[&quot;x&quot;]&#125; def&quot;    # error: outer string literal ended prematurely</span><br><span class="line">f&quot;abc &#123;a[&#39;x&#39;]&#125; def&quot;    # workaround: use different quoting</span><br></pre></td></tr></table></figure>

<p>格式表达式中不允许有反斜杠，这会引发错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f&quot;newline: &#123;ord(&#39;\n&#39;)&#125;&quot;  # raises SyntaxError</span><br></pre></td></tr></table></figure>

<p>想包含需要用反斜杠转义的值，可以创建一个临时变量。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; newline &#x3D; ord(&#39;\n&#39;)</span><br><span class="line">&gt;&gt;&gt; f&quot;newline: &#123;newline&#125;&quot;</span><br><span class="line">&#39;newline: 10&#39;</span><br></pre></td></tr></table></figure>

<p>格式化字符串字面值不可用作文档字符串，即便其中没有包含表达式。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...     f&quot;Not a docstring&quot;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; foo.__doc__ is None</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>另请参见 <a href="https://www.python.org/dev/peps/pep-0498" target="_blank" rel="noopener"><strong>PEP 498</strong></a> 了解加入格式化字符串字面值的提议，以及使用了相关的格式字符串机制的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a>。</p>
<h3 id="2-4-4-数字字面值"><a href="#2-4-4-数字字面值" class="headerlink" title="2.4.4. 数字字面值"></a>2.4.4. 数字字面值</h3><p>数字字面值有三种类型: 整型数、浮点数和虚数。没有专门的复数字面值 (复数可由一个实数加一个虚数合成)。</p>
<p>注意数字字面值并不包含正负号；<code>-1</code> 这样的负数实际上是由单目运算符 ‘<code>-</code>‘ 和字面值 <code>1</code> 合成的。</p>
<h3 id="2-4-5-整型数字面值"><a href="#2-4-5-整型数字面值" class="headerlink" title="2.4.5. 整型数字面值"></a>2.4.5. 整型数字面值</h3><p>整型数字面值由以下词法定义进行描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">integer      ::&#x3D;  decinteger | bininteger | octinteger | hexinteger</span><br><span class="line">decinteger   ::&#x3D;  nonzerodigit ([&quot;_&quot;] digit)* | &quot;0&quot;+ ([&quot;_&quot;] &quot;0&quot;)*</span><br><span class="line">bininteger   ::&#x3D;  &quot;0&quot; (&quot;b&quot; | &quot;B&quot;) ([&quot;_&quot;] bindigit)+</span><br><span class="line">octinteger   ::&#x3D;  &quot;0&quot; (&quot;o&quot; | &quot;O&quot;) ([&quot;_&quot;] octdigit)+</span><br><span class="line">hexinteger   ::&#x3D;  &quot;0&quot; (&quot;x&quot; | &quot;X&quot;) ([&quot;_&quot;] hexdigit)+</span><br><span class="line">nonzerodigit ::&#x3D;  &quot;1&quot;...&quot;9&quot;</span><br><span class="line">digit        ::&#x3D;  &quot;0&quot;...&quot;9&quot;</span><br><span class="line">bindigit     ::&#x3D;  &quot;0&quot; | &quot;1&quot;</span><br><span class="line">octdigit     ::&#x3D;  &quot;0&quot;...&quot;7&quot;</span><br><span class="line">hexdigit     ::&#x3D;  digit | &quot;a&quot;...&quot;f&quot; | &quot;A&quot;...&quot;F&quot;</span><br></pre></td></tr></table></figure>

<p>整型数字面值的长度没有限制，能一直大到占满可用内存。</p>
<p>在确定数字大小时字面值中的下划线会被忽略。它们可用来将数码分组以提高可读性。一个下划线可放在数码之间，也可放在基数说明符例如 <code>0x</code> 之后。</p>
<p>注意非零的十进制数开头不允许有额外的零。这是为了避免与 Python 在版本 3.0 之前所使用的 C 风格八进制字面值相混淆。</p>
<p>一些整型数字面值的示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7     2147483647                        0o177    0b100110111</span><br><span class="line">3     79228162514264337593543950336     0o377    0xdeadbeef</span><br><span class="line">      100_000_000_000                   0b_1110_0101</span><br></pre></td></tr></table></figure>

<p><em>在 3.6 版更改:</em> 允许在字面值中使用下划线进行分组。</p>
<h3 id="2-4-6-浮点数字面值"><a href="#2-4-6-浮点数字面值" class="headerlink" title="2.4.6. 浮点数字面值"></a>2.4.6. 浮点数字面值</h3><p>浮点数字面值由以下词法定义进行描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">floatnumber   ::&#x3D;  pointfloat | exponentfloat</span><br><span class="line">pointfloat    ::&#x3D;  [digitpart] fraction | digitpart &quot;.&quot;</span><br><span class="line">exponentfloat ::&#x3D;  (digitpart | pointfloat) exponent</span><br><span class="line">digitpart     ::&#x3D;  digit ([&quot;_&quot;] digit)*</span><br><span class="line">fraction      ::&#x3D;  &quot;.&quot; digitpart</span><br><span class="line">exponent      ::&#x3D;  (&quot;e&quot; | &quot;E&quot;) [&quot;+&quot; | &quot;-&quot;] digitpart</span><br></pre></td></tr></table></figure>

<p>注意整型数部分和指数部分在解析时总是以 10 为基数。例如，<code>077e010</code> 是合法的，且表示的数值与 <code>77e10</code> 相同。浮点数字面值允许的范围依赖于具体实现。对于整型数字面值，支持以下划线进行分组。</p>
<p>一些浮点数字面值的示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.14    10.    .001    1e100    3.14e-10    0e0    3.14_15_93</span><br></pre></td></tr></table></figure>

<p><em>在 3.6 版更改:</em> 允许在字面值中使用下划线进行分组。</p>
<h3 id="2-4-7-虚数字面值"><a href="#2-4-7-虚数字面值" class="headerlink" title="2.4.7. 虚数字面值"></a>2.4.7. 虚数字面值</h3><p>虚数字面值由以下词法定义进行描述:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imagnumber ::&#x3D;  (floatnumber | digitpart) (&quot;j&quot; | &quot;J&quot;)</span><br></pre></td></tr></table></figure>

<p>一个虚数字面值将生成一个实部为 0.0 的复数。复数是以一对浮点数来表示的，它们的取值范围相同。要创建一个实部不为零的复数，就加上一个浮点数，例如 <code>(3+4j)</code>。一些虚数字面值的示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j</span><br></pre></td></tr></table></figure>



<h2 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5. 运算符"></a>2.5. 运算符</h2><p>以下形符属于运算符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+       -       *       **      &#x2F;       &#x2F;&#x2F;      %      @</span><br><span class="line">&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~       :&#x3D;</span><br><span class="line">&lt;       &gt;       &lt;&#x3D;      &gt;&#x3D;      &#x3D;&#x3D;      !&#x3D;</span><br></pre></td></tr></table></figure>



<h2 id="2-6-分隔符"><a href="#2-6-分隔符" class="headerlink" title="2.6. 分隔符"></a>2.6. 分隔符</h2><p>以下形符在语法中归类为分隔符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(       )       [       ]       &#123;       &#125;</span><br><span class="line">,       :       .       ;       @       &#x3D;       -&gt;</span><br><span class="line">+&#x3D;      -&#x3D;      *&#x3D;      &#x2F;&#x3D;      &#x2F;&#x2F;&#x3D;     %&#x3D;      @&#x3D;</span><br><span class="line">&amp;&#x3D;      |&#x3D;      ^&#x3D;      &gt;&gt;&#x3D;     &lt;&lt;&#x3D;     **&#x3D;</span><br></pre></td></tr></table></figure>

<p>句点也可出现于浮点数和虚数字面值中。连续三个句点有表示一个省略符的特殊含义。以上列表的后半部分为增强赋值操作符，在词法中作为分隔符，但也起到运算作用。</p>
<p>以下可打印 ASCII 字符作为其他形符的组成部分时具有特殊含义，或是对词法分析器有重要意义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;       &quot;       #       \</span><br></pre></td></tr></table></figure>

<p>以下可打印 ASCII 字符不在 Python 词法中使用。如果出现于字符串字面值和注释之外将无条件地引发错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$       ?       &#96;</span><br></pre></td></tr></table></figure>

<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#id10" target="_blank" rel="noopener">1</a></p>
<p><a href="http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt" target="_blank" rel="noopener">http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt</a></p>
</li>
</ul>
<h1 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3. 数据模型"></a>3. 数据模型</h1><h2 id="3-1-对象、值与类型"><a href="#3-1-对象、值与类型" class="headerlink" title="3.1. 对象、值与类型"></a>3.1. 对象、值与类型</h2><p><em>对象</em> 是 Python 中对数据的抽象。Python 程序中的所有数据都是由对象或对象间关系来表示的。（从某种意义上说，按照冯·诺依曼的 “存储程序计算机” 模型，代码本身也是由对象来表示的。）</p>
<p>每个对象都有各自的编号、类型和值。一个对象被创建后，它的 <em>编号</em> 就绝不会改变；你可以将其理解为该对象在内存中的地址。 ‘<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#is" target="_blank" rel="noopener"><code>is</code></a>‘ 运算符可以比较两个对象的编号是否相同；<a href="https://docs.python.org/zh-cn/3/library/functions.html#id" target="_blank" rel="noopener"><code>id()</code></a> 函数能返回一个代表其编号的整型数。</p>
<p><strong>CPython implementation detail:</strong> 在 CPython 中，<code>id(x)</code> 就是存放 <code>x</code> 的内存的地址。</p>
<p>对象的类型决定该对象所支持的操作 (例如 “对象是否有长度属性？”) 并且定义了该类型的对象可能的取值。<a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type()</code></a> 函数能返回一个对象的类型 (类型本身也是对象)。与编号一样，一个对象的 <em>类型</em> 也是不可改变的。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id8" target="_blank" rel="noopener">1</a></p>
<p>有些对象的 <em>值</em> 可以改变。值可以改变的对象被称为 <em>可变的</em>；值不可以改变的对象就被称为 <em>不可变的</em>。(一个不可变容器对象如果包含对可变对象的引用，当后者的值改变时，前者的值也会改变；但是该容器仍属于不可变对象，因为它所包含的对象集是不会改变的。因此，不可变并不严格等同于值不能改变，实际含义要更微妙。) 一个对象的可变性是由其类型决定的；例如，数字、字符串和元组是不可变的，而字典和列表是可变的。</p>
<p>对象绝不会被显式地销毁；然而，当无法访问时它们可能会被作为垃圾回收。允许具体的实现推迟垃圾回收或完全省略此机制 — 如何实现垃圾回收是实现的质量问题，只要可访问的对象不会被回收即可。</p>
<p><strong>CPython implementation detail:</strong> CPython 目前使用带有 (可选) 延迟检测循环链接垃圾的引用计数方案，会在对象不可访问时立即回收其中的大部分，但不保证回收包含循环引用的垃圾。请查看 <a href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc" target="_blank" rel="noopener"><code>gc</code></a> 模块的文档了解如何控制循环垃圾的收集相关信息。其他实现会有不同的行为方式，CPython 现有方式也可能改变。不要依赖不可访问对象的立即终结机制 (所以你应当总是显式地关闭文件)。</p>
<p>注意：使用实现的跟踪或调试功能可能令正常情况下会被回收的对象继续存活。还要注意通过 ‘<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a>…<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a>‘ 语句捕捉异常也可能令对象保持存活。</p>
<p>有些对象包含对 “外部” 资源的引用，例如打开文件或窗口。当对象被作为垃圾回收时这些资源也应该会被释放，但由于垃圾回收并不确保发生，这些对象还提供了明确地释放外部资源的操作，通常为一个 <code>close()</code> 方法。强烈推荐在程序中显式关闭此类对象。’<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a>…<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a>‘ 语句和 ‘<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a>‘ 语句提供了进行此种操作的更便捷方式。</p>
<p>有些对象包含对其他对象的引用；它们被称为 <em>容器</em>。容器的例子有元组、列表和字典等。这些引用是容器对象值的组成部分。在多数情况下，当谈论一个容器的值时，我们是指所包含对象的值而不是其编号；但是，当我们谈论一个容器的可变性时，则仅指其直接包含的对象的编号。因此，如果一个不可变容器 (例如元组) 包含对一个可变对象的引用，则当该可变对象被改变时容器的值也会改变。</p>
<p>类型会影响对象行为的几乎所有方面。甚至对象编号的重要性也在某种程度上受到影响: 对于不可变类型，会得出新值的运算实际上会返回对相同类型和取值的任一现有对象的引用，而对于可变类型来说这是不允许的。例如在 <code>a = 1; b = 1</code> 之后，<code>a</code> 和 <code>b</code> 可能会也可能不会指向同一个值为一的对象，这取决于具体实现，但是在 <code>c = []; d = []</code> 之后，<code>c</code> 和 <code>d</code> 保证会指向两个不同、单独的新建空列表。(请注意 <code>c = d = []</code> 则是将同一个对象赋值给 <code>c</code> 和 <code>d</code>。)</p>
<h2 id="3-2-标准类型层级结构"><a href="#3-2-标准类型层级结构" class="headerlink" title="3.2. 标准类型层级结构"></a>3.2. 标准类型层级结构</h2><p>以下是 Python 内置类型的列表。扩展模块 (具体实现会以 C, Java 或其他语言编写) 可以定义更多的类型。未来版本的 Python 可能会加入更多的类型 (例如有理数、高效存储的整型数组等等)，不过新增类型往往都是通过标准库来提供的。</p>
<p>以下部分类型的描述中包含有 ‘特殊属性列表’ 段落。这些属性提供对具体实现的访问而非通常使用。它们的定义在未来可能会改变。</p>
<ul>
<li><p>None</p>
<p>此类型只有一种取值。是一个具有此值的单独对象。此对象通过内置名称 <code>None</code> 访问。在许多情况下它被用来表示空值，例如未显式指明返回值的函数将返回 None。它的逻辑值为假。</p>
</li>
<li><p>NotImplemented</p>
<p>此类型只有一种取值。是一个具有此值的单独对象。此对象通过内置名称 <code>NotImplemented</code> 访问。数值方法和丰富比较方法如未实现指定运算符表示的运算则应返回此值。(解释器会根据指定运算符继续尝试反向运算或其他回退操作)。它的逻辑值为真。详情参见 <a href="https://docs.python.org/zh-cn/3/library/numbers.html#implementing-the-arithmetic-operations" target="_blank" rel="noopener">实现算数运算</a>。</p>
</li>
<li><p>Ellipsis</p>
<p>此类型只有一种取值。是一个具有此值的单独对象。此对象通过字面值 <code>...</code> 或内置名称 <code>Ellipsis</code> 访问。它的逻辑值为真。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Number" target="_blank" rel="noopener"><code>numbers.Number</code></a></p>
<p>此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结果。数字对象是不可变的；一旦创建其值就不再改变。Python 中的数字当然非常类似数学中的数字，但也受限于计算机中的数字表示方法。Python 区分整型数、浮点型数和复数:<a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>numbers.Integral</code></a>此类对象表示数学中整数集合的成员 (包括正数和负数)。整型数可细分为两种类型:整型 (<a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>)此类对象表示任意大小的数字，仅受限于可用的内存 (包括虚拟内存)。在变换和掩码运算中会以二进制表示，负数会以 2 的补码表示，看起来像是符号位向左延伸补满空位。布尔型 (<a href="https://docs.python.org/zh-cn/3/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a>)此类对象表示逻辑值 False 和 True。代表 <code>False</code> 和 <code>True</code> 值的两个对象是唯二的布尔对象。布尔类型是整型的子类型，两个布尔值在各种场合的行为分别类似于数值 0 和 1，例外情况只有在转换为字符串时分别返回字符串 <code>&quot;False&quot;</code> 或 <code>&quot;True&quot;</code>。整型数表示规则的目的是在涉及负整型数的变换和掩码运算时提供最为合理的解释。<a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>numbers.Real</code></a> (<a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>)此类对象表示机器级的双精度浮点数。其所接受的取值范围和溢出处理将受制于底层的机器架构 (以及 C 或 Java 实现)。Python 不支持单精度浮点数；支持后者通常的理由是节省处理器和内存消耗，但这点节省相对于在 Python 中使用对象的开销来说太过微不足道，因此没有理由包含两种浮点数而令该语言变得复杂。<a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>numbers.Complex</code></a> (<a href="https://docs.python.org/zh-cn/3/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a>)此类对象以一对机器级的双精度浮点数来表示复数值。有关浮点数的附带规则对其同样有效。一个复数值 <code>z</code> 的实部和虚部可通过只读属性 <code>z.real</code> 和 <code>z.imag</code> 来获取。</p>
</li>
<li><p>序列</p>
<p>此类对象表示以非负整数作为索引的有限有序集。内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 可返回一个序列的条目数量。当一个序列的长度为 <em>n</em> 时，索引集包含数字 0, 1, …, <em>n</em>-1。序列 <em>a</em> 的条目 <em>i</em> 可通过 <code>a[i]</code> 选择。序列还支持切片: <code>a[i:j]</code> 选择索引号为 <em>k</em> 的所有条目，<em>i</em> <code>&lt;=</code> <em>k</em> <code>&lt;</code> <em>j</em>。当用作表达式时，序列的切片就是一个与序列类型相同的新序列。新序列的索引还是从 0 开始。有些序列还支持带有第三个 “step” 形参的 “扩展切片”: <code>a[i:j:k]</code> 选择 <em>a</em> 中索引号为 <em>x</em> 的所有条目，<code>x = i + n*k</code>, <em>n</em> <code>&gt;=</code> <code>0</code> 且 <em>i</em> <code>&lt;=</code> <em>x</em> <code>&lt;</code> <em>j</em>。序列可根据其可变性来加以区分:不可变序列不可变序列类型的对象一旦创建就不能再改变。(如果对象包含对其他对象的引用，其中的可变对象就是可以改变的；但是，一个不可变对象所直接引用的对象集是不能改变的。)以下类型属于不可变对象:字符串字符串是由 Unicode 码位值组成的序列。范围在 <code>U+0000 - U+10FFFF</code> 之内的所有码位值都可在字符串中使用。Python 没有 <code>char</code> 类型；而是将字符串中的每个码位表示为一个长度为 <code>1</code> 的字符串对象。内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#ord" target="_blank" rel="noopener"><code>ord()</code></a> 可将一个码位由字符串形式转换成一个范围在 <code>0 - 10FFFF</code> 之内的整型数；<a href="https://docs.python.org/zh-cn/3/library/functions.html#chr" target="_blank" rel="noopener"><code>chr()</code></a> 可将一个范围在 <code>0 - 10FFFF</code> 之内的整型数转换为长度为 <code>1</code> 的对应字符串对象。<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.encode" target="_blank" rel="noopener"><code>str.encode()</code></a> 可以使用指定的文本编码将 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，而 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.decode" target="_blank" rel="noopener"><code>bytes.decode()</code></a> 则可以实现反向的解码。元组一个元组中的条目可以是任意 Python 对象。包含两个或以上条目的元组由逗号分隔的表达式构成。只有一个条目的元组 (‘单项元组’) 可通过在表达式后加一个逗号来构成 (一个表达式本身不能创建为元组，因为圆括号要用来设置表达式分组)。一个空元组可通过一对内容为空的圆括号创建。字节串字节串对象是不可变的数组。其中每个条目都是一个 8 位字节，以取值范围 0 &lt;= x &lt; 256 的整型数表示。字节串字面值 (例如 <code>b&#39;abc&#39;</code>) 和内置的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes()</code></a> 构造器可被用来创建字节串对象。字节串对象还可以通过 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes.decode" target="_blank" rel="noopener"><code>decode()</code></a> 方法解码为字符串。可变序列可变序列在被创建后仍可被改变。下标和切片标注可被用作赋值和 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> (删除) 语句的目标。目前有两种内生可变序列类型:列表列表中的条目可以是任意 Python 对象。列表由用方括号括起并由逗号分隔的多个表达式构成。(注意创建长度为 0 或 1 的列表无需使用特殊规则。)字节数组字节数组对象属于可变数组。可以通过内置的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray()</code></a> 构造器来创建。除了是可变的 (因而也是不可哈希的)，在其他方面字节数组提供的接口和功能都于不可变的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象一致。扩展模块 <a href="https://docs.python.org/zh-cn/3/library/array.html#module-array" target="_blank" rel="noopener"><code>array</code></a> 提供了一个额外的可变序列类型示例，<a href="https://docs.python.org/zh-cn/3/library/collections.html#module-collections" target="_blank" rel="noopener"><code>collections</code></a> 模块也是如此。</p>
</li>
<li><p>集合类型</p>
<p>此类对象表示由不重复且不可变对象组成的无序且有限的集合。因此它们不能通过下标来索引。但是它们可被迭代，也可用内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 返回集合中的条目数。集合常见的用处是快速成员检测，去除序列中的重复项，以及进行交、并、差和对称差等数学运算。对于集合元素所采用的不可变规则与字典的键相同。注意数字类型遵循正常的数字比较规则: 如果两个数字相等 (例如 <code>1</code> 和 <code>1.0</code>)，则同一集合中只能包含其中一个。目前有两种内生集合类型:集合此类对象表示可变集合。它们可通过内置的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set()</code></a> 构造器创建，并且创建之后可以通过方法进行修改，例如 <code>add()</code>。冻结集合此类对象表示不可变集合。它们可通过内置的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset" target="_blank" rel="noopener"><code>frozenset()</code></a> 构造器创建。由于 frozenset 对象不可变且 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>，它可以被用作另一个集合的元素或是字典的键。</p>
</li>
<li><p>映射</p>
<p>此类对象表示由任意索引集合所索引的对象的集合。通过下标 <code>a[k]</code> 可在映射 <code>a</code> 中选择索引为 <code>k</code> 的条目；这可以在表达式中使用，也可作为赋值或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句的目标。内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 可返回一个映射中的条目数。目前只有一种内生映射类型:字典此类对象表示由几乎任意值作为索引的有限个对象的集合。不可作为键的值类型只有包含列表或字典或其他可变类型，通过值而非对象编号进行比较的值，其原因在于高效的字典实现需要使用键的哈希值以保持一致性。用作键的数字类型遵循正常的数字比较规则: 如果两个数字相等 (例如 <code>1</code> 和 <code>1.0</code>) 则它们均可来用来索引同一个字典条目。字典是可变的；它们可通过 <code>{...}</code> 标注来创建 (参见 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#dict" target="_blank" rel="noopener">字典显示</a> 小节)。扩展模块 <a href="https://docs.python.org/zh-cn/3/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 提供了额外的映射类型示例，<a href="https://docs.python.org/zh-cn/3/library/collections.html#module-collections" target="_blank" rel="noopener"><code>collections</code></a> 模块也是如此。</p>
</li>
<li><p>可调用类型</p>
<p>此类型可以被应用于函数调用操作 (参见 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#calls" target="_blank" rel="noopener">调用</a> 小节):用户定义函数用户定义函数对象可通过函数定义来创建 (参见 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" target="_blank" rel="noopener">函数定义</a> 小节)。它被调用时应附带一个参数列表，其中包含的条目应与函数所定义的形参列表一致。特殊属性:属性意义<code>__doc__</code>该函数的文档字符串，没有则为 <code>None</code>；不会被子类继承。可写<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#definition.__name__" target="_blank" rel="noopener"><code>__name__</code></a>该函数的名称。可写<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#definition.__qualname__" target="_blank" rel="noopener"><code>__qualname__</code></a>该函数的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-qualified-name" target="_blank" rel="noopener">qualified name</a>。<em>3.3 新版功能.<em>可写<code>__module__</code>该函数所属模块的名称，没有则为 <code>None</code>。可写<code>__defaults__</code>由具有默认值的参数的默认参数值组成的元组，如无任何参数具有默认值则为 <code>None</code>。可写<code>__code__</code>表示编译后的函数体的代码对象。可写<code>__globals__</code>对存放该函数中全局变量的字典的引用 — 函数所属模块的全局命名空间。只读<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a>命名空间支持的函数属性。可写<code>__closure__``None</code> 或包含该函数可用变量的绑定的单元的元组。有关 <code>cell_contents</code> 属性的详情见下。只读<code>__annotations__</code>包含参数标注的字典。字典的键是参数名，如存在返回标注则为 <code>&#39;return&#39;</code>。可写<code>__kwdefaults__</code>仅包含关键字参数默认值的字典。可写大部分标有 “Writable” 的属性均会检查赋值的类型。函数对象也支持获取和设置任意属性，例如这可以被用来给函数附加元数据。使用正规的属性点号标注获取和设置此类属性。</em>注意当前实现仅支持用户定义函数属性。未来可能会增加支持内置函数属性。*单元对象具有 <code>cell_contents</code> 属性。这可被用来获取以及设置单元的值。有关函数定义的额外信息可以从其代码对象中提取；参见下文对内部类型的描述。 <a href="https://docs.python.org/zh-cn/3/library/types.html#types.CellType" target="_blank" rel="noopener"><code>cell</code></a> 类型可以在 <a href="https://docs.python.org/zh-cn/3/library/types.html#module-types" target="_blank" rel="noopener"><code>types</code></a> 模块中访问。实例方法实例方法用于结合类、类实例和任何可调用对象 (通常为用户定义函数)。特殊的只读属性: <code>__self__</code> 为类实例对象本身，<code>__func__</code> 为函数对象；<code>__doc__</code> 为方法的文档 (与 <code>__func__.__doc__</code> 作用相同)；<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#definition.__name__" target="_blank" rel="noopener"><code>__name__</code></a> 为方法名称 (与 <code>__func__.__name__</code> 作用相同)；<code>__module__</code> 为方法所属模块的名称，没有则为 <code>None</code>。方法还支持获取 (但不能设置) 下层函数对象的任意函数属性。用户定义方法对象可在获取一个类的属性时被创建 (也可能通过该类的一个实例)，如果该属性为用户定义函数对象或类方法对象。当通过从类实例获取一个用户定义函数对象的方式创建一个实例方法对象时，类实例对象的 <code>__self__</code> 属性即为该实例，并会绑定方法对象。该新建方法的 <code>__func__</code> 属性就是原来的函数对象。当通过从类或实例获取一个类方法对象的方式创建一个实例对象时，实例对象的 <code>__self__</code> 属性为该类本身，其 <code>__func__</code> 属性为类方法对应的下层函数对象。当一个实例方法对象被调用时，会调用对应的下层函数 (<code>__func__</code>)，并将类实例 (<code>__self__</code>) 插入参数列表的开头。例如，当 <code>C</code> 是一个包含了 <code>f()</code> 函数定义的类，而 <code>x</code> 是 <code>C</code> 的一个实例，则调用 <code>x.f(1)</code> 就等同于调用 <code>C.f(x, 1)</code>。当一个实例方法对象是衍生自一个类方法对象时，保存在 <code>__self__</code> 中的 “类实例” 实际上会是该类本身，因此无论是调用 <code>x.f(1)</code> 还是 <code>C.f(1)</code> 都等同于调用 <code>f(C,1)</code>，其中 <code>f</code> 为对应的下层函数。请注意从函数对象到实例方法对象的变换会在每一次从实例获取属性时发生。在某些情况下，一种高效的优化方式是将属性赋值给一个本地变量并调用该本地变量。还要注意这样的变换只发生于用户定义函数；其他可调用对象 (以及所有不可调用对象) 在被获取时都不会发生变换。还有一个需要关注的要点是作为一个类实例属性的用户定义函数不会被转换为绑定方法；这样的变换 *仅当</em> 函数是类属性时才会发生。生成器函数一个使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 语句 （见 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener">yield 语句</a> 章节）的函数或方法被称作一个 <em>生成器函数<em>。 这样的函数在被调用时，总是返回一个可以执行函数体的迭代器对象：调用该迭代器的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>iterator.__next__()</code></a> 方法将会导致这个函数一直运行直到它使用 <code>yield</code> 语句提供了一个值为止。 当这个函数执行 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句或者执行到末尾时，将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常并且这个迭代器将到达所返回的值集合的末尾。协程函数使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 来定义的函数或方法就被称为 *协程函数</em>。这样的函数在被调用时会返回一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象。它可能包含 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式以及 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-with" target="_blank" rel="noopener"><code>async with</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 语句。详情可参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#coroutine-objects" target="_blank" rel="noopener">协程对象</a> 一节。异步生成器函数使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 来定义并包含 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 语句的函数或方法就被称为 <em>异步生成器函数</em>。这样的函数在被调用时会返回一个异步迭代器对象，该对象可在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 语句中用来执行函数体。调用异步迭代器的 <code>aiterator.__anext__()</code> 方法将会返回一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a>，此对象会在被等待时执行直到使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 表达式输出一个值。当函数执行时到空的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句或是最后一条语句时，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a> 异常，异步迭代器也会到达要输出的值集合的末尾。内置函数内置函数对象是对于 C 函数的外部封装。内置函数的例子包括 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/math.html#math.sin" target="_blank" rel="noopener"><code>math.sin()</code></a> (<a href="https://docs.python.org/zh-cn/3/library/math.html#module-math" target="_blank" rel="noopener"><code>math</code></a> 是一个标准内置模块)。内置函数参数的数量和类型由 C 函数决定。特殊的只读属性: <code>__doc__</code> 是函数的文档字符串，如果没有则为 <code>None</code>; <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#definition.__name__" target="_blank" rel="noopener"><code>__name__</code></a> 是函数的名称; <code>__self__</code> 设定为 <code>None</code> (参见下一条目); <code>__module__</code> 是函数所属模块的名称，如果没有则为 <code>None</code>。内置方法此类型实际上是内置函数的另一种形式，只不过还包含了一个传入 C 函数的对象作为隐式的额外参数。内置方法的一个例子是 <code>alist.append()</code>，其中 *alist</em> 为一个列表对象。在此示例中，特殊的只读属性 <code>__self__</code> 会被设为 <em>alist</em> 所标记的对象。类类是可调用的。此种对象通常是作为“工厂”来创建自身的实例，类也可以有重载 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 的变体类型。调用的参数会传给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>，而且通常也会传给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 来初始化新的实例。类实例任意类的实例通过在所属类中定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__call__" target="_blank" rel="noopener"><code>__call__()</code></a> 方法即能成为可调用的对象。</p>
</li>
<li><p>模块</p>
<p>模块是 Python 代码的基本组织单元，由 <a href="https://docs.python.org/zh-cn/3/reference/import.html#importsystem" target="_blank" rel="noopener">导入系统</a> 创建，由 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句发起调用，或者通过 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module" target="_blank" rel="noopener"><code>importlib.import_module()</code></a> 和内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 等函数发起调用。 模块对象具有由字典对象实现的命名空间（这是被模块中定义的函数的 <code>__globals__</code> 属性引用的字典）。 属性引用被转换为该字典中的查找，例如 <code>m.x</code> 相当于 <code>m.__dict__[&quot;x&quot;]</code>。 模块对象不包含用于初始化模块的代码对象（因为初始化完成后不需要它）。属性赋值会更新模块的命名空间字典，例如 <code>m.x = 1</code> 等同于 <code>m.__dict__[&quot;x&quot;] = 1</code>。预定义的 (可写) 属性: <a href="https://docs.python.org/zh-cn/3/reference/import.html#__name__" target="_blank" rel="noopener"><code>__name__</code></a> 为模块的名称; <code>__doc__</code> 为模块的文档字符串，如果没有则为 <code>None</code>; <code>__annotations__</code> (可选) 为一个包含 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-variable-annotation" target="_blank" rel="noopener">变量标注</a> 的字典，它是在模块体执行时获取的; <a href="https://docs.python.org/zh-cn/3/reference/import.html#__file__" target="_blank" rel="noopener"><code>__file__</code></a> 是模块对应的被加载文件的路径名，如果它是加载自一个文件的话。某些类型的模块可能没有 <a href="https://docs.python.org/zh-cn/3/reference/import.html#__file__" target="_blank" rel="noopener"><code>__file__</code></a> 属性，例如 C 模块是静态链接到解释器内部的; 对于从一个共享库动态加载的扩展模块来说该属性为该共享库文件的路径名。特殊的只读属性: <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 为以字典对象表示的模块命名空间。<strong>CPython implementation detail:</strong> 由于 CPython 清理模块字典的设定，当模块离开作用域时模块字典将会被清理，即使该字典还有活动的引用。想避免此问题，可复制该字典或保持模块状态以直接使用其字典。</p>
</li>
<li><p>自定义类</p>
<p>自定义类这种类型一般通过类定义来创建 (参见 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class" target="_blank" rel="noopener">类定义</a> 一节)。每个类都有通过一个字典对象实现的独立命名空间。类属性引用会被转化为在此字典中查找，例如 <code>C.x</code> 会被转化为 <code>C.__dict__[&quot;x&quot;]</code> (不过也存在一些钩子对象以允许其他定位属性的方式)。当未在其中发现某个属性名称时，会继续在基类中查找。这种基类查找使用 C3 方法解析顺序，即使存在 ‘钻石形’ 继承结构即有多条继承路径连到一个共同祖先也能保持正确的行为。有关 Python 使用的 C3 MRO 的详情可查看配合 2.3 版发布的文档 <a href="https://www.python.org/download/releases/2.3/mro/.当一个类属性引用" target="_blank" rel="noopener">https://www.python.org/download/releases/2.3/mro/.当一个类属性引用</a> (假设类名为 <code>C</code>) 会产生一个类方法对象时，它将转化为一个 <code>__self__</code> 属性为 <code>C</code> 的实例方法对象。当其会产生一个静态方法对象时，它将转化为该静态方法对象所封装的对象。从类的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 所包含内容以外获取属性的其他方式请参看 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#descriptors" target="_blank" rel="noopener">实现描述器</a> 一节。类属性赋值会更新类的字典，但不会更新基类的字典。类对象可被调用 (见上文) 以产生一个类实例 (见下文)。特殊属性: <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#definition.__name__" target="_blank" rel="noopener"><code>__name__</code></a> 为类的名称; <code>__module__</code> 为类所在模块的名称; <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 为包含类命名空间的字典; <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#class.__bases__" target="_blank" rel="noopener"><code>__bases__</code></a> 为包含基类的元组，按其在基类列表中的出现顺序排列; <code>__doc__</code> 为类的文档字符串，如果没有则为 <code>None</code>; <code>__annotations__</code> (可选) 为一个包含 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-variable-annotation" target="_blank" rel="noopener">变量标注</a> 的字典，它是在类体执行时获取的。</p>
</li>
<li><p>类实例</p>
<p>类实例可通过调用类对象来创建 (见上文)。每个类实例都有通过一个字典对象实现的独立命名空间，属性引用会首先在此字典中查找。当未在其中发现某个属性，而实例对应的类中有该属性时，会继续在类属性中查找。如果找到的类属性为一个用户定义函数对象，它会被转化为实例方法对象，其 <code>__self__</code> 属性即该实例。静态方法和类方法对象也会被转化；参见上文 “Classes” 一节。要了解其他通过类实例来获取相应类属性的方式可参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#descriptors" target="_blank" rel="noopener">实现描述器</a> 一节，这样得到的属性可能与实际存放于类的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 中的对象不同。如果未找到类属性，而对象对应的类具有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 方法，则会调用该方法来满足查找要求。属性赋值和删除会更新实例的字典，但不会更新对应类的字典。如果类具有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__delattr__" target="_blank" rel="noopener"><code>__delattr__()</code></a> 方法，则将调用方法而不再直接更新实例的字典。如果类实例具有某些特殊名称的方法，就可以伪装为数字、序列或映射。参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#specialnames" target="_blank" rel="noopener">特殊方法名称</a> 一节。特殊属性: <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 为属性字典; <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#instance.__class__" target="_blank" rel="noopener"><code>__class__</code></a> 为实例对应的类。</p>
</li>
<li><p>I/O 对象 (或称文件对象)</p>
<p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> 表示一个打开的文件。有多种快捷方式可用来创建文件对象: <a href="https://docs.python.org/zh-cn/3/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 内置函数，以及 <a href="https://docs.python.org/zh-cn/3/library/os.html#os.popen" target="_blank" rel="noopener"><code>os.popen()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>os.fdopen()</code></a> 和 socket 对象的 <a href="https://docs.python.org/zh-cn/3/library/socket.html#socket.socket.makefile" target="_blank" rel="noopener"><code>makefile()</code></a> 方法 (还可能使用某些扩展模块所提供的其他函数或方法)。<code>sys.stdin</code>, <code>sys.stdout</code> 和 <code>sys.stderr</code> 会初始化为对应于解释器标准输入、输出和错误流的文件对象；它们都会以文本模式打开，因此都遵循 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.TextIOBase" target="_blank" rel="noopener"><code>io.TextIOBase</code></a> 抽象类所定义的接口。</p>
</li>
<li><p>内部类型</p>
<p>某些由解释器内部使用的类型也被暴露给用户。它们的定义可能随未来解释器版本的更新而变化，为内容完整起见在此处一并介绍。代码对象代码对象表示 <em>编译为字节的</em> 可执行 Python 代码，或称 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytecode" target="_blank" rel="noopener">bytecode</a>。代码对象和函数对象的区别在于函数对象包含对函数全局对象 (函数所属的模块) 的显式引用，而代码对象不包含上下文；而且默认参数值会存放于函数对象而不是代码对象内 (因为它们表示在运行时算出的值)。与函数对象不同，代码对象不可变，也不包含对可变对象的引用 (不论是直接还是间接)。特殊的只读属性: <code>co_name</code> 给出了函数名; <code>co_argcount</code> 为位置参数的总数量 (包括仅限位置参数和带有默认值的参数); <code>co_posonlyargcount</code> 为仅限位置参数的数量 (包括带有默认值的参数); <code>co_kwonlyargcount</code> 为仅限关键字参数的数量 (包括带有默认值的参数); <code>co_nlocals</code> 为函数使用的局部变量的数量 (包括参数); <code>co_varnames</code> 为一个包含局部变量名称的元组 (参数名排在最前面); <code>co_cellvars</code> 为一个包含被嵌套函数所引用的局部变量名称的元组; <code>co_freevars</code> 为一个包含自由变量名称的元组; <code>co_code</code> 为一个表示字节码指令序列的字符口中; <code>co_consts</code> 为一个包含字节码所使用的字面值的元组; <code>co_names</code> 为一个包含字节码所使用的名称的元组; <code>co_filename</code> 为被编码代码所在的文件名; <code>co_firstlineno</code> 为函数首行的行号; <code>co_lnotab</code> 为一个字符串，其中编码了从字节码偏移量到行号的映射 (详情参见解释器的源代码); <code>co_stacksize</code> 为要求的栈大小; <code>co_flags</code> 为一个整数，其中编码了解释器所用的多个旗标。以下是可用于 <code>co_flags</code> 的标志位定义：如果函数使用 <code>*arguments</code> 语法来接受任意数量的位置参数，则 <code>0x04</code> 位被设置；如果函数使用 <code>**keywords</code> 语法来接受任意数量的关键字参数，则 <code>0x08</code> 位被设置；如果函数是一个生成器，则 <code>0x20</code> 位被设置。未来特性声明 (<code>from __future__ import division</code>) 也使用 <code>co_flags</code> 中的标志位来指明代码对象的编译是否启用特定的特性: 如果函数编译时启用未来除法特性则设置 <code>0x2000</code> 位; 在更早的 Python 版本中则使用 <code>0x10</code> 和 <code>0x1000</code> 位。<code>co_flags</code> 中的其他位被保留为内部使用。如果代码对象表示一个函数，<code>co_consts</code> 中的第一项将是函数的文档字符串，如果未定义则为 <code>None</code>。帧对象帧对象表示执行帧。它们可能出现在回溯对象中 (见下文)，还会被传递给注册跟踪函数。特殊的只读属性: <code>f_back</code> 为前一堆栈帧 (指向调用者)，如是最底层堆栈帧则为 <code>None</code>; <code>f_code</code> 为此帧中所执行的代码对象; <code>f_locals</code> 为用于查找本地变量的字典; <code>f_globals</code> 则用于查找全局变量; <code>f_builtins</code> 用于查找内置 (固有) 名称; <code>f_lasti</code> 给出精确指令 (这是代码对象的字节码字符串的一个索引)。特殊的可写属性: <code>f_trace</code>，如果不为 <code>None</code>，则是在代码执行期间调用各类事件的函数 (由调试器使用)。通常每个新源码行会触发一个事件 - 这可以通过将 <code>f_trace_lines</code> 设为 <a href="https://docs.python.org/zh-cn/3/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a> 来禁用。具体的实现 <em>可能</em> 会通过将 <code>f_trace_opcodes</code> 设为 <a href="https://docs.python.org/zh-cn/3/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a> 来允许按操作码请求事件。请注意如果跟踪函数引发的异常逃逸到被跟踪的函数中，这可能会导致未定义的解释器行为。<code>f_lineno</code> 为帧的当前行号 — 在这里写入从一个跟踪函数内部跳转的指定行 (仅用于最底层的帧)。调试器可以通过写入 f_lineno 实现一个 Jump 命令 (即设置下一语句)。帧对象支持一个方法:<code>frame.``clear</code>()此方法清除该帧持有的全部对本地变量的引用。而且如果该帧属于一个生成器，生成器会被完成。这有助于打破包含帧对象的循环引用 (例如当捕获一个异常并保存其回溯在之后使用)。如果该帧当前正在执行则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。<em>3.4 新版功能.<em>回溯对象回溯对象表示一个异常的栈跟踪记录。当异常发生时会隐式地创建一个回溯对象，也可能通过调用 <a href="https://docs.python.org/zh-cn/3/library/types.html#types.TracebackType" target="_blank" rel="noopener"><code>types.TracebackType</code></a> 显式地创建。对于隐式地创建的回溯对象，当查找异常句柄使得执行栈展开时，会在每个展开层级的当前回溯之前插入一个回溯对象。当进入一个异常句柄时，栈跟踪将对程序启用。(参见 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener">try 语句</a> 一节。) 它可作为 <code>sys.exc_info()</code> 所返回的元组的第三项，以及所捕获异常的 <code>__traceback__</code> 属性被获取。当程序不包含可用的句柄时，栈跟踪会 (以良好的格式) 写入标准错误流；如果解释器处于交互模式，它也可作为 <code>sys.last_traceback</code> 对用户启用。对于显式创建的回溯对象，则由回溯对象的创建者来决定应该如何链接 <code>tb_next</code> 属性来构成完整的栈跟踪。特殊的只读属性: <code>tb_frame</code> 指向当前层级的执行帧; <code>tb_lineno</code> 给出发生异常所在的行号; <code>tb_lasti</code> 标示具体指令。如果异常发生于没有匹配的 except 子句或有 finally 子句的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中，回溯对象中的行号和最后指令可能与相应帧对象中行号不同。特殊的可写属性: <code>tb_next</code> 为栈跟踪中的下一层级 (通往发生异常的帧)，如果没有下一层级则为 <code>None</code>。</em>在 3.7 版更改:</em> 回溯对象现在可以使用 Python 代码显式地实例化，现有实例的 <code>tb_next</code> 属性可以被更新。切片对象切片对象用来表示 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法得到的切片。该对象也可使用内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#slice" target="_blank" rel="noopener"><code>slice()</code></a> 函数来创建。特殊的只读属性: <code>start</code> 为下界; <code>stop</code> 为上界; <code>step</code> 为步长值; 各值如省略则为 <code>None</code>。这些属性可具有任意类型。切片对象支持一个方法:<code>slice.``indices</code>(<em>self</em>, <em>length</em>)此方法接受一个整型参数 <em>length</em> 并计算在切片对象被应用到 <em>length</em> 指定长度的条目序列时切片的相关信息应如何描述。其返回值为三个整型数组成的元组；这些数分别为切片的 <em>start</em> 和 <em>stop</em> 索引号以及 <em>step</em> 步长值。索引号缺失或越界则按照正规连续切片的方式处理。静态方法对象静态方法对象提供了一种避免上文所述将函数对象转换为方法对象的方式。静态方法对象为对任意其他对象的封装，通常用来封装用户定义方法对象。当从类或类实例获取一个静态方法对象时，实际返回的对象是封装的对象，它不会被进一步转换。静态方法对象自身不是可调用的，但它们所封装的对象通常都是可调用的。静态方法对象可通过内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a> 构造器来创建。类方法对象类方法对象和静态方法一样是对其他对象的封装，会改变从类或类实例获取该对象的方式。类方法对象在此类获取操作中的行为已在上文 “用户定义方法” 一节中描述。类方法对象可通过内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a> 构造器来创建。</p>
</li>
</ul>
<h2 id="3-3-特殊方法名称"><a href="#3-3-特殊方法名称" class="headerlink" title="3.3. 特殊方法名称"></a>3.3. 特殊方法名称</h2><p>一个类可以通过定义具有特殊名称的方法来实现由特殊语法所引发的特定操作 (例如算术运算或下标与切片)。这是 Python 实现 <em>操作符重载</em> 的方式，允许每个类自行定义基于操作符的特定行为。例如，如果一个类定义了名为 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 的方法，并且 <code>x</code> 为该类的一个实例，则 <code>x[i]</code> 基本就等同于 <code>type(x).__getitem__(x, i)</code>。除非有说明例外情况，在没有定义适当方法的情况下尝试执行一种操作将引发一个异常 (通常为 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>)。</p>
<p>将一个特殊方法设为 <code>None</code> 表示对应的操作不可用。例如，如果一个类将 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 设为 <code>None</code>，则该类就是不可迭代的，因此对其实例调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#iter" target="_blank" rel="noopener"><code>iter()</code></a> 将引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> (而不会回退至 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>). <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id9" target="_blank" rel="noopener">2</a></p>
<p>在实现模拟任何内置类型的类时，很重要的一点是模拟的实现程度对于被模拟对象来说应当是有意义的。例如，提取单个元素的操作对于某些序列来说是适宜的，但提取切片可能就没有意义。(这种情况的一个实例是 W3C 的文档对象模型中的 <code>NodeList</code> 接口。)</p>
<h3 id="3-3-1-基本定制"><a href="#3-3-1-基本定制" class="headerlink" title="3.3.1. 基本定制"></a>3.3.1. 基本定制</h3><ul>
<li><p><code>object.``__new__</code>(<em>cls</em>[, <em>…</em>])</p>
<p>调用以创建一个 <em>cls</em> 类的新实例。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 是一个静态方法 (因为是特例所以你不需要显式地声明)，它会将所请求实例所属的类作为第一个参数。其余的参数会被传递给对象构造器表达式 (对类的调用)。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 的返回值应为新对象实例 (通常是 <em>cls</em> 的实例)。典型的实现会附带适宜的参数使用 <code>super().__new__(cls[, ...])</code>，通过超类的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法来创建一个类的新实例，然后根据需要修改新创建的实例再将其返回。如果 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 在构造对象期间被发起调用并且它返回了一个实例或 <em>cls</em> 的子类，则新实例的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法将以 <code>__init__(self[, ...])</code> 的形式被发起调用，其中 <em>self</em> 为新实例而其余的参数与被传给对象构造器的参数相同。如果 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 未返回一个 <em>cls</em> 的实例，则新实例的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法就不会被执行。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 的目的主要是允许不可变类型的子类 (例如 int, str 或 tuple) 定制实例创建过程。它也常会在自定义元类中被重载以便定制类创建过程。</p>
</li>
<li><p><code>object.``__init__</code>(<em>self</em>[, <em>…</em>])</p>
<p>在实例 (通过 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>) 被创建之后，返回调用者之前调用。其参数与传递给类构造器表达式的参数相同。一个基类如果有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法，则其所派生的类如果也有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法，就必须显式地调用它以确保实例基类部分的正确初始化；例如: <code>super().__init__([args...])</code>.因为对象是由 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 协作构造完成的 (由 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 创建，并由 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 定制)，所以 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 返回的值只能是 <code>None</code>，否则会在运行时引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
</li>
<li><p><code>object.``__del__</code>(<em>self</em>)</p>
<p>在实例将被销毁时调用。这还会调用终结器或析构器 (不适当)。如果一个基类具有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法，则其所派生的类如果也有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法，就必须显式地调用它以确保实例基类部分的正确清除。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法可以 (但不推荐!) 通过创建一个该实例的新引用来推迟其销毁。这被称为对象 <em>重生</em>。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 是否会在重生的对象将被销毁时再次被调用是由具体实现决定的 ；当前的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-cpython" target="_blank" rel="noopener">CPython</a> 实现只会调用一次。当解释器退出时不会确保为仍然存在的对象调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法。注解 <code>del x</code> 并不直接调用 <code>x.__del__()</code> — 前者会将 <code>x</code> 的引用计数减一，而后者仅会在 <code>x</code> 的引用计数变为零时被调用。<strong>CPython implementation detail:</strong> It is possible for a reference cycle to prevent the reference count of an object from going to zero. In this case, the cycle will be later detected and deleted by the <a href="https://docs.python.org/zh-cn/3/glossary.html#term-garbage-collection" target="_blank" rel="noopener">cyclic garbage collector</a>. A common cause of reference cycles is when an exception has been caught in a local variable. The frame’s locals then reference the exception, which references its own traceback, which references the locals of all frames caught in the traceback.参见 <a href="https://docs.python.org/zh-cn/3/library/gc.html#module-gc" target="_blank" rel="noopener"><code>gc</code></a> 模块的文档。警告 由于调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法时周边状况已不确定，在其执行期间发生的异常将被忽略，改为打印一个警告到 <code>sys.stderr</code>。特别地：<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 可在任意代码被执行时启用，包括来自任意线程的代码。如果 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 需要接受锁或启用其他阻塞资源，可能会发生死锁，例如该资源已被为执行 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 而中断的代码所获取。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 可以在解释器关闭阶段被执行。因此，它需要访问的全局变量（包含其他模块）可能已被删除或设为 <code>None</code>。Python 会保证先删除模块中名称以单个下划线打头的全局变量再删除其他全局变量；如果已不存在其他对此类全局变量的引用，这有助于确保导入的模块在 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法被调用时仍然可用。</p>
</li>
<li><p><code>object.``__repr__</code>(<em>self</em>)</p>
<p>由 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 内置函数调用以输出一个对象的“官方”字符串表示。如果可能，这应类似一个有效的 Python 表达式，能被用来重建具有相同取值的对象（只要有适当的环境）。如果这不可能，则应返回形式如 <code>&lt;...some useful description...&gt;</code> 的字符串。返回值必须是一个字符串对象。如果一个类定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 但未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a>，则在需要该类的实例的“非正式”字符串表示时也会使用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a>。此方法通常被用于调试，因此确保其表示的内容包含丰富信息且无歧义是很重要的。</p>
</li>
<li><p><code>object.``__str__</code>(<em>self</em>)</p>
<p>通过 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str(object)</code></a> 以及内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#format" target="_blank" rel="noopener"><code>format()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 调用以生成一个对象的“非正式”或格式良好的字符串表示。返回值必须为一个 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#textseq" target="_blank" rel="noopener">字符串</a> 对象。此方法与 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>object.__repr__()</code></a> 的不同点在于 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a> 并不预期返回一个有效的 Python 表达式：可以使用更方便或更准确的描述信息。内置类型 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 所定义的默认实现会调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>object.__repr__()</code></a>。</p>
</li>
<li><p><code>object.``__bytes__</code>(<em>self</em>)</p>
<p>通过 <a href="https://docs.python.org/zh-cn/3/library/functions.html#func-bytes" target="_blank" rel="noopener">bytes</a> 调用以生成一个对象的字节串表示。这应该返回一个 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象。</p>
</li>
<li><p><code>object.``__format__</code>(<em>self</em>, <em>format_spec</em>)</p>
<p>通过 <a href="https://docs.python.org/zh-cn/3/library/functions.html#format" target="_blank" rel="noopener"><code>format()</code></a> 内置函数、扩展、<a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings" target="_blank" rel="noopener">格式化字符串字面值</a> 的求值以及 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 方法调用以生成一个对象的“格式化”字符串表示。 <em>format_spec</em> 参数为包含所需格式选项描述的字符串。 <em>format_spec</em> 参数的解读是由实现 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__format__" target="_blank" rel="noopener"><code>__format__()</code></a> 的类型决定的，不过大多数类或是将格式化委托给某个内置类型，或是使用相似的格式化选项语法。请参看 <a href="https://docs.python.org/zh-cn/3/library/string.html#formatspec" target="_blank" rel="noopener">格式规格迷你语言</a> 了解标准格式化语法的描述。返回值必须为一个字符串对象。<em>在 3.4 版更改:</em> <code>object</code> 本身的 <strong>format</strong> 方法如果被传入任何非空字符，将会引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。<em>在 3.7 版更改:</em> <code>object.__format__(x, &#39;&#39;)</code> 现在等同于 <code>str(x)</code> 而不再是 <code>format(str(self), &#39;&#39;)</code>。</p>
</li>
</ul>
<ul>
<li><p><code>object.``__lt__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__le__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__eq__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__ne__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__gt__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__ge__</code>(<em>self</em>, <em>other</em>)</p>
<p>以上这些被称为“富比较”方法。运算符号与方法名称的对应关系如下：<code>x 调用</code>x.<strong>lt</strong>(y)<code>、</code>x&lt;=y<code>调用</code>x.<strong>le</strong>(y)<code>、</code>x==y<code>调用</code>x.<strong>eq</strong>(y)<code>、</code>x!=y<code>调用</code>x.<strong>ne</strong>(y)<code>、</code>x&gt;y<code>调用</code>x.<strong>gt</strong>(y)<code>、</code>x&gt;=y<code>调用</code>x.<strong>ge</strong>(y)<code>。如果指定的参数对没有相应的实现，富比较方法可能会返回单例对象</code>NotImplemented<code>。按照惯例，成功的比较会返回</code>False<code>或</code>True<code>。不过实际上这些方法可以返回任意值，因此如果比较运算符是要用于布尔值判断（例如作为</code>if<code>语句的条件），Python 会对返回值调用 [</code>bool()<code>](https://docs.python.org/zh-cn/3/library/functions.html#bool) 以确定结果为真还是假。在默认情况下 [</code><strong>ne</strong>()<code>](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__ne__) 会委托给 [</code><strong>eq</strong>()<code>](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__) 并将结果取反，除非结果为</code>NotImplemented<code>。比较运算符之间没有其他隐含关系，例如</code>(x 为真并不意味着 <code>x&lt;=y</code>。要根据单根运算自动生成排序操作，请参看 <a href="https://docs.python.org/zh-cn/3/library/functools.html#functools.total_ordering" target="_blank" rel="noopener"><code>functools.total_ordering()</code></a>。请查看 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 的相关段落，了解创建可支持自定义比较运算并可用作字典键的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a> 对象时要注意的一些事项。这些方法并没有对调参数版本（在左边参数不支持该操作但右边参数支持时使用）；而是 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 互为对方的反射， <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 互为对方的反射，而 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__ne__" target="_blank" rel="noopener"><code>__ne__()</code></a> 则是它们自己的反射。如果两个操作数的类型不同，且右操作数类型是左操作数类型的直接或间接子类，则优先选择右操作数的反射方法，否则优先选择左操作数的方法。虚拟子类不会被考虑。</p>
</li>
<li><p><code>object.``__hash__</code>(<em>self</em>)</p>
<p>通过内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 调用以对哈希集的成员进行操作，属于哈希集的类型包括 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a>、<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset" target="_blank" rel="noopener"><code>frozenset</code></a> 以及 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 应该返回一个整数。对象比较结果相同所需的唯一特征属性是其具有相同的哈希值；建议的做法是把参与比较的对象全部组件的哈希值混在一起，即将它们打包为一个元组并对该元组做哈希运算。例如:<code>def __hash__(self):    return hash((self.name, self.nick, self.color))</code>注解 <a href="https://docs.python.org/zh-cn/3/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 会从一个对象自定义的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法返回值中截断为 <code>Py_ssize_t</code> 的大小。通常对 64 位构建为 8 字节，对 32 位构建为 4 字节。如果一个对象的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 必须在不同位大小的构建上进行互操作，请确保检查全部所支持构建的宽度。做到这一点的简单方法是使用 <code>python -c &quot;import sys; print(sys.hash_info.width)&quot;</code>。如果一个类没有定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 方法，那么也不应该定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 操作；如果它定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 但没有定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a>，则其实例将不可被用作可哈希集的项。如果一个类定义了可变对象并实现了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 方法，则不应该实现 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a>，因为可哈希集的实现要求键的哈希集是不可变的（如果对象的哈希值发生改变，它将处于错误的哈希桶中）。用户定义的类默认带有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法；使用它们与任何对象（自己除外）比较必定不相等，并且 <code>x.__hash__()</code> 会返回一个恰当的值以确保 <code>x == y</code> 同时意味着 <code>x is y</code> 且 <code>hash(x) == hash(y)</code>。一个类如果重载了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 且没有定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 则会将其 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 隐式地设为 <code>None</code>。当一个类的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法为 <code>None</code> 时，该类的实例将在一个程序尝试获取其哈希值时正确地引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，并会在检测 <code>isinstance(obj, collections.abc.Hashable)</code> 时被正确地识别为不可哈希对象。如果一个重载了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 的类需要保留来自父类的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 实现，则必须通过设置 <code>__hash__ = .__hash__</code> 来显式地告知解释器。如果一个没有重载 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 的类需要去掉哈希支持，则应该在类定义中包含 <code>__hash__ = None</code>。一个自定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 以显式地引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 的类会被 <code>isinstance(obj, collections.abc.Hashable)</code> 调用错误地识别为可哈希对象。注解 在默认情况下，str 和 bytes 对象的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 值会使用一个不可预知的随机值“加盐”。 虽然它们在一个单独 Python 进程中会保持不变，但它们的值在重复运行的 Python 间是不可预测的。这种做法是为了防止以下形式的拒绝服务攻击：通过仔细选择输入来利用字典插入操作在最坏情况下的执行效率即 O(n^2) 复杂度。详情见 <a href="http://www.ocert.org/advisories/ocert-2011-003.html改变哈希值会影响集合的迭代次序。Python" target="_blank" rel="noopener">http://www.ocert.org/advisories/ocert-2011-003.html改变哈希值会影响集合的迭代次序。Python</a> 也从不保证这个次序不会被改变（通常它在 32 位和 64 位构建上是不一致的）。另见 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#envvar-PYTHONHASHSEED" target="_blank" rel="noopener"><code>PYTHONHASHSEED</code></a>.<em>在 3.3 版更改:</em> 默认启用哈希随机化。</p>
</li>
<li><p><code>object.``__bool__</code>(<em>self</em>)</p>
<p>调用此方法以实现真值检测以及内置的 <code>bool()</code> 操作；应该返回 <code>False</code> 或 <code>True</code>。如果未定义此方法，则会查找并调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 并在其返回非零值时视对象的逻辑值为真。如果一个类既未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 也未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a> 则视其所有实例的逻辑值为真。</p>
</li>
</ul>
<h3 id="3-3-2-自定义属性访问"><a href="#3-3-2-自定义属性访问" class="headerlink" title="3.3.2. 自定义属性访问"></a>3.3.2. 自定义属性访问</h3><p>可以定义下列方法来自定义对类实例属性访问（<code>x.name</code> 的使用、赋值或删除）的具体含义.</p>
<ul>
<li><p><code>object.``__getattr__</code>(<em>self</em>, <em>name</em>)</p>
<p>当默认属性访问因引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 而失败时被调用 (可能是调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>__getattribute__()</code></a> 时由于 <em>name</em> 不是一个实例属性或 <code>self</code> 的类关系树中的属性而引发了 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>；或者是对 <em>name</em> 特性属性调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a> 时引发了 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>)。此方法应当返回（找到的）属性值或是引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 异常。请注意如果属性是通过正常机制找到的，<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 就不会被调用。（这是在 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 之间故意设置的不对称性。）这既是出于效率理由也是因为不这样设置的话 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 将无法访问实例的其他属性。要注意至少对于实例变量来说，你不必在实例属性字典中插入任何值（而是通过插入到其他对象）就可以模拟对它的完全控制。请参阅下面的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>__getattribute__()</code></a> 方法了解真正获取对属性访问的完全控制权的办法。</p>
</li>
<li><p><code>object.``__getattribute__</code>(<em>self</em>, <em>name</em>)</p>
<p>此方法会无条件地被调用以实现对类实例属性的访问。如果类还定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a>，则后者不会被调用，除非 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>__getattribute__()</code></a> 显式地调用它或是引发了 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。此方法应当返回（找到的）属性值或是引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 异常。为了避免此方法中的无限递归，其实现应该总是调用具有相同名称的基类方法来访问它所需要的任何属性，例如 <code>object.__getattribute__(self, name)</code>。注解 此方法在作为通过特定语法或内置函数隐式地调用的结果的情况下查找特殊方法时仍可能会被跳过。参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#special-lookup" target="_blank" rel="noopener">特殊方法查找</a>。</p>
</li>
<li><p><code>object.``__setattr__</code>(<em>self</em>, <em>name</em>, <em>value</em>)</p>
<p>此方法在一个属性被尝试赋值时被调用。这个调用会取代正常机制（即将值保存到实例字典）。 <em>name</em> 为属性名称， <em>value</em> 为要赋给属性的值。如果 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 想要赋值给一个实例属性，它应该调用同名的基类方法，例如 <code>object.__setattr__(self, name, value)</code>。</p>
</li>
<li><p><code>object.``__delattr__</code>(<em>self</em>, <em>name</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 但其作用为删除而非赋值。此方法应该仅在 <code>del obj.name</code> 对于该对象有意义时才被实现。</p>
</li>
<li><p><code>object.``__dir__</code>(<em>self</em>)</p>
<p>此方法会在对相应对象调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 时被调用。返回值必须为一个序列。 <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 会把返回的序列转换为列表并对其排序。</p>
</li>
</ul>
<h4 id="3-3-2-1-自定义模块属性访问"><a href="#3-3-2-1-自定义模块属性访问" class="headerlink" title="3.3.2.1. 自定义模块属性访问"></a>3.3.2.1. 自定义模块属性访问</h4><p>特殊名称 <code>__getattr__</code> 和 <code>__dir__</code> 还可被用来自定义对模块属性的访问。模块层级的 <code>__getattr__</code> 函数应当接受一个参数，其名称为一个属性名，并返回计算结果值或引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。如果通过正常查找即 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>object.__getattribute__()</code></a> 未在模块对象中找到某个属性，则 <code>__getattr__</code> 会在模块的 <code>__dict__</code> 中查找，未找到时会引发一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。如果找到，它会以属性名被调用并返回结果值。</p>
<p><code>__dir__</code> 函数应当不接受任何参数，并且返回一个表示模块中可访问名称的字符串序列。 此函数如果存在，将会重载一个模块中的标准 <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 查找。</p>
<p>想要更细致地自定义模块的行为（设置属性和特性属性等待），可以将模块对象的 <code>__class__</code> 属性设置为一个 <a href="https://docs.python.org/zh-cn/3/library/types.html#types.ModuleType" target="_blank" rel="noopener"><code>types.ModuleType</code></a> 的子类。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from types import ModuleType</span><br><span class="line"></span><br><span class="line">class VerboseModule(ModuleType):</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return f&#39;Verbose &#123;self.__name__&#125;&#39;</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, attr, value):</span><br><span class="line">        print(f&#39;Setting &#123;attr&#125;...&#39;)</span><br><span class="line">        super().__setattr__(attr, value)</span><br><span class="line"></span><br><span class="line">sys.modules[__name__].__class__ &#x3D; VerboseModule</span><br></pre></td></tr></table></figure>

<p>注解</p>
<p>定义模块的 <code>__getattr__</code> 和设置模块的 <code>__class__</code> 只会影响使用属性访问语法进行的查找 – 直接访问模块全局变量（不论是通过模块内的代码还是通过对模块全局字典的引用）是不受影响的。</p>
<p><em>在 3.5 版更改:</em> <code>__class__</code> 模块属性改为可写。</p>
<p><em>3.7 新版功能:</em> <code>__getattr__</code> 和 <code>__dir__</code> 模块属性。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0562" target="_blank" rel="noopener"><strong>PEP 562</strong></a> - 模块 <strong>getattr</strong> 和 <strong>dir</strong></p>
<p>描述用于模块的 <code>__getattr__</code> 和 <code>__dir__</code> 函数。</p>
</li>
</ul>
<h4 id="3-3-2-2-实现描述器"><a href="#3-3-2-2-实现描述器" class="headerlink" title="3.3.2.2. 实现描述器"></a>3.3.2.2. 实现描述器</h4><p>以下方法仅当一个包含该方法的类（称为 <em>描述器</em> 类）的实例出现于一个 <em>所有者</em> 类中的时候才会起作用（该描述器必须在所有者类或其某个上级类的字典中）。在以下示例中，“属性”指的是名称为所有者类 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 中的特征属性的键名的属性。</p>
<ul>
<li><p><code>object.``__get__</code>(<em>self</em>, <em>instance</em>, <em>owner=None</em>)</p>
<p>调用此方法以获取所有者类的属性（类属性访问）或该类的实例的属性（实例属性访问）。 可选的 <em>owner</em> 参数是所有者类而 <em>instance</em> 是被用来访问属性的实例，如果通过 <em>owner</em> 来访问属性则返回 <code>None</code>。此方法应当返回计算得到的属性值或是引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 异常。<a href="https://www.python.org/dev/peps/pep-0252" target="_blank" rel="noopener"><strong>PEP 252</strong></a> 指明 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a> 为带有一至二个参数的可调用对象。 Python 自身内置的描述器支持此规格定义；但是，某些第三方工具可能要求必须带两个参数。 Python 自身的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>__getattribute__()</code></a> 实现总是会传入两个参数，无论它们是否被要求提供。</p>
</li>
<li><p><code>object.``__set__</code>(<em>self</em>, <em>instance</em>, <em>value</em>)</p>
<p>调用此方法以设置 <em>instance</em> 指定的所有者类的实例的属性为新值 <em>value</em>。请注意，添加 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set__" target="_blank" rel="noopener"><code>__set__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__delete__" target="_blank" rel="noopener"><code>__delete__()</code></a> 会将描述器变成“数据描述器”。 更多细节请参阅 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#descriptor-invocation" target="_blank" rel="noopener">发起调用描述器</a>。</p>
</li>
<li><p><code>object.``__delete__</code>(<em>self</em>, <em>instance</em>)</p>
<p>调用此方法以删除 <em>instance</em> 指定的所有者类的实例的属性。</p>
</li>
<li><p><code>object.``__set_name__</code>(<em>self</em>, <em>owner</em>, <em>name</em>)</p>
<p>在所有者类 <em>owner</em> 创建时被调用。描述器会被赋值给 <em>name<em>。注解 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set_name__" target="_blank" rel="noopener"><code>__set_name__()</code></a> 只是作为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 构造器的一部分被隐式地调用，因此在某个类被初次创建之后又额外添加一个描述器时，那就需要显式地调用它并且附带适当的形参:<code>class A:   pass descr = custom_descriptor() A.attr = descr descr.__set_name__(A, &#39;attr&#39;)</code>详情参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#class-object-creation" target="_blank" rel="noopener">创建类对象</a>。</em>3.6 新版功能.</em></p>
</li>
</ul>
<p>属性 <code>__objclass__</code> 会被 <a href="https://docs.python.org/zh-cn/3/library/inspect.html#module-inspect" target="_blank" rel="noopener"><code>inspect</code></a> 模块解读为指定此对象定义所在的类（正确设置此属性有助于动态类属性的运行时内省）。对于可调用对象来说，它可以指明预期或要求提供一个特定类型（或子类）的实例作为第一个位置参数（例如，CPython 会为实现于 C 中的未绑定方法设置此属性）。</p>
<h4 id="3-3-2-3-发起调用描述器"><a href="#3-3-2-3-发起调用描述器" class="headerlink" title="3.3.2.3. 发起调用描述器"></a>3.3.2.3. 发起调用描述器</h4><p>总的说来，描述器就是具有“绑定行为”的对象属性，其属性访问已被描述器协议中的方法所重载，包括 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set__" target="_blank" rel="noopener"><code>__set__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__delete__" target="_blank" rel="noopener"><code>__delete__()</code></a>。如果一个对象定义了以上方法中的任意一个，它就被称为描述器。</p>
<p>属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。例如，<code>a.x</code> 的查找顺序会从 <code>a.__dict__[&#39;x&#39;]</code> 开始，然后是 <code>type(a).__dict__[&#39;x&#39;]</code>，接下来依次查找 <code>type(a)</code> 的上级基类，不包括元类。</p>
<p>但是，如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而发起调用描述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。</p>
<p>描述器发起调用的开始点是一个绑定 <code>a.x</code>。参数的组合方式依 <code>a</code> 而定:</p>
<ul>
<li><p>直接调用</p>
<p>最简单但最不常见的调用方式是用户代码直接发起调用一个描述器方法: <code>x.__get__(a)</code>。</p>
</li>
<li><p>实例绑定</p>
<p>如果绑定到一个对象实例，<code>a.x</code> 会被转换为调用: <code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>。</p>
</li>
<li><p>类绑定</p>
<p>如果绑定到一个类，<code>A.x</code> 会被转换为调用: <code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>。</p>
</li>
<li><p>超绑定</p>
<p>如果 <code>a</code> 是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#super" target="_blank" rel="noopener"><code>super</code></a> 的一个实例，则绑定 <code>super(B, obj).m()</code> 会在 <code>obj.__class__.__mro__</code> 中搜索 <code>B</code> 的直接上级基类 <code>A</code> 然后通过以下调用发起调用描述器: <code>A.__dict__[&#39;m&#39;].__get__(obj, obj.__class__)</code>。</p>
</li>
</ul>
<p>对于实例绑定，发起描述器调用的优先级取决于定义了哪些描述器方法。一个描述器可以定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a>、<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set__" target="_blank" rel="noopener"><code>__set__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__delete__" target="_blank" rel="noopener"><code>__delete__()</code></a> 的任意组合。如果它没有定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a>，则访问属性会返回描述器对象自身，除非对象的实例字典中有相应属性值。如果描述器定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set__" target="_blank" rel="noopener"><code>__set__()</code></a> 和/或 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__delete__" target="_blank" rel="noopener"><code>__delete__()</code></a>，则它是一个数据描述器；如果以上两个都未定义，则它是一个非数据描述器。通常，数据描述器会同时定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set__" target="_blank" rel="noopener"><code>__set__()</code></a>，而非数据描述器只有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a> 方法。定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set__" target="_blank" rel="noopener"><code>__set__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__get__" target="_blank" rel="noopener"><code>__get__()</code></a> 的数据描述器总是会重载实例字典中的定义。与之相对的，非数据描述器可被实例所重载。</p>
<p>Python 方法 (包括 <a href="https://docs.python.org/zh-cn/3/library/functions.html#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a>) 都是作为非描述器来实现的。因此实例可以重定义并重载方法。这允许单个实例获得与相同类的其他实例不一样的行为。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/functions.html#property" target="_blank" rel="noopener"><code>property()</code></a> 函数是作为数据描述器来实现的。因此实例不能重载特性属性的行为。</p>
<h4 id="3-3-2-4-slots"><a href="#3-3-2-4-slots" class="headerlink" title="3.3.2.4. slots"></a>3.3.2.4. <strong>slots</strong></h4><p><em><strong>slots</strong></em> 允许我们显式地声明数据成员（例如特征属性）并禁止创建 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em> (除非是在 <em><strong>slots</strong></em> 中显式地声明或是在父类中可用。)</p>
<p>相比使用 <em><strong>dict</strong></em> 此方式可以显著地节省空间。 属性查找速度也可得到显著的提升。</p>
<ul>
<li><p><code>object.``__slots__</code></p>
<p>这个类变量可赋值为字符串、可迭代对象或由实例使用的变量名构成的字符串序列。 <em><strong>slots</strong></em> 会为已声明的变量保留空间，并阻止自动为每个实例创建 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em>。</p>
</li>
</ul>
<h5 id="3-3-2-4-1-使用-slots-的注意事项"><a href="#3-3-2-4-1-使用-slots-的注意事项" class="headerlink" title="3.3.2.4.1. 使用 slots 的注意事项"></a>3.3.2.4.1. 使用 <em><strong>slots</strong></em> 的注意事项</h5><ul>
<li>当继承自一个未定义 <em><strong>slots</strong></em> 的类时，实例的 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em> 属性将总是可访问。</li>
<li>没有 <em><strong>dict</strong></em> 变量，实例就不能给未在 <em><strong>slots</strong></em> 定义中列出的新变量赋值。尝试给一个未列出的变量名赋值将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。新变量需要动态赋值，就要将 <code>&#39;__dict__&#39;</code> 加入到 <em><strong>slots</strong></em> 声明的字符串序列中。</li>
<li>如果未给每个实例设置 <em><strong>weakref</strong></em> 变量，定义了 <em><strong>slots</strong></em> 的类就不支持对其实际的弱引用。如果需要弱引用支持，就要将 <code>&#39;__weakref__&#39;</code> 加入到 <em><strong>slots</strong></em> 声明的字符串序列中。</li>
<li><em><strong>slots</strong></em> 是通过为每个变量名创建描述器 (<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#descriptors" target="_blank" rel="noopener">实现描述器</a>) 在类层级上实现的。因此，类属性不能被用来为通过 <em><strong>slots</strong></em> 定义的实例变量设置默认值；否则，类属性就会覆盖描述器赋值。</li>
<li><em><strong>slots</strong></em> 声明的作用不只限于定义它的类。在父类中声明的 <em><strong>slots</strong></em> 在其子类中同样可用。不过，子类将会获得 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em> 除非它们也定义了 <em><strong>slots</strong></em> (其中应该仅包含对任何 <em>额外</em> 名称的声明位置)。</li>
<li>如果一个类定义的位置在某个基类中也有定义，则由基类位置定义的实例变量将不可访问（除非通过直接从基类获取其描述器的方式）。这会使得程序的含义变成未定义。未来可能会添加一个防止此情况的检查。</li>
<li>非空的 <em><strong>slots</strong></em> 不适用于派生自“可变长度”内置类型例如 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>、<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 的派生类。</li>
<li>任何非字符串可迭代对象都可以被赋值给 <em><strong>slots</strong></em>。映射也可以被使用；不过，未来可能会分别赋给每个键具有特殊含义的值。</li>
<li><em><strong>class</strong></em> 赋值仅在两个类具有相同的 <em><strong>slots</strong></em> 时才会起作用。</li>
<li>带有多个父类声明位置的多重继承也是可用的，但仅允许一个父类具有由声明位置创建的属性（其他基类必须具有空的位置布局） —— 违反规则将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</li>
<li>如果为 <em><strong>slots</strong></em> 使用了一个迭代器，则会为迭代器的每个值创建描述器。 但是 <em><strong>slots</strong></em> 属性将为一个空迭代器。</li>
</ul>
<h3 id="3-3-3-自定义类创建"><a href="#3-3-3-自定义类创建" class="headerlink" title="3.3.3. 自定义类创建"></a>3.3.3. 自定义类创建</h3><p>当一个类继承其他类时，那个类的 <em><strong>init_subclass</strong></em> 会被调用。这样就可以编写能够改变子类行为的类。这与类装饰器有紧密的关联，但是类装饰器是影响它们所应用的特定类，而 <code>__init_subclass__</code> 则只作用于定义了该方法的类所派生的子类。</p>
<ul>
<li><p><em>classmethod</em> <code>object.``__init_subclass__</code>(<em>cls</em>)</p>
<p>当所在类派生子类时此方法就会被调用。<em>cls</em> 将指向新的子类。如果定义为一个普通实例方法，此方法将被隐式地转换为类方法。传入一个新类的关键字参数会被传给父类的 <code>__init_subclass__</code>。为了与其他使用 <code>__init_subclass__</code> 的类兼容，应当根据需要去掉部分关键字参数再将其余的传给基类，例如:<code>class Philosopher:    def __init_subclass__(cls, /, default_name, **kwargs):        super().__init_subclass__(**kwargs)        cls.default_name = default_name class AustralianPhilosopher(Philosopher, default_name=&quot;Bruce&quot;):    pass ``object.__init_subclass__</code> 的默认实现什么都不做，只在带任意参数调用时引发一个错误。注解 元类提示 <code>metaclass</code> 将被其它类型机制消耗掉，并不会被传给 <code>__init_subclass__</code> 的实现。实际的元类（而非显式的提示）可通过 <code>type(cls)</code> 访问。<em>3.6 新版功能.</em></p>
</li>
</ul>
<h4 id="3-3-3-1-元类"><a href="#3-3-3-1-元类" class="headerlink" title="3.3.3.1. 元类"></a>3.3.3.1. 元类</h4><p>默认情况下，类是使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type()</code></a> 来构建的。类体会在一个新的命名空间内执行，类名会被局部绑定到 <code>type(name, bases, namespace)</code> 的结果。</p>
<p>类创建过程可通过在定义行传入 <code>metaclass</code> 关键字参数，或是通过继承一个包含此参数的现有类来进行定制。在以下示例中，<code>MyClass</code> 和 <code>MySubclass</code> 都是 <code>Meta</code> 的实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Meta(type):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class MyClass(metaclass&#x3D;Meta):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class MySubclass(MyClass):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>在类定义内指定的任何其他关键字参数都会在下面所描述的所有元类操作中进行传递。</p>
<p>当一个类定义被执行时，将发生以下步骤:</p>
<ul>
<li>解析 MRO 条目；</li>
<li>确定适当的元类；</li>
<li>准备类命名空间；</li>
<li>执行类主体；</li>
<li>创建类对象。</li>
</ul>
<h4 id="3-3-3-2-解析-MRO-条目"><a href="#3-3-3-2-解析-MRO-条目" class="headerlink" title="3.3.3.2. 解析 MRO 条目"></a>3.3.3.2. 解析 MRO 条目</h4><p>如果在类定义中出现的基类不是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 的实例，则使用 <code>__mro_entries__</code> 方法对其进行搜索，当找到结果时，它会以原始基类元组做参数进行调用。此方法必须返回类的元组以替代此基类被使用。元组可以为空，在此情况下原始基类将被忽略。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a> - 对 typing 模块和泛型类型的核心支持</p>
<h4 id="3-3-3-3-确定适当的元类"><a href="#3-3-3-3-确定适当的元类" class="headerlink" title="3.3.3.3. 确定适当的元类"></a>3.3.3.3. 确定适当的元类</h4><p>为一个类定义确定适当的元类是根据以下规则:</p>
<ul>
<li>如果没有基类且没有显式指定元类，则使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type()</code></a>；</li>
<li>如果给出一个显式元类而且 <em>不是</em> <a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type()</code></a> 的实例，则其会被直接用作元类；</li>
<li>如果给出一个 <a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type()</code></a> 的实例作为显式元类，或是定义了基类，则使用最近派生的元类。</li>
</ul>
<p>最近派生的元类会从显式指定的元类（如果有）以及所有指定的基类的元类（即 <code>type(cls)</code>）中选取。最近派生的元类应为 <em>所有</em> 这些候选元类的一个子类型。如果没有一个候选元类符合该条件，则类定义将失败并抛出 <code>TypeError</code>。</p>
<h4 id="3-3-3-4-准备类命名空间"><a href="#3-3-3-4-准备类命名空间" class="headerlink" title="3.3.3.4. 准备类命名空间"></a>3.3.3.4. 准备类命名空间</h4><p>一旦确定了适当的元类，则将准备好类命名空间。 如果元类具有 <code>__prepare__</code> 属性，它会以 <code>namespace = metaclass.__prepare__(name, bases, **kwds)</code> 的形式被调用（其中如果有任何额外的关键字参数，则应当来自类定义）。 <code>__prepare__</code> 方法应该被实现为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a>。 <code>__prepare__</code> 所返回的命名空间会被传入 <code>__new__</code>，但是当最终的类对象被创建时，该命名空间会被拷贝到一个新的 <code>dict</code> 中。</p>
<p>如果元类没有 <code>__prepare__</code> 属性，则类命名空间将初始化为一个空的有序映射。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-3115" target="_blank" rel="noopener"><strong>PEP 3115</strong></a> - Python 3000 中的元类</p>
<p>引入 <code>__prepare__</code> 命名空间钩子</p>
</li>
</ul>
<h4 id="3-3-3-5-执行类主体"><a href="#3-3-3-5-执行类主体" class="headerlink" title="3.3.3.5. 执行类主体"></a>3.3.3.5. 执行类主体</h4><p>类主体会以（类似于） <code>exec(body, globals(), namespace)</code> 的形式被执行。普通调用与 <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 的关键区别在于当类定义发生于函数内部时，词法作用域允许类主体（包括任何方法）引用来自当前和外部作用域的名称。</p>
<p>但是，即使当类定义发生于函数内部时，在类内部定义的方法仍然无法看到在类作用域层次上定义的名称。类变量必须通过实例的第一个形参或类方法来访问，或者是通过下一节中描述的隐式词法作用域的 <code>__class__</code> 引用。</p>
<h4 id="3-3-3-6-创建类对象"><a href="#3-3-3-6-创建类对象" class="headerlink" title="3.3.3.6. 创建类对象"></a>3.3.3.6. 创建类对象</h4><p>一旦执行类主体完成填充类命名空间，将通过调用 <code>metaclass(name, bases, namespace, **kwds)</code> 创建类对象（此处的附加关键字参数与传入 <code>__prepare__</code> 的相同）。</p>
<p>如果类主体中有任何方法引用了 <code>__class__</code> 或 <code>super</code>，这个类对象会通过零参数形式的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#super" target="_blank" rel="noopener"><code>super()</code></a>. <code>__class__</code> 所引用，这是由编译器所创建的隐式闭包引用。这使用零参数形式的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#super" target="_blank" rel="noopener"><code>super()</code></a> 能够正确标识正在基于词法作用域来定义的类，而被用于进行当前调用的类或实例则是基于传递给方法的第一个参数来标识的。</p>
<p><strong>CPython implementation detail:</strong> 在 CPython 3.6 及之后的版本中，<code>__class__</code> 单元会作为类命名空间中的cell is passed to the metaclass as a <code>__classcell__</code> 条目被传给元类。 如果存在，它必须被向上传播给 <code>type.__new__</code> 调用，以便能正确地初始化该类。 如果不这样做，在 Python 3.8 中将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
<p>当使用默认的元类 <a href="https://docs.python.org/zh-cn/3/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 或者任何最终会调用 <code>type.__new__</code> 的元类时，以下额外的自定义步骤将在创建类对象之后被发起调用:</p>
<ul>
<li>首先，<code>type.__new__</code> 将收集类命名空间中所有定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__set_name__" target="_blank" rel="noopener"><code>__set_name__()</code></a> 方法的描述器；</li>
<li>接下来，所有这些 <code>__set_name__</code> 方法将使用所定义的类和特定描述器所赋的名称进行调用；</li>
<li>最后，将在新类根据方法解析顺序所确定的直接父类上调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init_subclass__" target="_blank" rel="noopener"><code>__init_subclass__()</code></a> 钩子。</li>
</ul>
<p>在类对象创建之后，它会被传给包含在类定义中的类装饰器（如果有的话），得到的对象将作为已定义的类绑定到局部命名空间。</p>
<p>当通过 <code>type.__new__</code> 创建一个新类时，提供以作为命名空间形参的对象会被复制到一个新的有序映射并丢弃原对象。这个新副本包装于一个只读代理中，后者则成为类对象的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-3135" target="_blank" rel="noopener"><strong>PEP 3135</strong></a> - 新的超类型</p>
<p>描述隐式的 <code>__class__</code> 闭包引用</p>
</li>
</ul>
<h4 id="3-3-3-7-元类的作用"><a href="#3-3-3-7-元类的作用" class="headerlink" title="3.3.3.7. 元类的作用"></a>3.3.3.7. 元类的作用</h4><p>元类的潜在作用非常广泛。已经过尝试的设想包括枚举、日志、接口检查、自动委托、自动特征属性创建、代理、框架以及自动资源锁定/同步等等。</p>
<h3 id="3-3-4-自定义实例及子类检查"><a href="#3-3-4-自定义实例及子类检查" class="headerlink" title="3.3.4. 自定义实例及子类检查"></a>3.3.4. 自定义实例及子类检查</h3><p>以下方法被用来重载 <a href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a> 内置函数的默认行为。</p>
<p>特别地，元类 <a href="https://docs.python.org/zh-cn/3/library/abc.html#abc.ABCMeta" target="_blank" rel="noopener"><code>abc.ABCMeta</code></a> 实现了这些方法以便允许将抽象基类（ABC）作为“虚拟基类”添加到任何类或类型（包括内置类型），包括其他 ABC 之中。</p>
<ul>
<li><p><code>class.``__instancecheck__</code>(<em>self</em>, <em>instance</em>)</p>
<p>如果 <em>instance</em> 应被视为 <em>class</em> 的一个（直接或间接）实例则返回真值。如果定义了此方法，则会被调用以实现 <code>isinstance(instance, class)</code>。</p>
</li>
<li><p><code>class.``__subclasscheck__</code>(<em>self</em>, <em>subclass</em>)</p>
<p>Return true 如果 <em>subclass</em> 应被视为 <em>class</em> 的一个（直接或间接）子类则返回真值。如果定义了此方法，则会被调用以实现 <code>issubclass(subclass, class)</code>。</p>
</li>
</ul>
<p>请注意这些方法的查找是基于类的类型（元类）。它们不能作为类方法在实际的类中被定义。这与基于实例被调用的特殊方法的查找是一致的，只有在此情况下实例本身被当作是类。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-3119" target="_blank" rel="noopener"><strong>PEP 3119</strong></a> - 引入抽象基类</p>
<p>新增功能描述，通过 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#class.__instancecheck__" target="_blank" rel="noopener"><code>__instancecheck__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#class.__subclasscheck__" target="_blank" rel="noopener"><code>__subclasscheck__()</code></a> 来定制 <a href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a> 行为，加入此功能的动机是出于向该语言添加抽象基类的内容（参见 <a href="https://docs.python.org/zh-cn/3/library/abc.html#module-abc" target="_blank" rel="noopener"><code>abc</code></a> 模块）。</p>
</li>
</ul>
<h3 id="3-3-5-模拟泛型类型"><a href="#3-3-5-模拟泛型类型" class="headerlink" title="3.3.5. 模拟泛型类型"></a>3.3.5. 模拟泛型类型</h3><p>通过定义一个特殊方法，可以实现由 <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> 所规定的泛型类语法 (例如 <code>List[int]</code>):</p>
<ul>
<li><p><em>classmethod</em> <code>object.``__class_getitem__</code>(<em>cls</em>, <em>key</em>)</p>
<p>按照 <em>key</em> 参数指定的类型返回一个表示泛型类的专门化对象。</p>
</li>
</ul>
<p>此方法的查找会基于对象自身，并且当定义于类体内部时，此方法将隐式地成为类方法。请注意，此机制主要是被保留用于静态类型提示，不鼓励在其他场合使用。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a> - 对 typing 模块和泛型类型的核心支持</p>
<h3 id="3-3-6-模拟可调用对象"><a href="#3-3-6-模拟可调用对象" class="headerlink" title="3.3.6. 模拟可调用对象"></a>3.3.6. 模拟可调用对象</h3><ul>
<li><p><code>object.``__call__</code>(<em>self</em>[, <em>args…</em>])</p>
<p>此方法会在实例作为一个函数被“调用”时被调用；如果定义了此方法，则 <code>x(arg1, arg2, ...)</code> 就相当于 <code>x.__call__(arg1, arg2, ...)</code> 的快捷方式。</p>
</li>
</ul>
<h3 id="3-3-7-模拟容器类型"><a href="#3-3-7-模拟容器类型" class="headerlink" title="3.3.7. 模拟容器类型"></a>3.3.7. 模拟容器类型</h3><p>可以定义下列方法来实现容器对象。 容器通常属于序列（如列表或元组）或映射（如字典），但也存在其他形式的容器。 前几个方法集被用于模拟序列或是模拟映射；两者的不同之处在于序列允许的键应为整数 <em>k</em> 且 <code>0 &lt;= k &lt; N</code> 其中 <em>N</em> 是序列或定义指定区间的项的切片对象的长度。 此外还建议让映射提供 <code>keys()</code>, <code>values()</code>, <code>items()</code>, <code>get()</code>, <code>clear()</code>, <code>setdefault()</code>, <code>pop()</code>, <code>popitem()</code>, <code>copy()</code> 以及 <code>update()</code> 等方法，它们的行为应与 Python 标准字典对象的相应方法类似。 此外 <a href="https://docs.python.org/zh-cn/3/library/collections.abc.html#module-collections.abc" target="_blank" rel="noopener"><code>collections.abc</code></a> 模块提供了一个 <a href="https://docs.python.org/zh-cn/3/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>MutableMapping</code></a> 抽象基类以便根据由 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__delitem__" target="_blank" rel="noopener"><code>__delitem__()</code></a>, 和 <code>keys()</code> 组成的基本集来创建所需的方法。 可变序列还应像 Python 标准列表对象那样提供 <code>append()</code>, <code>count()</code>, <code>index()</code>, <code>extend()</code>, <code>insert()</code>, <code>pop()</code>, <code>remove()</code>, <code>reverse()</code> 和 <code>sort()</code> 等方法。 最后，序列类型还应通过定义下文描述的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iadd__" target="_blank" rel="noopener"><code>__iadd__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__mul__" target="_blank" rel="noopener"><code>__mul__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__rmul__" target="_blank" rel="noopener"><code>__rmul__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__imul__" target="_blank" rel="noopener"><code>__imul__()</code></a> 等方法来实现加法（指拼接）和乘法（指重复）；它们不应定义其他数值运算符。 此外还建议映射和序列都实现 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a> 方法以允许高效地使用 <code>in</code> 运算符；对于映射，<code>in</code> 应该搜索映射的键；对于序列，则应搜索其中的值。 另外还建议映射和序列都实现 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法以允许高效地迭代容器中的条目；对于映射，<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 应当迭代对象的键；对于序列，则应当迭代其中的值。</p>
<ul>
<li><p><code>object.``__len__</code>(<em>self</em>)</p>
<p>调用此方法以实现内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a>。应该返回对象的长度，以一个 <code>&gt;=</code> 0 的整数表示。此外，如果一个对象未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a> 方法而其 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 方法返回值为零，则在布尔运算中会被视为假值。<strong>CPython implementation detail:</strong> 在 CPython 中，要求长度最大为 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.maxsize" target="_blank" rel="noopener"><code>sys.maxsize</code></a>。如果长度大于 <code>sys.maxsize</code> 则某些特性 (例如 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a>) 可能会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>。要通过真值检测来防止引发 <code>OverflowError</code>，对象必须定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a> 方法。</p>
</li>
<li><p><code>object.``__length_hint__</code>(<em>self</em>)</p>
<p>调用此方法以实现 <a href="https://docs.python.org/zh-cn/3/library/operator.html#operator.length_hint" target="_blank" rel="noopener"><code>operator.length_hint()</code></a>。 应该返回对象长度的估计值（可能大于或小于实际长度）。 此长度应为一个 <code>&gt;=</code> 0 的整数。 返回值也可以为 <a href="https://docs.python.org/zh-cn/3/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a>，这会被视作与 <code>__length_hint__</code> 方法完全不存在时一样处理。 此方法纯粹是为了优化性能，并不要求正确无误。<em>3.4 新版功能.</em></p>
</li>
</ul>
<p>注解</p>
<p>切片是通过下述三个专门方法完成的。以下形式的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[1:2] &#x3D; b</span><br></pre></td></tr></table></figure>

<p>会为转写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[slice(1, 2, None)] &#x3D; b</span><br></pre></td></tr></table></figure>

<p>其他形式以此类推。略去的切片项总是以 <code>None</code> 补全。</p>
<ul>
<li><p><code>object.``__getitem__</code>(<em>self</em>, <em>key</em>)</p>
<p>调用此方法以实现 <code>self[key]</code> 的求值。对于序列类型，接受的键应为整数和切片对象。请注意负数索引（如果类想要模拟序列类型）的特殊解读是取决于 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法。如果 <em>key</em> 的类型不正确则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常；如果为序列索引集范围以外的值（在进行任何负数索引的特殊解读之后）则应引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 异常。对于映射类型，如果 <em>key</em> 找不到（不在容器中）则应引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。注解 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 循环在有不合法索引时会期待捕获 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 以便正确地检测到序列的结束。</p>
</li>
<li><p><code>object.``__setitem__</code>(<em>self</em>, <em>key</em>, <em>value</em>)</p>
<p>调用此方法以实现向 <code>self[key]</code> 赋值。注意事项与 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 相同。为对象实现此方法应该仅限于需要映射允许基于键修改值或添加键，或是序列允许元素被替换时。不正确的 <em>key</em> 值所引发的异常应与 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法的情况相同。</p>
</li>
<li><p><code>object.``__delitem__</code>(<em>self</em>, <em>key</em>)</p>
<p>调用此方法以实现 <code>self[key]</code> 的删除。注意事项与 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 相同。为对象实现此方法应该权限于需要映射允许移除键，或是序列允许移除元素时。不正确的 <em>key</em> 值所引发的异常应与 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法的情况相同。</p>
</li>
<li><p><code>object.``__missing__</code>(<em>self</em>, <em>key</em>)</p>
<p>此方法由 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>.<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 在找不到字典中的键时调用以实现 dict 子类的 <code>self[key]</code>。</p>
</li>
<li><p><code>object.``__iter__</code>(<em>self</em>)</p>
<p>此方法在需要为容器创建迭代器时被调用。此方法应该返回一个新的迭代器对象，它能够逐个迭代容器中的所有对象。对于映射，它应该逐个迭代容器中的键。迭代器对象也需要实现此方法；它们需要返回对象自身。有关迭代器对象的详情请参看 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typeiter" target="_blank" rel="noopener">迭代器类型</a> 一节。</p>
</li>
<li><p><code>object.``__reversed__</code>(<em>self</em>)</p>
<p>此方法（如果存在）会被 <a href="https://docs.python.org/zh-cn/3/library/functions.html#reversed" target="_blank" rel="noopener"><code>reversed()</code></a> 内置函数调用以实现逆向迭代。它应当返回一个新的以逆序逐个迭代容器内所有对象的迭代器对象。如果未提供 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 方法，则 <a href="https://docs.python.org/zh-cn/3/library/functions.html#reversed" target="_blank" rel="noopener"><code>reversed()</code></a> 内置函数将回退到使用序列协议 (<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>)。支持序列协议的对象应当仅在能够提供比 <a href="https://docs.python.org/zh-cn/3/library/functions.html#reversed" target="_blank" rel="noopener"><code>reversed()</code></a> 所提供的实现更高效的实现时才提供 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 方法。</p>
</li>
</ul>
<p>成员检测运算符 (<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#not-in" target="_blank" rel="noopener"><code>not in</code></a>) 通常以对容器进行逐个迭代的方式来实现。 不过，容器对象可以提供以下特殊方法并采用更有效率的实现，这样也不要求对象必须为可迭代对象。</p>
<ul>
<li><p><code>object.``__contains__</code>(<em>self</em>, <em>item</em>)</p>
<p>调用此方法以实现成员检测运算符。如果 <em>item</em> 是 <em>self</em> 的成员则应返回真，否则返回假。对于映射类型，此检测应基于映射的键而不是值或者键值对。对于未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a> 的对象，成员检测将首先尝试通过 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 进行迭代，然后再使用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 的旧式序列迭代协议，参看 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#membership-test-details" target="_blank" rel="noopener">语言参考中的相应部分</a>。</p>
</li>
</ul>
<h3 id="3-3-8-模拟数字类型"><a href="#3-3-8-模拟数字类型" class="headerlink" title="3.3.8. 模拟数字类型"></a>3.3.8. 模拟数字类型</h3><p>定义以下方法即可模拟数字类型。特定种类的数字不支持的运算（例如非整数不能进行位运算）所对应的方法应当保持未定义状态。</p>
<ul>
<li><p><code>object.``__add__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__sub__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__mul__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__matmul__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__truediv__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__floordiv__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__mod__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__divmod__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__pow__</code>(<em>self</em>, <em>other</em>[, <em>modulo</em>])</p>
</li>
<li><p><code>object.``__lshift__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rshift__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__and__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__xor__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__or__</code>(<em>self</em>, <em>other</em>)</p>
<p>调用这些方法来实现二进制算术运算 (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a>, <code>**</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>)。例如，求表达式 <code>x + y</code> 的值，其中 <em>x</em> 是具有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 方法的类的一个实例，则会调用 <code>x.__add__(y)</code>。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__divmod__" target="_blank" rel="noopener"><code>__divmod__()</code></a> 方法应该等价于使用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__floordiv__" target="_blank" rel="noopener"><code>__floordiv__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__mod__" target="_blank" rel="noopener"><code>__mod__()</code></a>，它不应该被关联到 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__truediv__" target="_blank" rel="noopener"><code>__truediv__()</code></a>。请注意如果要支持三元版本的内置 <a href="https://docs.python.org/zh-cn/3/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a> 函数，则 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__pow__" target="_blank" rel="noopener"><code>__pow__()</code></a> 的定义应该接受可选的第三个参数。如果这些方法中的某一个不支持与所提供参数进行运算，它应该返回 <code>NotImplemented</code>。</p>
</li>
<li><p><code>object.``__radd__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rsub__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rmul__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rmatmul__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rtruediv__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rfloordiv__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rmod__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rdivmod__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rpow__</code>(<em>self</em>, <em>other</em>[, <em>modulo</em>])</p>
</li>
<li><p><code>object.``__rlshift__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rrshift__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rand__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__rxor__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__ror__</code>(<em>self</em>, <em>other</em>)</p>
<p>调用这些方法来实现具有反射（交换）操作数的二进制算术运算 (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a>, <code>**</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>)。这些成员函数仅会在左操作数不支持相应运算 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id10" target="_blank" rel="noopener">3</a> 且两个操作数类型不同时被调用。<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id11" target="_blank" rel="noopener">4</a> 例如，求表达式 <code>x - y</code> 的值，其中 <em>y</em> 是具有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__rsub__" target="_blank" rel="noopener"><code>__rsub__()</code></a> 方法的类的一个实例，则当 <code>x.__sub__(y)</code> 返回 <em>NotImplemented</em> 时会调用 <code>y.__rsub__(x)</code>。请注意三元版的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a> 并不会尝试调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__rpow__" target="_blank" rel="noopener"><code>__rpow__()</code></a> (因为强制转换规则会太过复杂)。注解 如果右操作数类型为左操作数类型的一个子类，且该子类提供了指定运算的反射方法，则此方法会先于左操作数的非反射方法被调用。此行为可允许子类重载其祖先类的运算符。</p>
</li>
<li><p><code>object.``__iadd__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__isub__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__imul__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__imatmul__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__itruediv__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__ifloordiv__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__imod__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__ipow__</code>(<em>self</em>, <em>other</em>[, <em>modulo</em>])</p>
</li>
<li><p><code>object.``__ilshift__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__irshift__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__iand__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__ixor__</code>(<em>self</em>, <em>other</em>)</p>
</li>
<li><p><code>object.``__ior__</code>(<em>self</em>, <em>other</em>)</p>
<p>调用这些方法来实现扩展算术赋值 (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>@=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, <code>**=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>)。这些方法应该尝试进行自身操作 (修改 <em>self</em>) 并返回结果 (结果应该但并非必须为 <em>self</em>)。如果某个方法未被定义，相应的扩展算术赋值将回退到普通方法。例如，如果 <em>x</em> 是具有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iadd__" target="_blank" rel="noopener"><code>__iadd__()</code></a> 方法的类的一个实例，则 <code>x += y</code> 就等价于 <code>x = x.__iadd__(y)</code>。否则就如 <code>x + y</code> 的求值一样选择 <code>x.__add__(y)</code> 和 <code>y.__radd__(x)</code>。在某些情况下，扩展赋值可导致未预期的错误 (参见 <a href="https://docs.python.org/zh-cn/3/faq/programming.html#faq-augmented-assignment-tuple-error" target="_blank" rel="noopener">为什么 a_tuple[i] += [‘item’] 会在执行加法时引发异常？</a>)，但此行为实际上是数据模型的一个组成部分。</p>
</li>
<li><p><code>object.``__neg__</code>(<em>self</em>)</p>
</li>
<li><p><code>object.``__pos__</code>(<em>self</em>)</p>
</li>
<li><p><code>object.``__abs__</code>(<em>self</em>)</p>
</li>
<li><p><code>object.``__invert__</code>(<em>self</em>)</p>
<p>调用此方法以实现一元算术运算 (<code>-</code>, <code>+</code>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a> 和 <code>~</code>)。</p>
</li>
<li><p><code>object.``__complex__</code>(<em>self</em>)</p>
</li>
<li><p><code>object.``__int__</code>(<em>self</em>)</p>
</li>
<li><p><code>object.``__float__</code>(<em>self</em>)</p>
<p>调用这些方法以实现内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#complex" target="_blank" rel="noopener"><code>complex()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a>。应当返回一个相应类型的值。</p>
</li>
<li><p><code>object.``__index__</code>(<em>self</em>)</p>
<p>调用此方法以实现 <a href="https://docs.python.org/zh-cn/3/library/operator.html#operator.index" target="_blank" rel="noopener"><code>operator.index()</code></a> 以及 Python 需要无损地将数字对象转换为整数对象的场合（例如切片或是内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#bin" target="_blank" rel="noopener"><code>bin()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#hex" target="_blank" rel="noopener"><code>hex()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#oct" target="_blank" rel="noopener"><code>oct()</code></a> 函数)。 存在此方法表明数字对象属于整数类型。 必须返回一个整数。如果未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__int__" target="_blank" rel="noopener"><code>__int__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__float__" target="_blank" rel="noopener"><code>__float__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__complex__" target="_blank" rel="noopener"><code>__complex__()</code></a> 则相应的内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#complex" target="_blank" rel="noopener"><code>complex()</code></a> 将回退为 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__index__" target="_blank" rel="noopener"><code>__index__()</code></a>。</p>
</li>
<li><p><code>object.``__round__</code>(<em>self</em>[, <em>ndigits</em>])</p>
</li>
<li><p><code>object.``__trunc__</code>(<em>self</em>)</p>
</li>
<li><p><code>object.``__floor__</code>(<em>self</em>)</p>
</li>
<li><p><code>object.``__ceil__</code>(<em>self</em>)</p>
<p>调用这些方法以实现内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a> 以及 <a href="https://docs.python.org/zh-cn/3/library/math.html#module-math" target="_blank" rel="noopener"><code>math</code></a> 函数 <a href="https://docs.python.org/zh-cn/3/library/math.html#math.trunc" target="_blank" rel="noopener"><code>trunc()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/math.html#math.floor" target="_blank" rel="noopener"><code>floor()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/math.html#math.ceil" target="_blank" rel="noopener"><code>ceil()</code></a>。 除了将 <em>ndigits</em> 传给 <code>__round__()</code> 的情况之外这些方法的返回值都应当是原对象截断为 <a href="https://docs.python.org/zh-cn/3/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>Integral</code></a> (通常为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>)。如果未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__int__" target="_blank" rel="noopener"><code>__int__()</code></a> 则内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a> 会回退到 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__trunc__" target="_blank" rel="noopener"><code>__trunc__()</code></a>。</p>
</li>
</ul>
<h3 id="3-3-9-with-语句上下文管理器"><a href="#3-3-9-with-语句上下文管理器" class="headerlink" title="3.3.9. with 语句上下文管理器"></a>3.3.9. with 语句上下文管理器</h3><p><em>上下文管理器</em> 是一个对象，它定义了在执行 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句时要建立的运行时上下文。 上下文管理器处理进入和退出所需运行时上下文以执行代码块。 通常使用 <code>with</code> 语句（在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener">with 语句</a> 中描述），但是也可以通过直接调用它们的方法来使用。</p>
<p>上下文管理器的典型用法包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。</p>
<p>要了解上下文管理器的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typecontextmanager" target="_blank" rel="noopener">上下文管理器类型</a>。</p>
<ul>
<li><p><code>object.``__enter__</code>(<em>self</em>)</p>
<p>进入与此对象相关的运行时上下文。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句将会绑定这个方法的返回值到 <code>as</code> 子句中指定的目标，如果有的话。</p>
</li>
<li><p><code>object.``__exit__</code>(<em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em>)</p>
<p>退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无异常地退出的，三个参数都将为 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的话，异常将在退出此方法时按正常流程处理。请注意 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法不应该重新引发被传入的异常，这是调用者的责任。</p>
</li>
</ul>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a> - “with” 语句</p>
<p>Python <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的规范描述、背景和示例。</p>
</li>
</ul>
<h3 id="3-3-10-特殊方法查找"><a href="#3-3-10-特殊方法查找" class="headerlink" title="3.3.10. 特殊方法查找"></a>3.3.10. 特殊方法查找</h3><p>对于自定义类来说，特殊方法的隐式发起调用仅保证在其定义于对象类型中时能正确地发挥作用，而不能定义在对象实例字典中。 该行为就是以下代码会引发异常的原因。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c &#x3D; C()</span><br><span class="line">&gt;&gt;&gt; c.__len__ &#x3D; lambda: 5</span><br><span class="line">&gt;&gt;&gt; len(c)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: object of type &#39;C&#39; has no len()</span><br></pre></td></tr></table></figure>

<p>此行为背后的原理在于包括类型对象在内的所有对象都会实现的几个特殊方法，例如 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a>。 如果这些方法的隐式查找使用了传统的查找过程，它们会在对类型对象本身发起调用时失败:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 .__hash__() &#x3D;&#x3D; hash(1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; int.__hash__() &#x3D;&#x3D; hash(int)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span><br></pre></td></tr></table></figure>

<p>以这种方式不正确地尝试发起调用一个类的未绑定方法有时被称为‘元类混淆’，可以通过在查找特殊方法时绕过实例的方式来避免:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(1).__hash__(1) &#x3D;&#x3D; hash(1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(int).__hash__(int) &#x3D;&#x3D; hash(int)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>除了为了正确性而绕过任何实例属性之外，隐式特殊方法查找通常也会绕过 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>__getattribute__()</code></a> 方法，甚至包括对象的元类:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Meta(type):</span><br><span class="line">...     def __getattribute__(*args):</span><br><span class="line">...         print(&quot;Metaclass getattribute invoked&quot;)</span><br><span class="line">...         return type.__getattribute__(*args)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(object, metaclass&#x3D;Meta):</span><br><span class="line">...     def __len__(self):</span><br><span class="line">...         return 10</span><br><span class="line">...     def __getattribute__(*args):</span><br><span class="line">...         print(&quot;Class getattribute invoked&quot;)</span><br><span class="line">...         return object.__getattribute__(*args)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c &#x3D; C()</span><br><span class="line">&gt;&gt;&gt; c.__len__()                 # Explicit lookup via instance</span><br><span class="line">Class getattribute invoked</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; type(c).__len__(c)          # Explicit lookup via type</span><br><span class="line">Metaclass getattribute invoked</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; len(c)                      # Implicit lookup</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>以这种方式绕过 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattribute__" target="_blank" rel="noopener"><code>__getattribute__()</code></a> 机制为解析器内部的速度优化提供了显著的空间，其代价则是牺牲了处理特殊方法时的一些灵活性（特殊方法 <em>必须</em> 设置在类对象本身上以便始终一致地由解释器发起调用）。</p>
<h2 id="3-4-协程"><a href="#3-4-协程" class="headerlink" title="3.4. 协程"></a>3.4. 协程</h2><h3 id="3-4-1-可等待对象"><a href="#3-4-1-可等待对象" class="headerlink" title="3.4.1. 可等待对象"></a>3.4.1. 可等待对象</h3><p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象主要实现了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。 从 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 函数返回的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutine</a> 对象即属于可等待对象。</p>
<p>注解</p>
<p>从带有 <a href="https://docs.python.org/zh-cn/3/library/types.html#types.coroutine" target="_blank" rel="noopener"><code>types.coroutine()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>asyncio.coroutine()</code></a> 装饰器的生成器返回的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-generator-iterator" target="_blank" rel="noopener">generator iterator</a> 对象也属于可等待对象，但它们并未实现 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a>。</p>
<ul>
<li><p><code>object.``__await__</code>(<em>self</em>)</p>
<p>必须返回一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>。 应当被用来实现 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。 例如，<a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>asyncio.Future</code></a> 实现了此方法以与 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式相兼容。</p>
</li>
</ul>
<p><em>3.5 新版功能.</em></p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 了解有关可等待对象的详细信息。</p>
<h3 id="3-4-2-协程对象"><a href="#3-4-2-协程对象" class="headerlink" title="3.4.2. 协程对象"></a>3.4.2. 协程对象</h3><p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutine</a> 对象属于 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。 协程的执行可通过调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 并迭代其结果来进行控制。 当协程结束执行并返回时，迭代器会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，该异常的 <code>value</code> 属性将指向返回值。 如果协程引发了异常，它会被迭代器所传播。 协程不应该直接引发未处理的 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。</p>
<p>协程也具有下面列出的方法，它们类似于生成器的对应方法 (参见 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator-methods" target="_blank" rel="noopener">生成器-迭代器的方法</a>)。 但是，与生成器不同，协程并不直接支持迭代。</p>
<p><em>在 3.5.2 版更改:</em> 等待一个协程超过一次将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
<ul>
<li><p><code>coroutine.``send</code>(<em>value</em>)</p>
<p>开始或恢复协程的执行。 如果 <em>value</em> 为 <code>None</code>，则这相当于前往 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 所返回迭代器的下一项。 如果 <em>value</em> 不为 <code>None</code>，此方法将委托给导致协程挂起的迭代器的 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a> 方法。 其结果（返回值，<a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 或是其他异常）将与上述对 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 返回值进行迭代的结果相同。</p>
</li>
<li><p><code>coroutine.``throw</code>(<em>type</em>[, <em>value</em>[, <em>traceback</em>]])</p>
<p>在协程内引发指定的异常。 此方法将委托给导致协程挂起的迭代器的 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.throw" target="_blank" rel="noopener"><code>throw()</code></a> 方法，如果存在该方法。 否则的话，异常会在挂起点被引发。 其结果（返回值，<a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 或是其他异常）将与上述对 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 返回值进行迭代的结果相同。 如果异常未在协程内被捕获，则将回传给调用者。</p>
</li>
<li><p><code>coroutine.``close</code>()</p>
<p>此方法会使得协程清理自身并退出。 如果协程被挂起，此方法会先委托给导致协程挂起的迭代器的 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>close()</code></a> 方法，如果存在该方法。 然后它会在挂起点引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#GeneratorExit" target="_blank" rel="noopener"><code>GeneratorExit</code></a>，使得协程立即清理自身。 最后，协程会被标记为已结束执行，即使它根本未被启动。当协程对象将要被销毁时，会使用以上处理过程来自动关闭。</p>
</li>
</ul>
<h3 id="3-4-3-异步迭代器"><a href="#3-4-3-异步迭代器" class="headerlink" title="3.4.3. 异步迭代器"></a>3.4.3. 异步迭代器</h3><p><em>异步迭代器</em> 可以在其 <code>__anext__</code> 方法中调用异步代码。</p>
<p>异步迭代器可在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 语句中使用。</p>
<ul>
<li><p><code>object.``__aiter__</code>(<em>self</em>)</p>
<p>必须返回一个 <em>异步迭代器</em> 对象。</p>
</li>
<li><p><code>object.``__anext__</code>(<em>self</em>)</p>
<p>必须返回一个 <em>可迭代对象</em> 输出迭代器的下一结果值。 当迭代结束时应该引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a> 错误。</p>
</li>
</ul>
<p>异步可迭代对象的一个示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Reader:</span><br><span class="line">    async def readline(self):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    def __aiter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    async def __anext__(self):</span><br><span class="line">        val &#x3D; await self.readline()</span><br><span class="line">        if val &#x3D;&#x3D; b&#39;&#39;:</span><br><span class="line">            raise StopAsyncIteration</span><br><span class="line">        return val</span><br></pre></td></tr></table></figure>

<p><em>3.5 新版功能.</em></p>
<p><em>在 3.7 版更改:</em> 在 Python 3.7 之前，<code>__aiter__</code> 可以返回一个 <em>可迭代对象</em> 并解析为 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">异步迭代器</a>。</p>
<p>从 Python 3.7 开始，<code>__aiter__</code> 必须 返回一个异步迭代器对象。 返回任何其他对象都将导致 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 错误。</p>
<h3 id="3-4-4-异步上下文管理器"><a href="#3-4-4-异步上下文管理器" class="headerlink" title="3.4.4. 异步上下文管理器"></a>3.4.4. 异步上下文管理器</h3><p><em>异步上下文管理器</em> 是 <em>上下文管理器</em> 的一种，它能够在其 <code>__aenter__</code> 和 <code>__aexit__</code> 方法中暂停执行。</p>
<p>异步上下文管理器可在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-with" target="_blank" rel="noopener"><code>async with</code></a> 语句中使用。</p>
<ul>
<li><p><code>object.``__aenter__</code>(<em>self</em>)</p>
<p>在语义上类似于 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__" target="_blank" rel="noopener"><code>__enter__()</code></a>，仅有的区别是它必须返回一个 <em>可等待对象</em>。</p>
</li>
<li><p><code>object.``__aexit__</code>(<em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em>)</p>
<p>在语义上类似于 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a>，仅有的区别是它必须返回一个 <em>可等待对象</em>。</p>
</li>
</ul>
<p>异步上下文管理器类的一个示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class AsyncContextManager:</span><br><span class="line">    async def __aenter__(self):</span><br><span class="line">        await log(&#39;entering context&#39;)</span><br><span class="line"></span><br><span class="line">    async def __aexit__(self, exc_type, exc, tb):</span><br><span class="line">        await log(&#39;exiting context&#39;)</span><br></pre></td></tr></table></figure>

<p><em>3.5 新版功能.</em></p>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id1" target="_blank" rel="noopener">1</a></p>
<p>在某些情况下 <em>有可能</em> 基于可控的条件改变一个对象的类型。 但这通常不是个好主意，因为如果处理不当会导致一些非常怪异的行为。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id2" target="_blank" rel="noopener">2</a></p>
<p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 以及 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a> 方法对此有特殊处理；其他方法仍会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，但可能依靠 <code>None</code> 属于不可调用对象的行为来做到这一点。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id5" target="_blank" rel="noopener">3</a></p>
<p>这里的“不支持”是指该类无此方法，或方法返回 <code>NotImplemented</code>。 如果你想强制回退到右操作数的反射方法，请不要设置方法为 <code>None</code> — 那会造成显式地 <em>阻塞</em> 此种回退的相反效果。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#id6" target="_blank" rel="noopener">4</a></p>
<p>对于相同类型的操作数，如果非反射方法 (例如 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a>) 失败则会认为相应运算不被支持，这就是反射方法未被调用的原因。</p>
</li>
</ul>
<h1 id="4-执行模型"><a href="#4-执行模型" class="headerlink" title="4. 执行模型"></a>4. 执行模型</h1><h2 id="4-1-程序的结构"><a href="#4-1-程序的结构" class="headerlink" title="4.1. 程序的结构"></a>4.1. 程序的结构</h2><p>Python 程序是由代码块构成的。 <em>代码块</em> 是被作为一个单元来执行的一段 Python 程序文本。 以下几个都是代码块：模块、函数体和类定义。 交互式输入的每条命令都是一个代码块。 一个脚本文件（作为标准输入发送给解释器或是作为命令行参数发送给解释器的文件）也是一个代码块。 一条脚本命令（通过 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-c" target="_blank" rel="noopener"><code>-c</code></a> 选项在解释器命令行中指定的命令）也是一个代码块。 传递给内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 的字符串参数也是代码块。</p>
<p>代码块在 <em>执行帧</em> 中被执行。 一个帧会包含某些管理信息（用于调试）并决定代码块执行完成后应前往何处以及如何继续执行。</p>
<h2 id="4-2-命名与绑定"><a href="#4-2-命名与绑定" class="headerlink" title="4.2. 命名与绑定"></a>4.2. 命名与绑定</h2><h3 id="4-2-1-名称的绑定"><a href="#4-2-1-名称的绑定" class="headerlink" title="4.2.1. 名称的绑定"></a>4.2.1. 名称的绑定</h3><p><em>名称</em> 用于指代对象。 名称是通过名称绑定操作来引入的。</p>
<p>以下构造会绑定名称：传给函数的正式形参，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句，类与函数定义（这会在定义的代码块中绑定类或函数名称）以及发生以标识符为目标的赋值，<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 循环的开头，或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句的 <code>as</code> 之后。 <code>import</code> 语句的 <code>from ... import *</code> 形式会绑定在被导入模块中定义的所有名称，那些以下划线开头的除外。 这种形式仅在模块层级上被使用。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句的目标也被视作一种绑定（虽然其实际语义为解除名称绑定）。</p>
<p>每条赋值或导入语句均发生于类或函数内部定义的代码块中，或是发生于模块层级（即最高层级的代码块）。</p>
<p>如果名称绑定在一个代码块中，则为该代码块的局部变量，除非声明为 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a>。 如果名称绑定在模块层级，则为全局变量。 (模块代码块的变量既为局部变量又为全局变量。) 如果变量在一个代码块中被使用但不是在其中定义，则为 <em>自由变量</em>。</p>
<p>每个在程序文本中出现的名称是指由以下名称解析规则所建立的对该名称的 <em>绑定</em>。</p>
<h3 id="4-2-2-名称的解析"><a href="#4-2-2-名称的解析" class="headerlink" title="4.2.2. 名称的解析"></a>4.2.2. 名称的解析</h3><p><em>作用域</em> 定义了一个代码块中名称的可见性。 如果代码块中定义了一个局部变量，则其作用域包含该代码块。 如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有某个被包含代码块引入了对该名称的不同绑定。</p>
<p>当一个名称在代码块中被使用时，会由包含它的最近作用域来解析。 对一个代码块可见的所有这种作用域的集合称为该代码块的 <em>环境</em>。</p>
<p>当一个名称完全找不到时，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 异常。 如果当前作用域为函数作用域，且该名称指向一个局部变量，而此变量在该名称被使用的时候尚未绑定到特定值，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#UnboundLocalError" target="_blank" rel="noopener"><code>UnboundLocalError</code></a> 异常。 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#UnboundLocalError" target="_blank" rel="noopener"><code>UnboundLocalError</code></a> 为 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 的一个子类。</p>
<p>如果一个代码块内的任何位置发生名称绑定操作，则代码块内所有对该名称的使用会被认为是对当前代码块的引用。 当一个名称在其被绑定前就在代码块内被使用时则会导致错误。 这个一个很微妙的规则。 Python 缺少声明语法，并允许名称绑定操作发生于代码块内的任何位置。 一个代码块的局部变量可通过在整个代码块文本中扫描名称绑定操作来确定。</p>
<p>如果 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句出现在一个代码块中，则所有对该语句所指定名称的使用都是在最高层级命名空间内对该名称绑定的引用。 名称在最高层级命名内的解析是通过全局命名空间，也就是包含该代码块的模块的命名空间，以及内置命名空间即 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块的命名空间。 全局命名空间会先被搜索。 如果未在其中找到指定名称，再搜索内置命名空间。 <code>global</code> 语句必须位于所有对其所指定名称的使用之前。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句与同一代码块中名称绑定具有相同的作用域。 如果一个自由变量的最近包含作用域中有一条 global 语句，则该自由变量也会被当作是全局变量。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句会使得相应的名称指向之前在最近包含函数作用域中绑定的变量。 如果指定名称不存在于任何包含函数作用域中则将在编译时引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。</p>
<p>模块的作用域会在模块第一次被导入时自动创建。 一个脚本的主模块总是被命名为 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a>。</p>
<p>类定义代码块以及传给 <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 的参数是名称解析上下文中的特殊情况。 类定义是可能使用并定义名称的可执行语句。 这些引用遵循正常的名称解析规则，例外之处在于未绑定的局部变量将会在全局命名空间中查找。 类定义的命名空间会成为该类的属性字典。 在类代码块中定义的名称的作用域会被限制在类代码块中；它不会扩展到方法的代码块中 – 这也包括推导式和生成器表达式，因为它们都是使用函数作用域实现的。 这意味着以下代码将会失败:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    a &#x3D; 42</span><br><span class="line">    b &#x3D; list(a + i for i in range(10))</span><br></pre></td></tr></table></figure>



<h3 id="4-2-3-内置命名空间和受限的执行"><a href="#4-2-3-内置命名空间和受限的执行" class="headerlink" title="4.2.3. 内置命名空间和受限的执行"></a>4.2.3. 内置命名空间和受限的执行</h3><p><strong>CPython implementation detail:</strong> 用户不应该接触 <code>__builtins__</code>，严格说来它属于实现细节。 用户如果要重载内置命名空间中的值则应该 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 并相应地修改该模块中的属性。</p>
<p>与一个代码块的执行相关联的内置命名空间实际上是通过在其全局命名空间中搜索名称 <code>__builtins__</code> 来找到的；这应该是一个字典或一个模块（在后一种情况下会使用该模块的字典）。 默认情况下，当在 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 模块中时，<code>__builtins__</code> 就是内置模块 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a>；当在任何其他模块中时，<code>__builtins__</code> 则是 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块自身的字典的一个别名。</p>
<h3 id="4-2-4-与动态特性的交互"><a href="#4-2-4-与动态特性的交互" class="headerlink" title="4.2.4. 与动态特性的交互"></a>4.2.4. 与动态特性的交互</h3><p>自由变量的名称解析发生于运行时而不是编译时。 这意味着以下代码将打印出 42:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 10</span><br><span class="line">def f():</span><br><span class="line">    print(i)</span><br><span class="line">i &#x3D; 42</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 函数没有对完整环境的访问权限来解析名称。 名称可以在调用者的局部和全局命名空间中被解析。 自由变量的解析不是在最近包含命名空间中，而是在全局命名空间中。 <a href="https://docs.python.org/zh-cn/3/reference/executionmodel.html#id3" target="_blank" rel="noopener">1</a> <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 函数有可选参数用来重载全局和局部命名空间。 如果只指定一个命名空间，则它会同时作用于两者。</p>
<h2 id="4-3-异常"><a href="#4-3-异常" class="headerlink" title="4.3. 异常"></a>4.3. 异常</h2><p>异常是中断代码块的正常控制流程以便处理错误或其他异常条件的一种方式。 异常会在错误被检测到的位置 <em>引发</em>，它可以被当前包围代码块或是任何直接或间接发起调用发生错误的代码块的其他代码块所 <em>处理</em>。</p>
<p>Python 解析器会在检测到运行时错误（例如零作为被除数）的时候引发异常。 Python 程序也可以通过 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 语句显式地引发异常。 异常处理是通过 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 语句来指定的。 该语句的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句可被用来指定清理代码，它并不处理异常，而是无论之前的代码是否发生异常都会被执行。</p>
<p>Python 的错误处理采用的是“终止”模型：异常处理器可以找出发生了什么问题，并在外层继续执行，但它不能修复错误的根源并重试失败的操作（除非通过从顶层重新进入出错的代码片段）。</p>
<p>当一个异常完全未被处理时，解释器会终止程序的执行，或者返回交互模式的主循环。 无论是哪种情况，它都会打印栈回溯信息，除非是当异常为 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 的时候。</p>
<p>异常是通过类实例来标识的。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句会依据实例的类来选择：它必须引用实例的类或是其所属的基类。 实例可通过处理器被接收，并可携带有关异常条件的附加信息。</p>
<p>注解</p>
<p>异常消息不是 Python API 的组成部分。 其内容可能在 Python 升级到新版本时不经警告地发生改变，不应该被需要在多版本解释器中运行的代码所依赖。</p>
<p>另请参看 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener">try 语句</a> 小节中对 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的描述以及 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener">raise 语句</a> 小节中对 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 语句的描述。</p>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/executionmodel.html#id1" target="_blank" rel="noopener">1</a></p>
<p>出现这样的限制是由于通过这些操作执行的代码在模块被编译的时候并不可用。</p>
</li>
</ul>
<h1 id="5-导入系统"><a href="#5-导入系统" class="headerlink" title="5. 导入系统"></a>5. 导入系统</h1><p>一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-module" target="_blank" rel="noopener">module</a> 内的 Python 代码通过 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-importing" target="_blank" rel="noopener">importing</a> 操作就能够访问另一个模块内的代码。 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句是发起调用导入机制的最常用方式，但不是唯一的方式。 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module" target="_blank" rel="noopener"><code>importlib.import_module()</code></a> 以及内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 等函数也可以被用来发起调用导入机制。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句结合了两个操作；它先搜索指定名称的模块，然后将搜索结果绑定到当前作用域中的名称。 <code>import</code> 语句的搜索操作定义为对 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 函数的调用并带有适当的参数。 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 的返回值会被用于执行 <code>import</code> 语句的名称绑定操作。 请参阅 <code>import</code> 语句了解名称绑定操作的更多细节。</p>
<p>对 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 的直接调用将仅执行模块搜索以及在找到时的模块创建操作。 不过也可能产生某些副作用，例如导入父包和更新各种缓存 (包括 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a>)，只有 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句会执行名称绑定操作。</p>
<p>当 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句被执行时，标准的内置 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 函数会被调用。 其他发起调用导入系统的机制 (例如 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module" target="_blank" rel="noopener"><code>importlib.import_module()</code></a>) 可能会选择绕过 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 并使用它们自己的解决方案来实现导入机制。</p>
<p>当一个模块首次被导入时，Python 会搜索该模块，如果找到就创建一个 module 对象 <a href="https://docs.python.org/zh-cn/3/reference/import.html#fnmo" target="_blank" rel="noopener">1</a> 并初始化它。 如果指定名称的模块未找到，则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError" target="_blank" rel="noopener"><code>ModuleNotFoundError</code></a>。 当发起调用导入机制时，Python 会实现多种策略来搜索指定名称的模块。 这些策略可以通过使用使用下文所描述的多种钩子来加以修改和扩展。</p>
<p><em>在 3.3 版更改:</em> 导入系统已被更新以完全实现 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> 中的第二阶段要求。 不会再有任何隐式的导入机制 —— 整个导入系统都通过 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 暴露出来。 此外，对原生命名空间包的支持也已被实现 (参见 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a>)。</p>
<h2 id="5-1-importlib"><a href="#5-1-importlib" class="headerlink" title="5.1. importlib"></a>5.1. <a href="https://docs.python.org/zh-cn/3/library/importlib.html#module-importlib" target="_blank" rel="noopener"><code>importlib</code></a></h2><p><a href="https://docs.python.org/zh-cn/3/library/importlib.html#module-importlib" target="_blank" rel="noopener"><code>importlib</code></a> 模块提供了一个丰富的 API 用来与导入系统进行交互。 例如 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module" target="_blank" rel="noopener"><code>importlib.import_module()</code></a> 提供了相比内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 更推荐、更简单的 API 用来发起调用导入机制。 更多细节请参看 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#module-importlib" target="_blank" rel="noopener"><code>importlib</code></a> 库文档。</p>
<h2 id="5-2-包"><a href="#5-2-包" class="headerlink" title="5.2. 包"></a>5.2. 包</h2><p>Python 只有一种模块对象类型，所有模块都属于该类型，无论模块是用 Python、C 还是别的语言实现。 为了帮助组织模块并提供名称层次结构，Python 还引入了 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-package" target="_blank" rel="noopener">包</a> 的概念。</p>
<p>你可以把包看成是文件系统中的目录，并把模块看成是目录中的文件，但请不要对这个类似做过于字面的理解，因为包和模块不是必须来自于文件系统。 为了方便理解本文档，我们将继续使用这种目录和文件的类比。 与文件系统一样，包通过层次结构进行组织，在包之内除了一般的模块，还可以有子包。</p>
<p>要注意的一个重点概念是所有包都是模块，但并非所有模块都是包。 或者换句话说，包只是一种特殊的模块。 特别地，任何具有 <code>__path__</code> 属性的模块都会被当作是包。</p>
<p>所有模块都有自己的名字。 子包名与其父包名以点号分隔，与 Python 的标准属性访问语法一致。 例如你可能看到一个名为 <a href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" target="_blank" rel="noopener"><code>sys</code></a> 的模块，以及一个名为 <a href="https://docs.python.org/zh-cn/3/library/email.html#module-email" target="_blank" rel="noopener"><code>email</code></a> 的包，这个包又有一个名为 <a href="https://docs.python.org/zh-cn/3/library/email.mime.html#module-email.mime" target="_blank" rel="noopener"><code>email.mime</code></a> 的子包和该子包中的名为 <code>email.mime.text</code> 的子包。</p>
<h3 id="5-2-1-常规包"><a href="#5-2-1-常规包" class="headerlink" title="5.2.1. 常规包"></a>5.2.1. 常规包</h3><p>Python 定义了两种类型的包，<a href="https://docs.python.org/zh-cn/3/glossary.html#term-regular-package" target="_blank" rel="noopener">常规包</a> 和 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-namespace-package" target="_blank" rel="noopener">命名空间包</a>。 常规包是传统的包类型，它们在 Python 3.2 及之前就已存在。 常规包通常以一个包含 <code>__init__.py</code> 文件的目录形式实现。 当一个常规包被导入时，这个 <code>__init__.py</code> 文件会隐式地被执行，它所定义的对象会被绑定到该包命名空间中的名称。<code>__init__.py</code> 文件可以包含与任何其他模块中所包含的 Python 代码相似的代码，Python 将在模块被导入时为其添加额外的属性。</p>
<p>例如，以下文件系统布局定义了一个最高层级的 <code>parent</code> 包和三个子包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parent&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    one&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">    two&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">    three&#x2F;</span><br><span class="line">        __init__.py</span><br></pre></td></tr></table></figure>

<p>导入 <code>parent.one</code> 将隐式地执行 <code>parent/__init__.py</code> 和 <code>parent/one/__init__.py</code>。 后续导入 <code>parent.two</code> 或 <code>parent.three</code> 则将分别执行 <code>parent/two/__init__.py</code> 和 <code>parent/three/__init__.py</code>。</p>
<h3 id="5-2-2-命名空间包"><a href="#5-2-2-命名空间包" class="headerlink" title="5.2.2. 命名空间包"></a>5.2.2. 命名空间包</h3><p>命名空间包是由多个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-portion" target="_blank" rel="noopener">部分</a> 构成的，每个部分为父包增加一个子包。 各个部分可能处于文件系统的不同位置。 部分也可能处于 zip 文件中、网络上，或者 Python 在导入期间可以搜索的其他地方。 命名空间包并不一定会直接对应到文件系统中的对象；它们有可能是无实体表示的虚拟模块。</p>
<p>命名空间包的 <code>__path__</code> 属性不使用普通的列表。 而是使用定制的可迭代类型，如果其父包的路径 (或者最高层级包的 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a>) 发生改变，这种对象会在该包内的下一次导入尝试时自动执行新的对包部分的搜索。</p>
<p>命名空间包没有 <code>parent/__init__.py</code> 文件。 实际上，在导入搜索期间可能找到多个 <code>parent</code> 目录，每个都由不同的部分所提供。 因此 <code>parent/one</code> 的物理位置不一定与 <code>parent/two</code> 相邻。 在这种情况下，Python 将为顶级的 <code>parent</code> 包创建一个命名空间包，无论是它本身还是它的某个子包被导入。</p>
<p>另请参阅 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 了解对命名空间包的规格描述。</p>
<h2 id="5-3-搜索"><a href="#5-3-搜索" class="headerlink" title="5.3. 搜索"></a>5.3. 搜索</h2><p>为了开始搜索，Python 需要被导入模块（或者包，对于当前讨论来说两者没有差别）的完整 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-qualified-name" target="_blank" rel="noopener">限定名称</a>。 此名称可以来自 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句所带的各种参数，或者来自传给 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module" target="_blank" rel="noopener"><code>importlib.import_module()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 函数的形参。</p>
<p>此名称会在导入搜索的各个阶段被使用，它也可以是指向一个子模块的带点号路径，例如 <code>foo.bar.baz</code>。 在这种情况下，Python 会先尝试导入 <code>foo</code>，然后是 <code>foo.bar</code>，最后是 <code>foo.bar.baz</code>。 如果这些导入中的任何一个失败，都会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError" target="_blank" rel="noopener"><code>ModuleNotFoundError</code></a>。</p>
<h3 id="5-3-1-模块缓存"><a href="#5-3-1-模块缓存" class="headerlink" title="5.3.1. 模块缓存"></a>5.3.1. 模块缓存</h3><p>在导入搜索期间首先会被检查的地方是 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a>。 这个映射起到缓存之前导入的所有模块的作用（包括其中间路径）。 因此如果之前导入过 <code>foo.bar.baz</code>，则 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 将包含 <code>foo</code>, <code>foo.bar</code> 和 <code>foo.bar.baz</code> 条目。 每个键的值就是相应的模块对象。</p>
<p>在导入期间，会在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 查找模块名称，如存在则其关联的值就是需要导入的模块，导入过程完成。 然而，如果值为 <code>None</code>，则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError" target="_blank" rel="noopener"><code>ModuleNotFoundError</code></a>。 如果找不到指定模块名称，Python 将继续搜索该模块。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 是可写的。删除键可能不会破坏关联的模块（因为其他模块可能会保留对它的引用），但它会使命名模块的缓存条目无效，导致 Python 在下次导入时重新搜索命名模块。键也可以赋值为 <code>None</code> ，强制下一次导入模块导致 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError" target="_blank" rel="noopener"><code>ModuleNotFoundError</code></a> 。</p>
<p>但是要小心，因为如果你还保有对某个模块对象的引用，同时停用其在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中的缓存条目，然后又再次导入该名称的模块，则前后两个模块对象将 <em>不是</em> 同一个。 相反地，<a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.reload" target="_blank" rel="noopener"><code>importlib.reload()</code></a> 将重用 <em>同一个</em> 模块对象，并简单地通过重新运行模块的代码来重新初始化模块内容。</p>
<h3 id="5-3-2-查找器和加载器"><a href="#5-3-2-查找器和加载器" class="headerlink" title="5.3.2. 查找器和加载器"></a>5.3.2. 查找器和加载器</h3><p>如果指定名称的模块在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 找不到，则将发起调用 Python 的导入协议以查找和加载该模块。 此协议由两个概念性模块构成，即 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-finder" target="_blank" rel="noopener">查找器</a> 和 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-loader" target="_blank" rel="noopener">加载器</a>。 查找器的任务是确定是否能使用其所知的策略找到该名称的模块。 同时实现这两种接口的对象称为 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-importer" target="_blank" rel="noopener">导入器</a> —— 它们在确定能加载所需的模块时会返回其自身。</p>
<p>Python 包含了多个默认查找器和导入器。 第一个知道如何定位内置模块，第二个知道如何定位冻结模块。 第三个默认查找器会在 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" target="_blank" rel="noopener">import path</a> 中搜索模块。 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" target="_blank" rel="noopener">import path</a> 是一个由文件系统路径或 zip 文件组成的位置列表。 它还可以扩展为搜索任意可定位资源，例如由 URL 指定的资源。</p>
<p>导入机制是可扩展的，因此可以加入新的查找器以扩展模块搜索的范围和作用域。</p>
<p>查找器并不真正加载模块。 如果它们能找到指定名称的模块，会返回一个 <em>模块规格说明</em>，这是对模块导入相关信息的封装，供后续导入机制用于在加载模块时使用。</p>
<p>以下各节描述了有关查找器和加载器协议的更多细节，包括你应该如何创建并注册新的此类对象来扩展导入机制。</p>
<p><em>在 3.4 版更改:</em> 在之前的 Python 版本中，查找器会直接返回 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-loader" target="_blank" rel="noopener">加载器</a>，现在它们则返回模块规格说明，其中 <em>包含</em> 加载器。 加载器仍然在导入期间被使用，但负担的任务有所减少。</p>
<h3 id="5-3-3-导入钩子"><a href="#5-3-3-导入钩子" class="headerlink" title="5.3.3. 导入钩子"></a>5.3.3. 导入钩子</h3><p>导入机制被设计为可扩展；其中的基本机制是 <em>导入钩子*。 导入钩子有两种类型: *元钩子</em> 和 <em>导入路径钩子</em>。</p>
<p>元钩子在导入过程开始时被调用，此时任何其他导入过程尚未发生，但 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 缓存查找除外。 这允许元钩子重载 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 过程、冻结模块甚至内置模块。 元钩子的注册是通过向 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 添加新的查找器对象，具体如下所述。</p>
<p>导入路径钩子是作为 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> (或 <code>package.__path__</code>) 过程的一部分，在遇到它们所关联的路径项的时候被调用。 导入路径钩子的注册是通过向 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" target="_blank" rel="noopener"><code>sys.path_hooks</code></a> 添加新的可调用对象，具体如下所述。</p>
<h3 id="5-3-4-元路径"><a href="#5-3-4-元路径" class="headerlink" title="5.3.4. 元路径"></a>5.3.4. 元路径</h3><p>当指定名称的模块在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中找不到时，Python 会接着搜索 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a>，其中包含元路径查找器对象列表。 这些查找器按顺序被查询以确定它们是否知道如何处理该名称的模块。 元路径查找器必须实现名为 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 的方法，该方法接受三个参数：名称、导入路径和目标模块（可选）。 元路径查找器可使用任何策略来确定它是否能处理指定名称的模块。</p>
<p>如果元路径查找器知道如何处理指定名称的模块，它将返回一个说明对象。 如果它不能处理该名称的模块，则会返回 <code>None</code>。 如果 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 处理过程到达列表末尾仍未返回说明对象，则将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError" target="_blank" rel="noopener"><code>ModuleNotFoundError</code></a>。 任何其他被引发异常将直接向上传播，并放弃导入过程。</p>
<p>元路径查找器的 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 方法调用带有两到三个参数。 第一个是被导入模块的完整限定名称，例如 <code>foo.bar.baz</code>。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参数为 <code>None</code>，但对于子模块或子包，第二个参数为父包 <code>__path__</code> 属性的值。 如果相应的 <code>__path__</code> 属性无法访问，将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError" target="_blank" rel="noopener"><code>ModuleNotFoundError</code></a>。 第三个参数是一个将被作为稍后加载目标的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。</p>
<p>对于单个导入请求可以多次遍历元路径。 例如，假设所涉及的模块都尚未被缓存，则导入 <code>foo.bar.baz</code> 将首先执行顶级的导入，在每个元路径查找器 (<code>mpf</code>) 上调用 <code>mpf.find_spec(&quot;foo&quot;, None, None)</code>。 在导入 <code>foo</code> 之后，<code>foo.bar</code> 将通过第二次遍历元路径来导入，调用 <code>mpf.find_spec(&quot;foo.bar&quot;, foo.__path__, None)</code>。 一旦 <code>foo.bar</code> 完成导入，最后一次遍历将调用 <code>mpf.find_spec(&quot;foo.bar.baz&quot;, foo.bar.__path__, None)</code>。</p>
<p>有些元路径查找器只支持顶级导入。 当把 <code>None</code> 以外的对象作为第三个参数传入时，这些导入器将总是返回 <code>None</code>。</p>
<p>Python 的默认 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 具有三种元路径查找器，一种知道如何导入内置模块，一种知道如何导入冻结模块，还有一种知道如何导入来自 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" target="_blank" rel="noopener">import path</a> 的模块 (即 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" target="_blank" rel="noopener">path based finder</a>)。</p>
<p><em>在 3.4 版更改:</em> 元路径查找器的 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 方法替代了 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder.find_module" target="_blank" rel="noopener"><code>find_module()</code></a>，后者现已弃用，它将继续可用但不会再做改变，导入机制仅会在查找器未实现 <code>find_spec()</code> 时尝试使用它。</p>
<h2 id="5-4-加载"><a href="#5-4-加载" class="headerlink" title="5.4. 加载"></a>5.4. 加载</h2><p>当一个模块说明被找到时，导入机制将在加载该模块时使用它（及其所包含的加载器）。 下面是导入的加载部分所发生过程的简要说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">module &#x3D; None</span><br><span class="line">if spec.loader is not None and hasattr(spec.loader, &#39;create_module&#39;):</span><br><span class="line">    # It is assumed &#39;exec_module&#39; will also be defined on the loader.</span><br><span class="line">    module &#x3D; spec.loader.create_module(spec)</span><br><span class="line">if module is None:</span><br><span class="line">    module &#x3D; ModuleType(spec.name)</span><br><span class="line"># The import-related module attributes get set here:</span><br><span class="line">_init_module_attrs(spec, module)</span><br><span class="line"></span><br><span class="line">if spec.loader is None:</span><br><span class="line">    # unsupported</span><br><span class="line">    raise ImportError</span><br><span class="line">if spec.origin is None and spec.submodule_search_locations is not None:</span><br><span class="line">    # namespace package</span><br><span class="line">    sys.modules[spec.name] &#x3D; module</span><br><span class="line">elif not hasattr(spec.loader, &#39;exec_module&#39;):</span><br><span class="line">    module &#x3D; spec.loader.load_module(spec.name)</span><br><span class="line">    # Set __loader__ and __package__ if missing.</span><br><span class="line">else:</span><br><span class="line">    sys.modules[spec.name] &#x3D; module</span><br><span class="line">    try:</span><br><span class="line">        spec.loader.exec_module(module)</span><br><span class="line">    except BaseException:</span><br><span class="line">        try:</span><br><span class="line">            del sys.modules[spec.name]</span><br><span class="line">        except KeyError:</span><br><span class="line">            pass</span><br><span class="line">        raise</span><br><span class="line">return sys.modules[spec.name]</span><br></pre></td></tr></table></figure>

<p>请注意以下细节:</p>
<blockquote>
<ul>
<li>如果在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中存在指定名称的模块对象，导入操作会已经将其返回。</li>
<li>在加载器执行模块代码之前，该模块将存在于 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中。 这一点很关键，因为该模块代码可能（直接或间接地）导入其自身；预先将其添加到 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 可防止在最坏情况下的无限递归和最好情况下的多次加载。</li>
<li>如果加载失败，则该模块 – 只限加载失败的模块 – 将从 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中移除。 任何已存在于 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 缓存的模块，以及任何作为附带影响被成功加载的模块仍会保留在缓存中。 这与重新加载不同，后者会把即使加载失败的模块也保留在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中。</li>
<li>在模块创建完成但还未执行之前，导入机制会设置导入相关模块属性（在上面的示例伪代码中为 “_init_module_attrs”），详情参见 <a href="https://docs.python.org/zh-cn/3/reference/import.html#import-mod-attrs" target="_blank" rel="noopener">后续部分</a>。</li>
<li>模块执行是加载的关键时刻，在此期间将填充模块的命名空间。 执行会完全委托给加载器，由加载器决定要填充的内容和方式。</li>
<li>在加载过程中创建并传递给 exec_module() 的模块并不一定就是在导入结束时返回的模块 <a href="https://docs.python.org/zh-cn/3/reference/import.html#fnlo" target="_blank" rel="noopener">2</a>。</li>
</ul>
</blockquote>
<p><em>在 3.4 版更改:</em> 导入系统已经接管了加载器建立样板的责任。 这些在以前是由 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.load_module" target="_blank" rel="noopener"><code>importlib.abc.Loader.load_module()</code></a> 方法来执行的。</p>
<h3 id="5-4-1-加载器"><a href="#5-4-1-加载器" class="headerlink" title="5.4.1. 加载器"></a>5.4.1. 加载器</h3><p>模块加载器提供关键的加载功能：模块执行。 导入机制调用 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.exec_module" target="_blank" rel="noopener"><code>importlib.abc.Loader.exec_module()</code></a> 方法并传入一个参数来执行模块对象。 从 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.exec_module" target="_blank" rel="noopener"><code>exec_module()</code></a> 返回的任何值都将被忽略。</p>
<p>加载器必须满足下列要求:</p>
<blockquote>
<ul>
<li>如果模块是一个 Python 模块（而非内置模块或动态加载的扩展），加载器应该在模块的全局命名空间 (<code>module.__dict__</code>) 中执行模块的代码。</li>
<li>如果加载器无法执行指定模块，它应该引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a>，不过在 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.exec_module" target="_blank" rel="noopener"><code>exec_module()</code></a> 期间引发的任何其他异常也会被传播。</li>
</ul>
</blockquote>
<p>在许多情况下，查找器和加载器可以是同一对象；在此情况下 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 方法将返回一个规格说明，其中加载器会被设为 <code>self</code>。</p>
<p>模块加载器可以选择通过实现 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.create_module" target="_blank" rel="noopener"><code>create_module()</code></a> 方法在加载期间创建模块对象。 它接受一个参数，即模块规格说明，并返回新的模块对象供加载期间使用。 <code>create_module()</code> 不需要在模块对象上设置任何属性。 如果模块返回 <code>None</code>，导入机制将自行创建新模块。</p>
<p><em>3.4 新版功能:</em> 加载器的 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.create_module" target="_blank" rel="noopener"><code>create_module()</code></a> 方法。</p>
<p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.load_module" target="_blank" rel="noopener"><code>load_module()</code></a> 方法被 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.exec_module" target="_blank" rel="noopener"><code>exec_module()</code></a> 所替代，导入机制会对加载的所有样板责任作出假定。</p>
<p>为了与现有的加载器兼容，导入机制会使用导入器的 <code>load_module()</code> 方法，如果它存在且导入器也未实现 <code>exec_module()</code>。 但是，<code>load_module()</code> 现已弃用，加载器应该转而实现 <code>exec_module()</code>。</p>
<p>除了执行模块之外，<code>load_module()</code> 方法必须实现上文描述的所有样板加载功能。 所有相同的限制仍然适用，并带有一些附加规定:</p>
<blockquote>
<ul>
<li>如果 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中存在指定名称的模块对象，加载器必须使用已存在的模块。 （否则 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.reload" target="_blank" rel="noopener"><code>importlib.reload()</code></a> 将无法正确工作。） 如果该名称模块不存在于 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中，加载器必须创建一个新的模块对象并将其加入 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a>。</li>
<li>在加载器执行模块代码之前，模块 <em>必须</em> 存在于 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 之中，以防止无限递归或多次加载。</li>
<li>如果加载失败，加载器必须移除任何它已加入到 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中的模块，但它必须 <strong>仅限</strong> 移除加载失败的模块，且所移除的模块应为加载器自身显式加载的。</li>
</ul>
</blockquote>
<p><em>在 3.5 版更改:</em> 当 <code>exec_module()</code> 已定义但 <code>create_module()</code> 未定义时将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a>。</p>
<p><em>在 3.6 版更改:</em> 当 <code>exec_module()</code> 已定义但 <code>create_module()</code> 未定义时将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a>。</p>
<h3 id="5-4-2-子模块"><a href="#5-4-2-子模块" class="headerlink" title="5.4.2. 子模块"></a>5.4.2. 子模块</h3><p>当使用任意机制 (例如 <code>importlib</code> API, <code>import</code> 及 <code>import-from</code> 语句或者内置的 <code>__import__()</code>) 加载一个子模块时，父模块的命名空间中会添加一个对子模块对象的绑定。 例如，如果包 <code>spam</code> 有一个子模块 <code>foo</code>，则在导入 <code>spam.foo</code> 之后，<code>spam</code> 将具有一个 绑定到相应子模块的 <code>foo</code> 属性。 假如现在有如下的目录结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spam&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    foo.py</span><br><span class="line">    bar.py</span><br></pre></td></tr></table></figure>

<p>并且 <code>spam/__init__.py</code> 中有如下几行内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from .foo import Foo</span><br><span class="line">from .bar import Bar</span><br></pre></td></tr></table></figure>

<p>则执行如下代码将在 <code>spam</code> 模块中添加对 <code>foo</code> 和 <code>bar</code> 的名称绑定:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import spam</span><br><span class="line">&gt;&gt;&gt; spam.foo</span><br><span class="line">&lt;module &#39;spam.foo&#39; from &#39;&#x2F;tmp&#x2F;imports&#x2F;spam&#x2F;foo.py&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; spam.bar</span><br><span class="line">&lt;module &#39;spam.bar&#39; from &#39;&#x2F;tmp&#x2F;imports&#x2F;spam&#x2F;bar.py&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>按照通常的 Python 名称绑定规则，这看起来可能会令人惊讶，但它实际上是导入系统的一个基本特性。 保持不变的一点是如果你有 <code>sys.modules[&#39;spam&#39;]</code> 和 <code>sys.modules[&#39;spam.foo&#39;]</code> (例如在上述导入之后就是如此)，则后者必须显示为前者的 <code>foo</code> 属性。</p>
<h3 id="5-4-3-模块规格说明"><a href="#5-4-3-模块规格说明" class="headerlink" title="5.4.3. 模块规格说明"></a>5.4.3. 模块规格说明</h3><p>导入机制在导入期间会使用有关每个模块的多种信息，特别是加载之前。 大多数信息都是所有模块通用的。 模块规格说明的目的是基于每个模块来封装这些导入相关信息。</p>
<p>在导入期间使用规格说明可允许状态在导入系统各组件之间传递，例如在创建模块规格说明的查找器和执行模块的加载器之间。 最重要的一点是，它允许导入机制执行加载的样板操作，在没有模块规格说明的情况下这是加载器的责任。</p>
<p>模块的规格说明会作为模块对象的 <code>__spec__</code> 属性对外公开。 有关模块规格的详细内容请参阅 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.ModuleSpec" target="_blank" rel="noopener"><code>ModuleSpec</code></a>。</p>
<p><em>3.4 新版功能.</em></p>
<h3 id="5-4-4-导入相关的模块属性"><a href="#5-4-4-导入相关的模块属性" class="headerlink" title="5.4.4. 导入相关的模块属性"></a>5.4.4. 导入相关的模块属性</h3><p>导入机制会在加载期间会根据模块的规格说明填充每个模块对象的这些属性，并在加载器执行模块之前完成。</p>
<ul>
<li><p><code>__name__</code></p>
<p><code>__name__</code> 属性必须被设为模块的完整限定名称。 此名称被用来在导入系统中唯一地标识模块。</p>
</li>
<li><p><code>__loader__</code></p>
<p><code>__loader__</code> 属性必须被设为导入系统在加载模块时使用的加载器对象。 这主要是用于内省，但也可用于额外的加载器专用功能，例如获取关联到加载器的数据。</p>
</li>
<li><p><code>__package__</code></p>
<p>模块的 <code>__package__</code> 属性必须设定。 其取值必须为一个字符串，但可以与 <code>__name__</code> 取相同的值。 当模块是包时，其 <code>__package__</code> 值应该设为其 <code>__name__</code> 值。 当模块不是包时，对于最高层级模块 <code>__package__</code> 应该设为空字符串，对于子模块则应该设为其父包名。 更多详情可参阅 <a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a>。该属性取代 <code>__name__</code> 被用来为主模块计算显式相对导入，相关定义见 <a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a>。 预期它与 <code>__spec__.parent</code> 具有相同的值。<em>在 3.6 版更改:</em> <code>__package__</code> 预期与 <code>__spec__.parent</code> 具有相同的值。</p>
</li>
<li><p><code>__spec__</code></p>
<p><code>__spec__</code> 属性必须设为在导入模块时要使用的模块规格说明。 对 <code>__spec__</code> 的正确设定将同时作用于 <a href="https://docs.python.org/zh-cn/3/reference/toplevel_components.html#programs" target="_blank" rel="noopener">解释器启动期间初始化的模块</a>。 唯一的例外是 <code>__main__</code>，其中的 <code>__spec__</code> 会 <a href="https://docs.python.org/zh-cn/3/reference/import.html#main-spec" target="_blank" rel="noopener">在某些情况下设为 None</a>.当 <code>__package__</code> 未定义时， <code>__spec__.parent</code> 会被用作回退项。<em>3.4 新版功能.**在 3.6 版更改:</em> 当 <code>__package__</code> 未定义时，<code>__spec__.parent</code> 会被用作回退项。</p>
</li>
<li><p><code>__path__</code></p>
<p>如果模块为包（不论是正规包还是命名空间包），则必须设置模块对象的 <code>__path__</code> 属性。 属性值必须为可迭代对象，但如果 <code>__path__</code> 没有进一步的用处则可以为空。 如果 <code>__path__</code> 不为空，则在迭代时它应该产生字符串。 有关 <code>__path__</code> 语义的更多细节将在 <a href="https://docs.python.org/zh-cn/3/reference/import.html#package-path-rules" target="_blank" rel="noopener">下文</a> 中给出。不是包的模块不应该具有 <code>__path__</code> 属性。</p>
</li>
<li><p><code>__file__</code></p>
</li>
</ul>
<ul>
<li><p><code>__cached__</code></p>
<p><code>__file__</code> 是可选项。 如果设置，此属性的值必须为字符串。 导入系统可以选择在其没有语法意义时不设置 <code>__file__</code> (例如从数据库加载的模块)。如果设置了 <code>__file__</code>，则也可以再设置 <code>__cached__</code> 属性，后者取值为编译版本代码（例如字节码文件）所在的路径。 设置此属性不要求文件已存在；该路径可以简单地指向应该存放编译文件的位置 (参见 <a href="https://www.python.org/dev/peps/pep-3147" target="_blank" rel="noopener"><strong>PEP 3147</strong></a>)。当未设置 <code>__file__</code> 时也可以设置 <code>__cached__</code>。 但是，那样的场景很不典型。 最终，加载器会使用 <code>__file__</code> 和/或 <code>__cached__</code>。 因此如果一个加载器可以从缓存加载模块但是不能从文件加载，那种非典型场景就是适当的。</p>
</li>
</ul>
<h3 id="5-4-5-module-path"><a href="#5-4-5-module-path" class="headerlink" title="5.4.5. module.path"></a>5.4.5. module.<strong>path</strong></h3><p>根据定义，如果一个模块具有 <code>__path__</code> 属性，它就是包。</p>
<p>包的 <code>__path__</code> 属性会在导入其子包期间被使用。 在导入机制内部，它的功能与 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 基本相同，即在导入期间提供一个模块搜索位置列表。 但是，<code>__path__</code> 通常会比 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 受到更多限制。</p>
<p><code>__path__</code> 必须是由字符串组成的可迭代对象，但它也可以为空。 作用于 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 的规则同样适用于包的 <code>__path__</code>，并且 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" target="_blank" rel="noopener"><code>sys.path_hooks</code></a> (见下文) 会在遍历包的 <code>__path__</code> 时被查询。</p>
<p>包的 <code>__init__.py</code> 文件可以设置或更改包的 <code>__path__</code> 属性，而且这是在 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 之前实现命名空间包的典型方式。 随着 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 的引入，命名空间包不再需要提供仅包含 <code>__path__</code> 操控代码的 <code>__init__.py</code> 文件；导入机制会自动为命名空间包正确地设置 <code>__path__</code>。</p>
<h3 id="5-4-6-模块的-repr"><a href="#5-4-6-模块的-repr" class="headerlink" title="5.4.6. 模块的 repr"></a>5.4.6. 模块的 repr</h3><p>默认情况下，全部模块都具有一个可用的 repr，但是你可以依据上述的属性设置，在模块的规格说明中更为显式地控制模块对象的 repr。</p>
<p>如果模块具有 spec (<code>__spec__</code>)，导入机制将尝试用它来生成一个 repr。 如果生成失败或找不到 spec，导入系统将使用模块中的各种可用信息来制作一个默认 repr。 它将尝试使用 <code>module.__name__</code>, <code>module.__file__</code> 以及 <code>module.__loader__</code> 作为 repr 的输入，并将任何丢失的信息赋为默认值。</p>
<p>以下是所使用的确切规则:</p>
<blockquote>
<ul>
<li>如果模块具有 <code>__spec__</code> 属性，其中的规格信息会被用来生成 repr。 被查询的属性有 “name”, “loader”, “origin” 和 “has_location” 等等。</li>
<li>如果模块具有 <code>__file__</code> 属性，这会被用作模块 repr 的一部分。</li>
<li>如果模块没有 <code>__file__</code> 但是有 <code>__loader__</code> 且取值不为 <code>None</code>，则加载器的 repr 会被用作模块 repr 的一部分。</li>
<li>对于其他情况，仅在 repr 中使用模块的 <code>__name__</code>。</li>
</ul>
</blockquote>
<p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.module_repr" target="_blank" rel="noopener"><code>loader.module_repr()</code></a> 已弃用，导入机制现在使用模块规格说明来生成模块 repr。</p>
<p>为了向后兼容 Python 3.3，如果加载器定义了 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.Loader.module_repr" target="_blank" rel="noopener"><code>module_repr()</code></a> 方法，则会在尝试上述两种方式之前先调用该方法来生成模块 repr。 但请注意此方法已弃用。</p>
<h3 id="5-4-7-已缓存字节码的失效"><a href="#5-4-7-已缓存字节码的失效" class="headerlink" title="5.4.7. 已缓存字节码的失效"></a>5.4.7. 已缓存字节码的失效</h3><p>在 Python 从 <code>.pyc</code> 文件加载已缓存字节码之前，它会检查缓存是否由最新的 <code>.py</code> 源文件所生成。 默认情况下，Python 通过在所写入缓存文件中保存源文件的最新修改时间戳和大小来实现这一点。 在运行时，导入系统会通过比对缓存文件中保存的元数据和源文件的元数据确定该缓存的有效性。</p>
<p>Python 也支持“基于哈希的”缓存文件，即保存源文件内容的哈希值而不是其元数据。 存在两种基于哈希的 <code>.pyc</code> 文件：检查型和非检查型。 对于检查型基于哈希的 <code>.pyc</code> 文件，Python 会通过求哈希源文件并将结果哈希值与缓存文件中的哈希值比对来确定缓存有效性。 如果检查型基于哈希的缓存文件被确定为失效，Python 会重新生成并写入一个新的检查型基于哈希的缓存文件。 对于非检查型 <code>.pyc</code> 文件，只要其存在 Python 就会直接认定缓存文件有效。 确定基于哈希的 <code>.pyc</code> 文件有效性的行为可通过 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-check-hash-based-pycs" target="_blank" rel="noopener"><code>--check-hash-based-pycs</code></a> 旗标来重载。</p>
<p><em>在 3.7 版更改:</em> 增加了基于哈希的 <code>.pyc</code> 文件。在此之前，Python 只支持基于时间戳来确定字节码缓存的有效性。</p>
<h2 id="5-5-基于路径的查找器"><a href="#5-5-基于路径的查找器" class="headerlink" title="5.5. 基于路径的查找器"></a>5.5. 基于路径的查找器</h2><p>在之前已经提及，Python 带有几种默认的元路径查找器。 其中之一是 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" target="_blank" rel="noopener">path based finder</a> (<a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.PathFinder" target="_blank" rel="noopener"><code>PathFinder</code></a>)，它会搜索包含一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry" target="_blank" rel="noopener">路径条目</a> 列表的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" target="_blank" rel="noopener">import path</a>。 每个路径条目指定一个用于搜索模块的位置。</p>
<p>基于路径的查找器自身并不知道如何进行导入。 它只是遍历单独的路径条目，将它们各自关联到某个知道如何处理特定类型路径的路径条目查找器。</p>
<p>默认的路径条目查找器集合实现了在文件系统中查找模块的所有语义，可处理多种特殊文件类型例如 Python 源码 (<code>.py</code> 文件)，Python 字节码 (<code>.pyc</code> 文件) 以及共享库 (例如 <code>.so</code> 文件)。 在标准库中 <a href="https://docs.python.org/zh-cn/3/library/zipimport.html#module-zipimport" target="_blank" rel="noopener"><code>zipimport</code></a> 模块的支持下，默认路径条目查找器还能处理所有来自 zip 文件的上述文件类型。</p>
<p>路径条目不必仅限于文件系统位置。 它们可以指向 URL、数据库查询或可以用字符串指定的任何其他位置。</p>
<p>基于路径的查找器还提供了额外的钩子和协议以便能扩展和定制可搜索路径条目的类型。 例如，如果你想要支持网络 URL 形式的路径条目，你可以编写一个实现 HTTP 语义在网络上查找模块的钩子。 这个钩子（可调用对象）应当返回一个支持下述协议的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a>，以被用来获取一个专门针对来自网络的模块的加载器。</p>
<p>预先的警告：本节和上节都使用了 <em>查找器</em> 这一术语，并通过 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-meta-path-finder" target="_blank" rel="noopener">meta path finder</a> 和 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a> 两个术语来明确区分它们。 这两种类型的查找器非常相似，支持相似的协议，且在导入过程中以相似的方式运作，但关键的一点是要记住它们是有微妙差异的。 特别地，元路径查找器作用于导入过程的开始，主要是启动 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 遍历。</p>
<p>相比之下，路径条目查找器在某种意义上说是基于路径的查找器的实现细节，实际上，如果需要从 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 移除基于路径的查找器，并不会有任何路径条目查找器被发起调用。</p>
<h3 id="5-5-1-路径条目查找器"><a href="#5-5-1-路径条目查找器" class="headerlink" title="5.5.1. 路径条目查找器"></a>5.5.1. 路径条目查找器</h3><p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" target="_blank" rel="noopener">path based finder</a> 会负责查找和加载通过 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry" target="_blank" rel="noopener">path entry</a> 字符串来指定位置的 Python 模块和包。 多数路径条目所指定的是文件系统中的位置，但它们并不必受限于此。</p>
<p>作为一种元路径查找器，<a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" target="_blank" rel="noopener">path based finder</a> 实现了上文描述的 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 协议，但是它还对外公开了一些附加钩子，可被用来定制模块如何从 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" target="_blank" rel="noopener">import path</a> 查找和加载。</p>
<p>有三个变量由 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" target="_blank" rel="noopener">path based finder</a>, <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a>, <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" target="_blank" rel="noopener"><code>sys.path_hooks</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_importer_cache" target="_blank" rel="noopener"><code>sys.path_importer_cache</code></a> 所使用。 包对象的 <code>__path__</code> 属性也会被使用。 它们提供了可用于定制导入机制的额外方式。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 包含一个提供模块和包搜索位置的字符串列表。 它初始化自 <code>PYTHONPATH</code> 环境变量以及多种其他特定安装和实现的默认设置。 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 条目可指定的名称有文件系统中的目录、zip 文件和其他可用于搜索模块的潜在“位置”（参见 <a href="https://docs.python.org/zh-cn/3/library/site.html#module-site" target="_blank" rel="noopener"><code>site</code></a> 模块），例如 URL 或数据库查询等。 在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 中只能出现字符串和字节串；所有其他数据类型都会被忽略。 字节串条目使用的编码由单独的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">路径条目查找器</a> 来确定。</p>
<p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder" target="_blank" rel="noopener">path based finder</a> 是一种 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-meta-path-finder" target="_blank" rel="noopener">meta path finder</a>，因此导入机制会通过调用上文描述的基于路径的查找器的 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.PathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 方法来启动 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" target="_blank" rel="noopener">import path</a> 搜索。 当要向 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.PathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 传入 <code>path</code> 参数时，它将是一个可遍历的字符串列表 —— 通常为用来在其内部进行导入的包的 <code>__path__</code> 属性。 如果 <code>path</code> 参数为 <code>None</code>，这表示最高层级的导入，将会使用 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a>。</p>
<p>基于路径的查找器会迭代搜索路径中的每个条目，并且每次都查找与路径条目对应的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a> (<a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder" target="_blank" rel="noopener"><code>PathEntryFinder</code></a>)。 因为这种操作可能很耗费资源（例如搜索会有 stat() 调用的开销），基于路径的查找器会维持一个缓存来将路径条目映射到路径条目查找器。 这个缓存放于 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_importer_cache" target="_blank" rel="noopener"><code>sys.path_importer_cache</code></a> (尽管如此命名，但这个缓存实际存放的是查找器对象而非仅限于 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-importer" target="_blank" rel="noopener">importer</a> 对象)。 通过这种方式，对特定 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry" target="_blank" rel="noopener">path entry</a> 位置的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a> 的高耗费搜索只需进行一次。 用户代码可以自由地从 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_importer_cache" target="_blank" rel="noopener"><code>sys.path_importer_cache</code></a> 移除缓存条目，以强制基于路径的查找器再次执行路径条目搜索 <a href="https://docs.python.org/zh-cn/3/reference/import.html#fnpic" target="_blank" rel="noopener">3</a>。</p>
<p>如果路径条目不存在于缓存中，基于路径的查找器会迭代 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" target="_blank" rel="noopener"><code>sys.path_hooks</code></a> 中的每个可调用对象。 对此列表中的每个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-hook" target="_blank" rel="noopener">路径条目钩子</a> 的调用会带有一个参数，即要搜索的路径条目。 每个可调用对象或是返回可处理路径条目的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a>，或是引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a>。 基于路径的查找器使用 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 来表示钩子无法找到与 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry" target="_blank" rel="noopener">path entry</a> 相对应的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a>。 该异常会被忽略并继续进行 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path" target="_blank" rel="noopener">import path</a> 的迭代。 每个钩子应该期待接收一个字符串或字节串对象；字节串对象的编码由钩子决定（例如可以是文件系统使用的编码 UTF-8 或其它编码），如果钩子无法解码参数，它应该引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a>。</p>
<p>如果 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" target="_blank" rel="noopener"><code>sys.path_hooks</code></a> 迭代结束时没有返回 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a>，则基于路径的查找器 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.PathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 方法将在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_importer_cache" target="_blank" rel="noopener"><code>sys.path_importer_cache</code></a> 中存入 <code>None</code> (表示此路径条目没有对应的查找器) 并返回 <code>None</code>，表示此 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-meta-path-finder" target="_blank" rel="noopener">meta path finder</a> 无法找到该模块。</p>
<p>如果 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_hooks" target="_blank" rel="noopener"><code>sys.path_hooks</code></a> 中的某个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-hook" target="_blank" rel="noopener">path entry hook</a> 可调用对象的返回值 <em>是</em> 一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-entry-finder" target="_blank" rel="noopener">path entry finder</a>，则以下协议会被用来向查找器请求一个模块的规格说明，并在加载该模块时被使用。</p>
<p>当前工作目录 – 由一个空字符串表示 – 的处理方式与 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 中的其他条目略有不同。 首先，如果发现当前工作目录不存在，则 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_importer_cache" target="_blank" rel="noopener"><code>sys.path_importer_cache</code></a> 中不会存放任何值。 其次，每个模块查找会对当前工作目录的值进行全新查找。 第三，由 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_importer_cache" target="_blank" rel="noopener"><code>sys.path_importer_cache</code></a> 所使用并由 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.PathFinder.find_spec" target="_blank" rel="noopener"><code>importlib.machinery.PathFinder.find_spec()</code></a> 所返回的路径将是实际的当前工作目录而非空字符串。</p>
<h3 id="5-5-2-路径条目查找器协议"><a href="#5-5-2-路径条目查找器协议" class="headerlink" title="5.5.2. 路径条目查找器协议"></a>5.5.2. 路径条目查找器协议</h3><p>为了支持模块和已初始化包的导入，也为了给命名空间包提供组成部分，路径条目查找器必须实现 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 方法。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 接受两个参数，即要导入模块的完整限定名称，以及（可选的）目标模块。 <code>find_spec()</code> 返回模块的完全填充好的规格说明。 这个规格说明总是包含“加载器”集合（但有一个例外）。</p>
<p>为了向导入机制提示该规格说明代表一个命名空间的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-portion" target="_blank" rel="noopener">portion</a>，路径条目查找器会将规格说明中的 “loader” 设为 <code>None</code> 并将 “submodule_search_locations” 设为一个包含该部分的列表。</p>
<p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 替代了 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder.find_loader" target="_blank" rel="noopener"><code>find_loader()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder.find_module" target="_blank" rel="noopener"><code>find_module()</code></a>，后两者现在都已弃用，但会在 <code>find_spec()</code> 未定义时被使用。</p>
<p>较旧的路径条目查找器可能会实现这两个已弃用的方法中的一个而没有实现 <code>find_spec()</code>。 为保持向后兼容，这两个方法仍会被接受。 但是，如果在路径条目查找器上实现了 <code>find_spec()</code>，这两个遗留方法就会被忽略。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.PathEntryFinder.find_loader" target="_blank" rel="noopener"><code>find_loader()</code></a> 接受一个参数，即被导入模块的完整限定名称。 <code>find_loader()</code> 会返回一个二元组，其中第一项为加载器，第二项为一个命名空间 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-portion" target="_blank" rel="noopener">portion</a>。 当第一项（即加载器）为 <code>None</code> 时，这意味着路径条目查找器虽然没有指定名称模块的加载器，但它知道该路径条目为指定名称模块提供了一个命名空间部分。 这几乎总是表明一种情况，即 Python 被要求导入一个并不以文件系统中的实体形式存在的命名空间包。 当一个路径条目查找器返回的加载器为 <code>None</code> 时，该二元组返回值的第二项必须为一个序列，不过它也可以为空。</p>
<p>如果 <code>find_loader()</code> 所返回加载器的值不为 <code>None</code>，则该部分会被忽略，而该加载器会自基于路径的查找器返回，终止对路径条目的搜索。</p>
<p>为了向后兼容其他导入协议的实现，许多路径条目查找器也同样支持元路径查找器所支持的传统 <code>find_module()</code> 方法。 但是路径条目查找器 <code>find_module()</code> 方法的调用绝不会带有 <code>path</code> 参数（它们被期望记录来自对路径钩子初始调用的恰当路径信息）。</p>
<p>路径条目查找器的 <code>find_module()</code> 方法已弃用，因为它不允许路径条目查找器为命名空间包提供部分。 如果 <code>find_loader()</code> 和 <code>find_module()</code> 同时存在于一个路径条目查找器中，导入系统将总是调用 <code>find_loader()</code> 而不选择 <code>find_module()</code>。</p>
<h2 id="5-6-替换标准导入系统"><a href="#5-6-替换标准导入系统" class="headerlink" title="5.6. 替换标准导入系统"></a>5.6. 替换标准导入系统</h2><p>替换整个导入系统的最可靠机制是移除 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 的默认内容，,将其完全替换为自定义的元路径钩子。</p>
<p>一个可行的方式是仅改变导入语句的行为而不影响访问导入系统的其他 API，那么替换内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a> 函数可能就够了。 这种技巧也可以在模块层级上运用，即只在某个模块内部改变导入语句的行为。</p>
<p>想要选择性地预先防止在元路径上从一个钩子导入某些模块（而不是完全禁用标准导入系统），只需直接从 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.abc.MetaPathFinder.find_spec" target="_blank" rel="noopener"><code>find_spec()</code></a> 引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError" target="_blank" rel="noopener"><code>ModuleNotFoundError</code></a> 而非返回 <code>None</code> 就足够了。 返回后者表示元路径搜索应当继续，而引发异常则会立即终止搜索。</p>
<h2 id="5-7-包相对导入"><a href="#5-7-包相对导入" class="headerlink" title="5.7. 包相对导入"></a>5.7. 包相对导入</h2><p>相对导入使用前缀点号。 一个前缀点号表示相对导入从当前包开始。 两个或更多前缀点号表示对当前包的上级包的相对导入，第一个点号之后的每个点号代表一级。 例如，给定以下的包布局结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    subpackage1&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        moduleX.py</span><br><span class="line">        moduleY.py</span><br><span class="line">    subpackage2&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        moduleZ.py</span><br><span class="line">    moduleA.py</span><br></pre></td></tr></table></figure>

<p>不论是在 <code>subpackage1/moduleX.py</code> 还是 <code>subpackage1/__init__.py</code> 中，以下导入都是有效的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from .moduleY import spam</span><br><span class="line">from .moduleY import spam as ham</span><br><span class="line">from . import moduleY</span><br><span class="line">from ..subpackage1 import moduleY</span><br><span class="line">from ..subpackage2.moduleZ import eggs</span><br><span class="line">from ..moduleA import foo</span><br></pre></td></tr></table></figure>

<p>绝对导入可以使用 <code>import &lt;&gt;</code> 或 <code>from &lt;&gt; import &lt;&gt;</code> 语法，但相对导入只能使用第二种形式；其中的原因在于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import XXX.YYY.ZZZ</span><br></pre></td></tr></table></figure>

<p>应当提供 <code>XXX.YYY.ZZZ</code> 作为可用表达式，但 .moduleY 不是一个有效的表达式。</p>
<h2 id="5-8-有关-main-的特殊事项"><a href="#5-8-有关-main-的特殊事项" class="headerlink" title="5.8. 有关 main 的特殊事项"></a>5.8. 有关 <strong>main</strong> 的特殊事项</h2><p>对于 Python 的导入系统来说 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 模块是一个特殊情况。 正如在 <a href="https://docs.python.org/zh-cn/3/reference/toplevel_components.html#programs" target="_blank" rel="noopener">另一节</a> 中所述，<code>__main__</code> 模块是在解释器启动时直接初始化的，与 <a href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" target="_blank" rel="noopener"><code>sys</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 很类似。 但是，与那两者不同，它并不被严格归类为内置模块。 这是因为 <code>__main__</code> 被初始化的方式依赖于发起调用解释器所附带的旗标和其他选项。</p>
<h3 id="5-8-1-main-spec"><a href="#5-8-1-main-spec" class="headerlink" title="5.8.1. main.spec"></a>5.8.1. <strong>main</strong>.<strong>spec</strong></h3><p>根据 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 被初始化的方式，<code>__main__.__spec__</code> 会被设置相应值或是 <code>None</code>。</p>
<p>当 Python 附加 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-m" target="_blank" rel="noopener"><code>-m</code></a> 选项启动时，<code>__spec__</code> 会被设为相应模块或包的模块规格说明。 <code>__spec__</code> 也会在 <code>__main__</code> 模块作为执行某个目录，zip 文件或其它 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 条目的一部分加载时被填充。</p>
<p>在 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#using-on-interface-options" target="_blank" rel="noopener">其余的情况</a> 下 <code>__main__.__spec__</code> 会被设为 <code>None</code>，因为用于填充 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 的代码不直接与可导入的模块相对应:</p>
<ul>
<li>交互型提示</li>
<li><a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-c" target="_blank" rel="noopener"><code>-c</code></a> 选项</li>
<li>从 stdin 运行</li>
<li>直接从源码或字节码文件运行</li>
</ul>
<p>请注意在最后一种情况中 <code>__main__.__spec__</code> 总是为 <code>None</code>，<em>即使</em> 文件从技术上说可以作为一个模块被导入。 如果想要让 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 中的元数据生效，请使用 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-m" target="_blank" rel="noopener"><code>-m</code></a> 开关。</p>
<p>还要注意即使是在 <code>__main__</code> 对应于一个可导入模块且 <code>__main__.__spec__</code> 被相应地设定时，它们仍会被视为 <em>不同的</em> 模块。 这是由于以下事实：使用 <code>if __name__ == &quot;__main__&quot;:</code> 检测来保护的代码块仅会在模块被用来填充 <code>__main__</code> 命名空间时而非普通的导入时被执行。</p>
<h2 id="5-9-开放问题项"><a href="#5-9-开放问题项" class="headerlink" title="5.9. 开放问题项"></a>5.9. 开放问题项</h2><p>XXX 最好是能增加一个图表。</p>
<p>XXX * (import_machinery.rst) 是否要专门增加一节来说明模块和包的属性，也许可以扩展或移植数据模型参考页中的相关条目？</p>
<p>XXX 库手册中的 runpy 和 pkgutil 等等应该都在页面顶端增加指向新的导入系统章节的“另请参阅”链接。</p>
<p>XXX 是否要增加关于初始化 <code>__main__</code> 的不同方式的更多解释？</p>
<p>XXX 增加更多有关 <code>__main__</code> 怪异/坑人特性的信息 (例如直接从 <a href="https://www.python.org/dev/peps/pep-0395" target="_blank" rel="noopener"><strong>PEP 395</strong></a> 复制)。</p>
<h2 id="5-10-参考文献"><a href="#5-10-参考文献" class="headerlink" title="5.10. 参考文献"></a>5.10. 参考文献</h2><p>导入机制自 Python 诞生之初至今已发生了很大的变化。 原始的 <a href="https://www.python.org/doc/essays/packages/" target="_blank" rel="noopener">包规格说明</a> 仍然可以查阅，但在撰写该文档之后许多相关细节已被修改。</p>
<p>原始的 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> 规格说明见 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a>，后续的扩展说明见 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a>。</p>
<p><a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 为 Python 3.3 引入了 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-namespace-package" target="_blank" rel="noopener">命名空间包</a>。 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 还引入了 <code>find_loader()</code> 协议作为 <code>find_module()</code> 的替代。</p>
<p><a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a> 描述了新增的 <code>__package__</code> 属性，用于在模块中的显式相对导入。</p>
<p><a href="https://www.python.org/dev/peps/pep-0328" target="_blank" rel="noopener"><strong>PEP 328</strong></a> 引入了绝对和显式相对导入，并初次提出了 <code>__name__</code> 语义，最终由 <a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a> 为 <code>__package__</code> 加入规范描述。</p>
<p><a href="https://www.python.org/dev/peps/pep-0338" target="_blank" rel="noopener"><strong>PEP 338</strong></a> 定义了将模块作为脚本执行。</p>
<p><a href="https://www.python.org/dev/peps/pep-0451" target="_blank" rel="noopener"><strong>PEP 451</strong></a> 在 spec 对象中增加了对每个模块导入状态的封装。 它还将加载器的大部分样板责任移交回导入机制中。 这些改变允许弃用导入系统中的一些 API 并为查找器和加载器增加一些新的方法。</p>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/import.html#id1" target="_blank" rel="noopener">1</a></p>
<p>参见 <a href="https://docs.python.org/zh-cn/3/library/types.html#types.ModuleType" target="_blank" rel="noopener"><code>types.ModuleType</code></a>。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/import.html#id2" target="_blank" rel="noopener">2</a></p>
<p>importlib 实现避免直接使用返回值。 而是通过在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中查找模块名称来获取模块对象。 这种方式的间接影响是被导入的模块可能在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中替换其自身。 这属于具体实现的特定行为，不保证能在其他 Python 实现中起作用。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/import.html#id3" target="_blank" rel="noopener">3</a></p>
<p>在遗留代码中，有可能在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path_importer_cache" target="_blank" rel="noopener"><code>sys.path_importer_cache</code></a> 中找到 <a href="https://docs.python.org/zh-cn/3/library/imp.html#imp.NullImporter" target="_blank" rel="noopener"><code>imp.NullImporter</code></a> 的实例。 建议将这些代码修改为使用 <code>None</code> 代替。 详情参见 <a href="https://docs.python.org/zh-cn/3/whatsnew/3.3.html#portingpythoncode" target="_blank" rel="noopener">Porting Python code</a>。</p>
</li>
</ul>
<h1 id="6-表达式"><a href="#6-表达式" class="headerlink" title="6. 表达式"></a>6. 表达式</h1><p>本章将解释 Python 中组成表达式的各种元素的的含义。</p>
<p><strong>语法注释:</strong> 在本章和后续章节中，会使用扩展 BNF 标注来描述语法而不是词法分析。 当（某种替代的）语法规则具有如下形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name ::&#x3D;  othername</span><br></pre></td></tr></table></figure>

<p>并且没有给出语义，则这种形式的 <code>name</code> 在语法上与 <code>othername</code> 相同。</p>
<h2 id="6-1-算术转换"><a href="#6-1-算术转换" class="headerlink" title="6.1. 算术转换"></a>6.1. 算术转换</h2><p>当对下述某个算术运算符的描述中使用了“数值参数被转换为普通类型”这样的说法，这意味着内置类型的运算符实现采用了如下作用方式:</p>
<ul>
<li>如果任一参数为复数，另一参数会被转换为复数；</li>
<li>否则，如果任一参数为浮点数，另一参数会被转换为浮点数；</li>
<li>否则，两者应该都为整数，不需要进行转换。</li>
</ul>
<p>某些附加规则会作用于特定运算符（例如，字符串作为 ‘%’ 运算符的左运算参数）。 扩展必须定义它们自己的转换行为。</p>
<h2 id="6-2-原子"><a href="#6-2-原子" class="headerlink" title="6.2. 原子"></a>6.2. 原子</h2><p>“原子”指表达式的最基本构成元素。 最简单的原子是标识符和字面值。 以圆括号、方括号或花括号包括的形式在语法上也被归类为原子。 原子的句法为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atom      ::&#x3D;  identifier | literal | enclosure</span><br><span class="line">enclosure ::&#x3D;  parenth_form | list_display | dict_display | set_display</span><br><span class="line">               | generator_expression | yield_atom</span><br></pre></td></tr></table></figure>



<h3 id="6-2-1-标识符（名称）"><a href="#6-2-1-标识符（名称）" class="headerlink" title="6.2.1. 标识符（名称）"></a>6.2.1. 标识符（名称）</h3><p>作为原子出现的标识符叫做名称。 请参看 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#identifiers" target="_blank" rel="noopener">标识符和关键字</a> 一节了解其词法定义，以及 <a href="https://docs.python.org/zh-cn/3/reference/executionmodel.html#naming" target="_blank" rel="noopener">命名与绑定</a> 获取有关命名与绑定的文档。</p>
<p>当名称被绑定到一个对象时，对该原子求值将返回相应对象。 当名称未被绑定时，尝试对其求值将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 异常。</p>
<p><strong>私有名称转换:</strong> 当以文本形式出现在类定义中的一个标识符以两个或更多下划线开头并且不以两个或更多下划线结尾，它会被视为该类的 <em>私有名称</em>。 私有名称会在为其生成代码之前被转换为一种更长的形式。 转换时会插入类名，移除打头的下划线再在名称前增加一个下划线。 例如，出现在一个名为 <code>Ham</code> 的类中的标识符 <code>__spam</code> 会被转换为 <code>_Ham__spam</code>。 这种转换独立于标识符所使用的相关句法。 如果转换后的名称太长（超过 255 个字符），可能发生由具体实现定义的截断。 如果类名仅由下划线组成，则不会进行转换。</p>
<h3 id="6-2-2-字面值"><a href="#6-2-2-字面值" class="headerlink" title="6.2.2. 字面值"></a>6.2.2. 字面值</h3><p>Python 支持字符串和字节串字面值，以及几种数字字面值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">literal ::&#x3D;  stringliteral | bytesliteral</span><br><span class="line">             | integer | floatnumber | imagnumber</span><br></pre></td></tr></table></figure>

<p>对字面值求值将返回一个该值所对应类型的对象（字符串、字节串、整数、浮点数、复数）。 对于浮点数和虚数（复数）的情况，该值可能为近似值。 详情参见 <a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#literals" target="_blank" rel="noopener">字面值</a>。</p>
<p>所有字面值都对应与不可变数据类型，因此对象标识的重要性不如其实际值。 多次对具有相同值的字面值求值（不论是发生在程序文本的相同位置还是不同位置）可能得到相同对象或是具有相同值的不同对象。</p>
<h3 id="6-2-3-带圆括号的形式"><a href="#6-2-3-带圆括号的形式" class="headerlink" title="6.2.3. 带圆括号的形式"></a>6.2.3. 带圆括号的形式</h3><p>带圆括号的形式是包含在圆括号中的可选表达式列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parenth_form ::&#x3D;  &quot;(&quot; [starred_expression] &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>带圆括号的表达式列表将返回该表达式列表所产生的任何东西：如果该列表包含至少一个逗号，它会产生一个元组；否则，它会产生该表达式列表所对应的单一表达式。</p>
<p>一对内容为空的圆括号将产生一个空的元组对象。 由于元组是不可变对象，因此适用与字面值相同的规则（即两次出现的空元组产生的对象可能相同也可能不同）。</p>
<p>请注意元组并不是由圆括号构建，实际起作用的是逗号操作符。 例外情况是空元组，这时圆括号 <em>才是</em> 必须的 — 允许在表达式中使用不带圆括号的 “空” 会导致歧义，并会造成常见输入错误无法被捕获。</p>
<h3 id="6-2-4-列表、集合与字典的显示"><a href="#6-2-4-列表、集合与字典的显示" class="headerlink" title="6.2.4. 列表、集合与字典的显示"></a>6.2.4. 列表、集合与字典的显示</h3><p>为了构建列表、集合或字典，Python 提供了名为“显示”的特殊句法，每个类型各有两种形式:</p>
<ul>
<li>第一种是显式地列出容器内容</li>
<li>第二种是通过一组循环和筛选指令计算出来，称为 <em>推导式</em>。</li>
</ul>
<p>推导式的常用句法元素为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comprehension ::&#x3D;  assignment_expression comp_for</span><br><span class="line">comp_for      ::&#x3D;  [&quot;async&quot;] &quot;for&quot; target_list &quot;in&quot; or_test [comp_iter]</span><br><span class="line">comp_iter     ::&#x3D;  comp_for | comp_if</span><br><span class="line">comp_if       ::&#x3D;  &quot;if&quot; expression_nocond [comp_iter]</span><br></pre></td></tr></table></figure>

<p>推导式的结构是一个单独表达式后面加至少一个 <code>for</code> 子句以及零个或更多个 <code>for</code> 或 <code>if</code> 子句。 在这种情况下，新容器的元素产生方式是将每个 <code>for</code> 或 <code>if</code> 子句视为一个代码块，按从左至右的顺序嵌套，然后每次到达最内层代码块时就对表达式进行求值以产生一个元素。</p>
<p>不过，除了最左边 <code>for</code> 子句中的可迭代表达式，推导式是在另一个隐式嵌套的作用域内执行的。 这能确保赋给目标列表的名称不会“泄露”到外层的作用域。</p>
<p>最左边的 <code>for</code> 子句中的可迭代对象表达式会直接在外层作用域中被求值，然后作为一个参数被传给隐式嵌套的作用域。 后续的 <code>for</code> 子句以及最左侧 <code>for</code> 子句中的任何筛选条件不能在外层作用域中被求值，因为它们可能依赖于从最左侧可迭代对象中获得的值。 例如: <code>[x*y for x in range(10) for y in range(x, x+10)]</code>。</p>
<p>为了确保推导式得出的结果总是一个类型正确的容器，在隐式嵌套作用域内禁止使用 <code>yield</code> 和 <code>yield from</code> 表达式。</p>
<p>从 Python 3.6 开始，在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 函数中可以使用 <code>async for</code> 子句来迭代 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a>。 在 <code>async def</code> 函数中构建推导式可以通过在打头的表达式后加上 <code>for</code> 或 <code>async for</code> 子句，也可能包含额外的 <code>for</code> 或 <code>async for</code> 子句，还可能使用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式。 如果一个推导式包含 <code>async for</code> 子句或者 <code>await</code> 表达式，则被称为 <em>异步推导式</em>。 异步推导式可以暂停执行它所在的协程函数。 另请参阅 <a href="https://www.python.org/dev/peps/pep-0530" target="_blank" rel="noopener"><strong>PEP 530</strong></a>。</p>
<p><em>3.6 新版功能:</em> 引入了异步推导式。</p>
<p><em>在 3.8 版更改:</em> <code>yield</code> 和 <code>yield from</code> 在隐式嵌套的作用域中已被禁用。</p>
<h3 id="6-2-5-列表显示"><a href="#6-2-5-列表显示" class="headerlink" title="6.2.5. 列表显示"></a>6.2.5. 列表显示</h3><p>列表显示是一个用方括号括起来的可能为空的表达式系列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_display ::&#x3D;  &quot;[&quot; [starred_list | comprehension] &quot;]&quot;</span><br></pre></td></tr></table></figure>

<p>列表显示会产生一个新的列表对象，其内容通过一系列表达式或一个推导式来指定。 当提供由逗号分隔的一系列表达式时，其元素会从左至右被求值并按此顺序放入列表对象。 当提供一个推导式时，列表会根据推导式所产生的结果元素进行构建。</p>
<h3 id="6-2-6-集合显示"><a href="#6-2-6-集合显示" class="headerlink" title="6.2.6. 集合显示"></a>6.2.6. 集合显示</h3><p>集合显示是用花括号标明的，与字典显示的区别在于没有冒号分隔的键和值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_display ::&#x3D;  &quot;&#123;&quot; (starred_list | comprehension) &quot;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>集合显示会产生一个新的可变集合对象，其内容通过一系列表达式或一个推导式来指定。 当提供由逗号分隔的一系列表达式时，其元素会从左至右被求值并加入到集合对象。 当提供一个推导式时，集合会根据推导式所产生的结果元素进行构建。</p>
<p>空集合不能用 <code>{}</code> 来构建；该字面值所构建的是一个空字典。</p>
<h3 id="6-2-7-字典显示"><a href="#6-2-7-字典显示" class="headerlink" title="6.2.7. 字典显示"></a>6.2.7. 字典显示</h3><p>字典显示是一个用花括号括起来的可能为空的键/数据对系列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_display       ::&#x3D;  &quot;&#123;&quot; [key_datum_list | dict_comprehension] &quot;&#125;&quot;</span><br><span class="line">key_datum_list     ::&#x3D;  key_datum (&quot;,&quot; key_datum)* [&quot;,&quot;]</span><br><span class="line">key_datum          ::&#x3D;  expression &quot;:&quot; expression | &quot;**&quot; or_expr</span><br><span class="line">dict_comprehension ::&#x3D;  expression &quot;:&quot; expression comp_for</span><br></pre></td></tr></table></figure>

<p>字典显示会产生一个新的字典对象。</p>
<p>如果给出一个由逗号分隔的键/数据对序列，它们会从左至右被求值以定义字典的条目：每个键对象会被用作在字典中存放相应数据的键。 这意味着你可以在键/数据对序列中多次指定相同的键，最终字典的值将由最后一次给出的键决定。</p>
<p>双星号 <code>**</code> 表示 <em>字典拆包</em>。 它的操作数必须是一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a>。 每个映射项被会加入新的字典。 后续的值会替代先前的键/数据对和先前的字典拆包所设置的值。</p>
<p><em>3.5 新版功能:</em> 拆包到字典显示，最初由 <a href="https://www.python.org/dev/peps/pep-0448" target="_blank" rel="noopener"><strong>PEP 448</strong></a> 提出。</p>
<p>字典推导式与列表和集合推导式有所不同，它需要以冒号分隔的两个表达式，后面带上标准的 “for” 和 “if” 子句。 当推导式被执行时，作为结果的键和值元素会按它们的产生顺序被加入新的字典。</p>
<p>对键取值类型的限制已列在之前的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#types" target="_blank" rel="noopener">标准类型层级结构</a> 一节中。 (总的说来，键的类型应该为 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>，这就把所有可变对象都排除在外。) 重复键之间的冲突不会被检测；指定键所保存的最后一个数据 (即在显示中排最右边的文本) 为最终有效数据。</p>
<p><em>在 3.8 版更改:</em> 在 Python 3.8 之前的字典推导式中，并没有定义好键和值的求值顺序。 在 CPython 中，值会先于键被求值。 根据 <a href="https://www.python.org/dev/peps/pep-0572" target="_blank" rel="noopener"><strong>PEP 572</strong></a> 的提议，从 3.8 开始，键会先于值被求值。</p>
<h3 id="6-2-8-生成器表达式"><a href="#6-2-8-生成器表达式" class="headerlink" title="6.2.8. 生成器表达式"></a>6.2.8. 生成器表达式</h3><p>生成器表达式是用圆括号括起来的紧凑形式生成器标注。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generator_expression ::&#x3D;  &quot;(&quot; expression comp_for &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>生成器表达式会产生一个新的生成器对象。 其句法与推导式相同，区别在于它是用圆括号而不是用方括号或花括号括起来的。</p>
<p>在生成器表达式中使用的变量会在为生成器对象调用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法的时候以惰性方式被求值（即与普通生成器相同的方式）。 但是，最左侧 <code>for</code> 子句内的可迭代对象是会被立即求值的，因此它所造成的错误会在生成器表达式被定义时被检测到，而不是在获取第一个值时才出错。 后续的 <code>for</code> 子句以及最左侧 <code>for</code> 子句内的任何筛选条件无法在外层作用域内被求值，因为它们可能会依赖于从最左侧可迭代对象获取的值。 例如: <code>(x*y for x in range(10) for y in range(x, x+10))</code>.</p>
<p>圆括号在只附带一个参数的调用中可以被省略。 详情参见 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#calls" target="_blank" rel="noopener">调用</a> 一节。</p>
<p>为了避免干扰到生成器表达式本身的预期操作，禁止在隐式定义的生成器中使用 <code>yield</code> 和 <code>yield from</code> 表达式。</p>
<p>如果生成器表达式包含 <code>async for</code> 子句或 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式，则称为 <em>异步生成器表达式</em>。 异步生成器表达式会返回一个新的异步生成器对象，此对象属于异步迭代器 (参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#async-iterators" target="_blank" rel="noopener">异步迭代器</a>)。</p>
<p><em>3.6 新版功能:</em> 引入了异步生成器表达式。</p>
<p><em>在 3.7 版更改:</em> 在 Python 3.7 之前，异步生成器表达式只能在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 协和中出现。 从 3.7 开始，任何函数都可以使用异步生成器表达式。</p>
<p><em>在 3.8 版更改:</em> <code>yield</code> 和 <code>yield from</code> 在隐式嵌套的作用域中已被禁用。</p>
<h3 id="6-2-9-yield-表达式"><a href="#6-2-9-yield-表达式" class="headerlink" title="6.2.9. yield 表达式"></a>6.2.9. yield 表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yield_atom       ::&#x3D;  &quot;(&quot; yield_expression &quot;)&quot;</span><br><span class="line">yield_expression ::&#x3D;  &quot;yield&quot; [expression_list | &quot;from&quot; expression]</span><br></pre></td></tr></table></figure>

<p>yield 表达式在定义 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 函数或是 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-generator" target="_blank" rel="noopener">asynchronous generator</a> 的时候才会用到。 因此只能在函数定义的内部使用yield表达式。 在一个函数体内使用 yield 表达式会使这个函数变成一个生成器，并且在一个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 定义的函数体内使用 yield 表达式会让协程函数变成异步的生成器。 比如说:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def gen():  # defines a generator function</span><br><span class="line">    yield 123</span><br><span class="line"></span><br><span class="line">async def agen(): # defines an asynchronous generator function</span><br><span class="line">    yield 123</span><br></pre></td></tr></table></figure>

<p>由于它们会对外层作用域造成附带影响，<code>yield</code> 表达式不被允许作为用于实现推导式和生成器表达式的隐式定义作用域的一部分。</p>
<p><em>在 3.8 版更改:</em> 禁止在实现推导式和生成器表达式的隐式嵌套作用域中使用 yield 表达式。</p>
<p>下面是对生成器函数的描述，异步生成器函数会在 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#asynchronous-generator-functions" target="_blank" rel="noopener">异步生成器函数</a> 一节中单独介绍。</p>
<p>当一个生成器函数被调用的时候，它返回一个迭代器，称为生成器。然后这个生成器来控制生成器函数的执行。当这个生成器的某一个方法被调用的时候，生成器函数开始执行。这时会一直执行到第一个 yield 表达式，在此执行再次被挂起，给生成器的调用者返回 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#grammar-token-expression-list" target="_blank" rel="noopener"><code>expression_list</code></a> 的值。挂起后，我们说所有局部状态都被保留下来，包括局部变量的当前绑定，指令指针，内部求值栈和任何异常处理的状态。通过调用生成器的某一个方法，生成器函数继续执行。此时函数的运行就和 yield 表达式只是一个外部函数调用的情况完全一致。恢复后 yield 表达式的值取决于调用的哪个方法来恢复执行。 如果用的是 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> (通常通过语言内置的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 或是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 来调用) 那么结果就是 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>. 否则，如果用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a>, 那么结果就是传递给send方法的值。</p>
<p>所有这些使生成器函数与协程非常相似；它们 yield 多次，它们具有多个入口点，并且它们的执行可以被挂起。唯一的区别是生成器函数不能控制在它在 yield 后交给哪里继续执行；控制权总是转移到生成器的调用者。</p>
<p>在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 结构中的任何位置都允许yield表达式。如果生成器在(因为引用计数到零或是因为被垃圾回收)销毁之前没有恢复执行，将调用生成器-迭代器的 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>close()</code></a> 方法. close 方法允许任何挂起的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句执行。</p>
<p>当使用 <code>yield from</code> 时，它会将所提供的表达式视为一个子迭代器。 这个子迭代器产生的所有值都直接被传递给当前生成器方法的调用者。 通过 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a> 传入的任何值以及通过 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.throw" target="_blank" rel="noopener"><code>throw()</code></a> 传入的任何异常如果有适当的方法则会被传给下层迭代器。 如果不是这种情况，那么 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a> 将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，而 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.throw" target="_blank" rel="noopener"><code>throw()</code></a> 将立即引发所传入的异常。</p>
<p>当下层迭代器完成时，被引发的 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 实例的 <code>value</code> 属性会成为 yield 表达式的值。 它可以在引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 时被显式地设置，也可以在子迭代器是一个生成器时自动地设置（通过从子生成器返回一个值）。</p>
<blockquote>
<p><em>在 3.3 版更改:</em> 添加 <code>yield from</code> 以委托控制流给一个子迭代器。</p>
</blockquote>
<p>当yield表达式是赋值语句右侧的唯一表达式时，括号可以省略。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0255" target="_blank" rel="noopener"><strong>PEP 255</strong></a> - 简单生成器</p>
<p>在 Python 中加入生成器和 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 语句的提议。</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener"><strong>PEP 342</strong></a> - 通过增强型生成器实现协程</p>
<p>增强生成器 API 和语法的提议，使其可以被用作简单的协程。</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-0380" target="_blank" rel="noopener"><strong>PEP 380</strong></a> - 委托给子生成器的语法</p>
<p>引入 <code>yield_from</code> 语法以方便地委托给子生成器的提议。</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-0525" target="_blank" rel="noopener"><strong>PEP 525</strong></a> - 异步生成器</p>
<p>通过给协程函数加入生成器功能对 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 进行扩展的提议。</p>
</li>
</ul>
<h4 id="6-2-9-1-生成器-迭代器的方法"><a href="#6-2-9-1-生成器-迭代器的方法" class="headerlink" title="6.2.9.1. 生成器-迭代器的方法"></a>6.2.9.1. 生成器-迭代器的方法</h4><p>这个子小节描述了生成器迭代器的方法。 它们可被用于控制生成器函数的执行。</p>
<p>请注意在生成器已经在执行时调用以下任何方法都会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p>
<ul>
<li><p><code>generator.``__next__</code>()</p>
<p>开始一个生成器函数的执行或是从上次执行的 yield 表达式位置恢复执行。 当一个生成器函数通过 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法恢复执行时，当前的 yield 表达式总是取值为 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 随后会继续执行到下一个 yield 表达式，其 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#grammar-token-expression-list" target="_blank" rel="noopener"><code>expression_list</code></a> 的值会返回给 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 的调用者。 如果生成器没有产生下一个值就退出，则将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。此方法通常是隐式地调用，例如通过 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 循环或是内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 函数。</p>
</li>
<li><p><code>generator.``send</code>(<em>value</em>)</p>
<p>恢复执行并向生成器函数“发送”一个值。 <em>value</em> 参数将成为当前 yield 表达式的结果。 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a> 方法会返回生成器所产生的下一个值，或者如果生成器没有产生下一个值就退出则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>。 当调用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a> 来启动生成器时，它必须以 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 作为调用参数，因为这时没有可以接收值的 yield 表达式。</p>
</li>
<li><p><code>generator.``throw</code>(<em>type</em>[, <em>value</em>[, <em>traceback</em>]])</p>
<p>在生成器暂停的位置引发 <code>type</code> 类型的异常，并返回该生成器函数所产生的下一个值。 如果生成器没有产生下一个值就退出，则将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。 如果生成器函数没有捕获传入的异常，或引发了另一个异常，则该异常会被传播给调用者。</p>
</li>
</ul>
<ul>
<li><p><code>generator.``close</code>()</p>
<p>在生成器函数暂停的位置引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#GeneratorExit" target="_blank" rel="noopener"><code>GeneratorExit</code></a>。 如果之后生成器函数正常退出、关闭或引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#GeneratorExit" target="_blank" rel="noopener"><code>GeneratorExit</code></a> (由于未捕获该异常) 则关闭并返回其调用者。 如果生成器产生了一个值，关闭会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 如果生成器引发任何其他异常，它会被传播给调用者。 如果生成器已经由于异常或正常退出则 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>close()</code></a> 不会做任何事。</p>
</li>
</ul>
<h4 id="6-2-9-2-示例"><a href="#6-2-9-2-示例" class="headerlink" title="6.2.9.2. 示例"></a>6.2.9.2. 示例</h4><p>这里是一个简单的例子，演示了生成器和生成器函数的行为:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def echo(value&#x3D;None):</span><br><span class="line">...     print(&quot;Execution starts when &#39;next()&#39; is called for the first time.&quot;)</span><br><span class="line">...     try:</span><br><span class="line">...         while True:</span><br><span class="line">...             try:</span><br><span class="line">...                 value &#x3D; (yield value)</span><br><span class="line">...             except Exception as e:</span><br><span class="line">...                 value &#x3D; e</span><br><span class="line">...     finally:</span><br><span class="line">...         print(&quot;Don&#39;t forget to clean up when &#39;close()&#39; is called.&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; generator &#x3D; echo(1)</span><br><span class="line">&gt;&gt;&gt; print(next(generator))</span><br><span class="line">Execution starts when &#39;next()&#39; is called for the first time.</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(next(generator))</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; print(generator.send(2))</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; generator.throw(TypeError, &quot;spam&quot;)</span><br><span class="line">TypeError(&#39;spam&#39;,)</span><br><span class="line">&gt;&gt;&gt; generator.close()</span><br><span class="line">Don&#39;t forget to clean up when &#39;close()&#39; is called.</span><br></pre></td></tr></table></figure>

<p>对于 <code>yield from</code> 的例子, 参见“Python 有什么新变化”中的 <a href="https://docs.python.org/zh-cn/3/whatsnew/3.3.html#pep-380" target="_blank" rel="noopener">PEP 380: 委托给子生成器的语法</a>。</p>
<h4 id="6-2-9-3-异步生成器函数"><a href="#6-2-9-3-异步生成器函数" class="headerlink" title="6.2.9.3. 异步生成器函数"></a>6.2.9.3. 异步生成器函数</h4><p>在一个使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 定义的函数或方法中出现的 yield 表达式会进一步将该函数定义为一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-generator" target="_blank" rel="noopener">asynchronous generator</a> 函数。</p>
<p>当一个异步生成器函数被调用时，它会返回一个名为异步生成器对象的异步迭代器。 此对象将在之后控制该生成器函数的执行。 异步生成器对象通常被用在协程函数的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 语句中，类似于在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 语句中使用生成器对象。</p>
<p>调用异步生成器的方法之一将返回 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象，执行会在此对象被等待时启动。 到那时，执行将前往第一个 yield 表达式，在那里它会再次暂停，将 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#grammar-token-expression-list" target="_blank" rel="noopener"><code>expression_list</code></a> 的值返回给等待中的协程。 与生成器一样，挂起意味着局部的所有状态会被保留，包括局部变量的当前绑定、指令的指针、内部求值的堆栈以及任何异常处理的状态。 当执行在等待异步生成器的方法返回下一个对象后恢复时，该函数可以从原状态继续进行，就仿佛 yield 表达式只是另一个外部调用。 恢复执行之后 yield 表达式的值取决于恢复执行所用的方法。 如果使用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 则结果为 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 否则的话，如果使用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.asend" target="_blank" rel="noopener"><code>asend()</code></a> 则结果将是传递给该方法的值。</p>
<p>在异步生成器函数中，yield 表达式允许出现在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 结构的任何位置。 但是，如果一个异步生成器在其被终结（由于引用计数达到零或被作为垃圾回收）之前未被恢复，则then a yield expression within a <code>try</code> 结构中的 yield 表达式可能导致挂起的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句执行失败。 在此情况下，应由运行该异步生成器的事件循环或任务调度器来负责调用异步生成器-迭代器的 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.aclose" target="_blank" rel="noopener"><code>aclose()</code></a> 方法并运行所返回的协程对象，从而允许任何挂起的 <code>finally</code> 子句得以执行。</p>
<p>为了能处理最终化，事件循环应该定义一个 <em>终结器</em> 函数，它接受一个异步生成器-迭代器且可能调用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.aclose" target="_blank" rel="noopener"><code>aclose()</code></a> 并执行协程。 这个 <em>终结器</em> 可能通过调用 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.set_asyncgen_hooks" target="_blank" rel="noopener"><code>sys.set_asyncgen_hooks()</code></a> 来注册。 当首次迭代时，异步生成器-迭代器将保存已注册的 <em>终结器</em> 以便在最终化时调用。 有关For a reference example of a <em>终结器</em> 方法的参考示例请查看 <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_events.py" target="_blank" rel="noopener">Lib/asyncio/base_events.py</a> 中实现的 <code>asyncio.Loop.shutdown_asyncgens</code>。</p>
<p><code>yield from</code> 表达式如果在异步生成器函数中使用会引发语法错误。</p>
<h4 id="6-2-9-4-异步生成器-迭代器方法"><a href="#6-2-9-4-异步生成器-迭代器方法" class="headerlink" title="6.2.9.4. 异步生成器-迭代器方法"></a>6.2.9.4. 异步生成器-迭代器方法</h4><p>这个子小节描述了异步生成器迭代器的方法，它们可被用于控制生成器函数的执行。</p>
<ul>
<li><p><em>coroutine</em> <code>agen.``__anext__</code>()</p>
<p>返回一个可等待对象，它在运行时会开始执行该异步生成器或是从上次执行的 yield 表达式位置恢复执行。 当一个异步生成器函数通过 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法恢复执行时，当前的 yield 表达式所返回的可等待对象总是取值为 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，它在运行时将继续执行到下一个 yield 表达式。 该 yield 表达式的 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#grammar-token-expression-list" target="_blank" rel="noopener"><code>expression_list</code></a> 的值会是完成的协程所引发的 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常的值。 如果异步生成器没有产生下一个值就退出，则该可等待对象将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a> 异常，提示该异步迭代操作已完成。此方法通常是通过 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 循环隐式地调用。</p>
</li>
<li><p><em>coroutine</em> <code>agen.``asend</code>(<em>value</em>)</p>
<p>返回一个可等待对象，它在运行时会恢复该异步生成器的执行。 与生成器的 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a> 方法一样，此方法会“发送”一个值给异步生成器函数，其 <em>value</em> 参数会成为当前 yield 表达式的结果值。 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.asend" target="_blank" rel="noopener"><code>asend()</code></a> 方法所返回的可等待对象将返回生成器产生的下一个值，其值为所引发的 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，或者如果异步生成器没有产生下一个值就退出则引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a>。 当调用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.asend" target="_blank" rel="noopener"><code>asend()</code></a> 来启动异步生成器时，它必须以 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 作为调用参数，因为这时没有可以接收值的 yield 表达式。</p>
</li>
<li><p><em>coroutine</em> <code>agen.``athrow</code>(<em>type</em>[, <em>value</em>[, <em>traceback</em>]])</p>
<p>返回一个可等待对象，它会在异步生成器暂停的位置引发 <code>type</code> 类型的异常，并返回该生成器函数所产生的下一个值，其值为所引发的 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。 如果异步生成器没有产生下一个值就退出，则将由该可等待对象引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a> 异步。 如果生成器函数没有捕获传入的异常，或引发了另一个异常，则当可等待对象运行时该异常会被传播给可等待对象的调用者。</p>
</li>
</ul>
<ul>
<li><p><em>coroutine</em> <code>agen.``aclose</code>()</p>
<p>返回一个可等待对象，它会在运行时向异步生成器函数暂停的位置抛入一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#GeneratorExit" target="_blank" rel="noopener"><code>GeneratorExit</code></a>。 如果该异步生成器函数正常退出、关闭或引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#GeneratorExit" target="_blank" rel="noopener"><code>GeneratorExit</code></a> (由于未捕获该异常) 则返回的可等待对象将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。 后续调用异步生成器所返回的任何其他可等待对象将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a> 异常。 如果异步生成器产生了一个值，该可等待对象会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 如果异步生成器引发任何其他异常，它会被传播给可等待对象的调用者。 如果异步生成器已经由于异常或正常退出则后续调用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#agen.aclose" target="_blank" rel="noopener"><code>aclose()</code></a> 将返回一个不会做任何事的可等待对象。</p>
</li>
</ul>
<h2 id="6-3-原型"><a href="#6-3-原型" class="headerlink" title="6.3. 原型"></a>6.3. 原型</h2><p>原型代表编程语言中最紧密绑定的操作。 它们的句法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary ::&#x3D;  atom | attributeref | subscription | slicing | call</span><br></pre></td></tr></table></figure>



<h3 id="6-3-1-属性引用"><a href="#6-3-1-属性引用" class="headerlink" title="6.3.1. 属性引用"></a>6.3.1. 属性引用</h3><p>属性引用是后面带有一个句点加一个名称的原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attributeref ::&#x3D;  primary &quot;.&quot; identifier</span><br></pre></td></tr></table></figure>

<p>此原型必须求值为一个支持属性引用的类型的对象，多数对象都支持属性引用。 随后该对象会被要求产生以指定标识符为名称的属性。 这个产生过程可通过重载 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 方法来自定义。 如果这个属性不可用，则将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 异常。 否则的话，所产生对象的类型和值会根据该对象来确定。 对同一属性引用的多次求值可能产生不同的对象。</p>
<h3 id="6-3-2-抽取"><a href="#6-3-2-抽取" class="headerlink" title="6.3.2. 抽取"></a>6.3.2. 抽取</h3><p>抽取就是在序列（字符串、元组或列表）或映射（字典）对象中选择一项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscription ::&#x3D;  primary &quot;[&quot; expression_list &quot;]&quot;</span><br></pre></td></tr></table></figure>

<p>此原型必须求值为一个支持抽取操作的对象（例如列表或字典）。 用户定义的对象可通过定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法来支持抽取操作。</p>
<p>对于内置对象，有两种类型的对象支持抽取操作:</p>
<p>如果原型为映射，表达式列表必须求值为一个以该映射的键为值的对象，抽取操作会在映射中选出该键所对应的值。（表达式列表为一个元组，除非其中只有一项。）</p>
<p>如果原型为序列，表达式列表必须求值为一个整数或一个切片（详情见下节）。</p>
<p>正式句法规则并没有在序列中设置负标号的特殊保留条款；但是，内置序列所提供的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法都可通过在索引中添加序列长度来解析负标号 (这样 <code>x[-1]</code> 会选出 <code>x</code> 中的最后一项)。 结果值必须为一个小于序列中项数的非负整数，抽取操作会选出标号为该值的项（从零开始数）。 由于对负标号和切片的支持存在于对象的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法，重载此方法的子类需要显式地添加这种支持。</p>
<p>字符串的项是字符。 字符不是单独的数据类型而是仅有一个字符的字符串。</p>
<h3 id="6-3-3-切片"><a href="#6-3-3-切片" class="headerlink" title="6.3.3. 切片"></a>6.3.3. 切片</h3><p>切片就是在序列对象（字符串、元组或列表）中选择某个范围内的项。 切片可被用作表达式以及赋值或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句的目标。 切片的句法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slicing      ::&#x3D;  primary &quot;[&quot; slice_list &quot;]&quot;</span><br><span class="line">slice_list   ::&#x3D;  slice_item (&quot;,&quot; slice_item)* [&quot;,&quot;]</span><br><span class="line">slice_item   ::&#x3D;  expression | proper_slice</span><br><span class="line">proper_slice ::&#x3D;  [lower_bound] &quot;:&quot; [upper_bound] [ &quot;:&quot; [stride] ]</span><br><span class="line">lower_bound  ::&#x3D;  expression</span><br><span class="line">upper_bound  ::&#x3D;  expression</span><br><span class="line">stride       ::&#x3D;  expression</span><br></pre></td></tr></table></figure>

<p>此处的正式句法中存在一点歧义：任何形似表达式列表的东西同样也会形似切片列表，因此任何抽取操作也可以被解析为切片。 为了不使句法更加复杂，于是通过定义将此情况解析为抽取优先于解析为切片来消除这种歧义（切片列表未包含正确的切片就属于此情况）。</p>
<p>切片的语义如下所述。 元型通过一个根据下面的切片列表来构造的键进行索引（与普通抽取一样使用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法）。 如果切片列表包含至少一个逗号，则键将是一个包含切片项转换的元组；否则的话，键将是单个切片项的转换。 切片项如为一个表达式，则其转换就是该表达式。 一个正确切片的转换就是一个切片对象（参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#types" target="_blank" rel="noopener">标准类型层级结构</a> 一节），该对象的 <code>start</code>, <code>stop</code> 和 <code>step</code> 属性将分别为表达式所给出的下界、上界和步长值，省略的表达式将用 <code>None</code> 来替换。</p>
<h3 id="6-3-4-调用"><a href="#6-3-4-调用" class="headerlink" title="6.3.4. 调用"></a>6.3.4. 调用</h3><p>所谓调用就是附带可能为空的一系列 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" target="_blank" rel="noopener">参数</a> 来执行一个可调用对象 (例如 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-function" target="_blank" rel="noopener">function</a>):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">call                 ::&#x3D;  primary &quot;(&quot; [argument_list [&quot;,&quot;] | comprehension] &quot;)&quot;</span><br><span class="line">argument_list        ::&#x3D;  positional_arguments [&quot;,&quot; starred_and_keywords]</span><br><span class="line">                            [&quot;,&quot; keywords_arguments]</span><br><span class="line">                          | starred_and_keywords [&quot;,&quot; keywords_arguments]</span><br><span class="line">                          | keywords_arguments</span><br><span class="line">positional_arguments ::&#x3D;  positional_item (&quot;,&quot; positional_item)*</span><br><span class="line">positional_item      ::&#x3D;  assignment_expression | &quot;*&quot; expression</span><br><span class="line">starred_and_keywords ::&#x3D;  (&quot;*&quot; expression | keyword_item)</span><br><span class="line">                          (&quot;,&quot; &quot;*&quot; expression | &quot;,&quot; keyword_item)*</span><br><span class="line">keywords_arguments   ::&#x3D;  (keyword_item | &quot;**&quot; expression)</span><br><span class="line">                          (&quot;,&quot; keyword_item | &quot;,&quot; &quot;**&quot; expression)*</span><br><span class="line">keyword_item         ::&#x3D;  identifier &quot;&#x3D;&quot; expression</span><br></pre></td></tr></table></figure>

<p>一个可选项为在位置和关键字参数后加上逗号而不影响语义。</p>
<p>此原型必须求值为一个可调用对象（用户定义的函数，内置函数，内置对象的方法，类对象，类实例的方法以及任何具有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__call__" target="_blank" rel="noopener"><code>__call__()</code></a> 方法的对象都是可调用对象）。 所有参数表达式将在尝试调用前被求值。 请参阅 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" target="_blank" rel="noopener">函数定义</a> 一节了解正式的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-parameter" target="_blank" rel="noopener">parameter</a> 列表句法。</p>
<p>如果存在关键字参数，它们会先通过以下操作被转换为位置参数。 首先，为正式参数创建一个未填充空位的列表. 如果有 N 个位置参数，则将它们放入前 N 个空位。 然后，对于每个关键字参数，使用标识符来确定其对应的空位（如果标识符与第一个正式参数名相同则使用第一个个空位，依此类推）。 如果空位已被填充，则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。 否则，将参数值放入空位进行填充（即使表达式为 <code>None</code> 也会填充空位）。 当所有参数处理完毕时，尚未填充的空位将用来自函数定义的相应默认值来填充。 （函数一旦定义其参数默认值就会被计算；因此，当列表或字典这类可变对象被用作默认值时，将会被所有未指定相应空位参数值的调用所共享；这种情况通常应当避免。） 如果任何一个未填充空位没有指定默认值，则会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。 否则的话，已填充空位的列表会被作为调用的参数列表。</p>
<p><strong>CPython implementation detail:</strong> 某些实现可能提供位置参数没有名称的内置函数，即使它们在文档说明的场合下有“命名”，因此不能以关键字形式提供参数。 在 CPython 中，以 C 编写并使用 <a href="https://docs.python.org/zh-cn/3/c-api/arg.html#c.PyArg_ParseTuple" target="_blank" rel="noopener"><code>PyArg_ParseTuple()</code></a> 来解析其参数的函数实现就属于这种情况。</p>
<p>如果存在比正式参数空位多的位置参数，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常，除非有一个正式参数使用了 <code>*identifier</code> 句法；在此情况下，该正式参数将接受一个包含了多余位置参数的元组（如果没有多余位置参数则为一个空元组）。</p>
<p>如果任何关键字参数没有与之对应的正式参数名称，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常，除非有一个正式参数使用了 <code>**identifier</code> 句法，该正式参数将接受一个包含了多余关键字参数的字典（使用关键字作为键而参数值作为与键对应的值），如果没有多余关键字参数则为一个（新的）空字典。</p>
<p>如果函数调用中出现了 <code>*expression</code> 句法，<code>expression</code> 必须求值为一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a>。 来自该可迭代对象的元素会被当作是额外的位置参数。 对于 <code>f(x1, x2, *y, x3, x4)</code> 调用，如果 <em>y</em> 求值为一个序列 <em>y1</em>, …, <em>yM*，则它就等价于一个带有 M+4 个位置参数 *x1</em>, <em>x2</em>, <em>y1</em>, …, <em>yM</em>, <em>x3</em>, <em>x4</em> 的调用。</p>
<p>这样做的一个后果是虽然 <code>*expression</code> 句法可能出现于显式的关键字参数 <em>之后<em>，但它会在关键字参数（以及任何 `*</em>expression` 参数 – 见下文） *之前</em> 被处理。 因此:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a, b):</span><br><span class="line">...     print(a, b)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f(b&#x3D;1, *(2,))</span><br><span class="line">2 1</span><br><span class="line">&gt;&gt;&gt; f(a&#x3D;1, *(2,))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: f() got multiple values for keyword argument &#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; f(1, *(2,))</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<p>在同一个调用中同时使用关键字参数和 <code>*expression</code> 句法并不常见，因此实际上这样的混淆不会发生。</p>
<p>如果函数调用中出现了 <code>**expression</code> 句法，<code>expression</code> 必须求值为一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a>，其内容会被当作是额外的关键字参数。 如果一个关键字已存在（作为显式关键字参数，或来自另一个拆包），则将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。</p>
<p>使用 <code>*identifier</code> 或 <code>**identifier</code> 句法的正式参数不能被用作位置参数空位或关键字参数名称。</p>
<p><em>在 3.5 版更改:</em> 函数调用接受任意数量的 <code>*</code> 和 <code>**</code> 拆包，位置参数可能跟在可迭代对象拆包 (<code>*</code>) 之后，而关键字参数可能跟在字典拆包 (<code>**</code>) 之后。 由 <a href="https://www.python.org/dev/peps/pep-0448" target="_blank" rel="noopener"><strong>PEP 448</strong></a> 发起最初提议。</p>
<p>除非引发了异常，调用总是会有返回值，返回值也可能为 <code>None</code>。 返回值的计算方式取决于可调用对象的类型。</p>
<p>如果类型为—</p>
<ul>
<li><p>用户自定义函数:</p>
<p>函数的代码块会被执行，并向其传入参数列表。 代码块所做的第一件事是将正式形参绑定到对应参数；相关描述参见 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" target="_blank" rel="noopener">函数定义</a> 一节。 当代码块执行 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句时，由其指定函数调用的返回值。</p>
</li>
<li><p>内置函数或方法:</p>
<p>具体结果依赖于解释器；有关内置函数和方法的描述参见 <a href="https://docs.python.org/zh-cn/3/library/functions.html#built-in-funcs" target="_blank" rel="noopener">内置函数</a>。</p>
</li>
<li><p>类对象:</p>
<p>返回该类的一个新实例。</p>
</li>
<li><p>类实例方法:</p>
<p>调用相应的用户自定义函数，向其传入的参数列表会比调用的参数列表多一项：该实例将成为第一个参数。</p>
</li>
<li><p>类实例:</p>
<p>该类必须定义有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__call__" target="_blank" rel="noopener"><code>__call__()</code></a> 方法；作用效果将等价于调用该方法。</p>
</li>
</ul>
<h2 id="6-4-await-表达式"><a href="#6-4-await-表达式" class="headerlink" title="6.4. await 表达式"></a>6.4. await 表达式</h2><p>挂起 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 的执行以等待一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。 只能在 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine-function" target="_blank" rel="noopener">coroutine function</a> 内部使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await_expr ::&#x3D;  &quot;await&quot; primary</span><br></pre></td></tr></table></figure>

<p><em>3.5 新版功能.</em></p>
<h2 id="6-5-幂运算符"><a href="#6-5-幂运算符" class="headerlink" title="6.5. 幂运算符"></a>6.5. 幂运算符</h2><p>幂运算符的绑定比在其左侧的一元运算符更紧密；但绑定紧密程度不及在其右侧的一元运算符。 句法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power ::&#x3D;  (await_expr | primary) [&quot;**&quot; u_expr]</span><br></pre></td></tr></table></figure>

<p>因此，在一个未加圆括号的幂运算符和单目运算符序列中，运算符将从右向左求值（这不会限制操作数的求值顺序）: <code>-1**2</code> 结果将为 <code>-1</code>。</p>
<p>幂运算符与附带两个参数调用内置 <a href="https://docs.python.org/zh-cn/3/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a> 函数具有相同的语义：结果为对其左参数进行其右参数所指定幂次的乘方运算。 数值参数会先转换为相同类型，结果也为转换后的类型。</p>
<p>对于 int 类型的操作数，结果将具有与操作数相同的类型，除非第二个参数为负数；在那种情况下，所有参数会被转换为 float 类型并输出 float 类型的结果。 例如，<code>10**2</code> 返回 <code>100</code>，而 <code>10**-2</code> 返回 <code>0.01</code>。</p>
<p>对 <code>0.0</code> 进行负数幂次运算将导致 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>。 对负数进行分数幂次运算将返回 <a href="https://docs.python.org/zh-cn/3/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> 数值。 （在早期版本中这将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。）</p>
<h2 id="6-6-一元算术和位运算"><a href="#6-6-一元算术和位运算" class="headerlink" title="6.6. 一元算术和位运算"></a>6.6. 一元算术和位运算</h2><p>所有算术和位运算具有相同的优先级:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_expr ::&#x3D;  power | &quot;-&quot; u_expr | &quot;+&quot; u_expr | &quot;~&quot; u_expr</span><br></pre></td></tr></table></figure>

<p>一元运算符 <code>-</code> (负) 会产生其数值参数的负值。</p>
<p>一元运算符 <code>+</code> (正) 会产生与其数值参数相同的值。</p>
<p>一元运算符 <code>~</code> (取反) 的结果是对其整数参数按位取反。 <code>x</code> 的按位取反被定义为 <code>-(x+1)</code>。 它只作用于整数。</p>
<p>在所有三种情况下，如果参数的类型不正确，将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。</p>
<h2 id="6-7-二元算术运算符"><a href="#6-7-二元算术运算符" class="headerlink" title="6.7. 二元算术运算符"></a>6.7. 二元算术运算符</h2><p>二元算术运算符遵循传统的优先级。 请注意某些此类运算符也作用于特定的非数字类型。 除幂运算符以外只有两个优先级别，一个作用于乘法型运算符，另一个作用于加法型运算符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_expr ::&#x3D;  u_expr | m_expr &quot;*&quot; u_expr | m_expr &quot;@&quot; m_expr |</span><br><span class="line">            m_expr &quot;&#x2F;&#x2F;&quot; u_expr | m_expr &quot;&#x2F;&quot; u_expr |</span><br><span class="line">            m_expr &quot;%&quot; u_expr</span><br><span class="line">a_expr ::&#x3D;  m_expr | a_expr &quot;+&quot; m_expr | a_expr &quot;-&quot; m_expr</span><br></pre></td></tr></table></figure>

<p>运算符 <code>*</code> (乘) 将输出其参数的乘积。 两个参数或者必须都为数字，或者一个参数必须为整数而另一个参数必须为序列。 在前一种情况下，两个数字将被转换为相同类型然后相乘。 在后一种情况下，将执行序列的重复；重复因子为负数将输出空序列。</p>
<p>运算符 <code>@</code> (at) 的目标是用于矩阵乘法。 没有内置 Python 类型实现此运算符。</p>
<p><em>3.5 新版功能.</em></p>
<p>运算符 <code>/</code> (除) 和 <code>//</code> (整除) 将输出其参数的商。 两个数字参数将先被转换为相同类型。 整数相除会输出一个 float 值，整数相整除的结果仍是整数；整除的结果就是使用 ‘floor’ 函数进行算术除法的结果。 除以零的运算将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a> 异常。</p>
<p>运算符 <code>%</code> (模) 将输出第一个参数除以第二个参数的余数。 两个数字参数将先被转换为相同类型。 右参数为零将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a> 异常。 参数可以为浮点数，例如 <code>3.14%0.7</code> 等于 <code>0.34</code> (因为 <code>3.14</code> 等于 <code>4*0.7 + 0.34</code>)。 模运算符的结果的正负总是与第二个操作数一致（或是为零）；结果的绝对值一定小于第二个操作数的绝对值 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id17" target="_blank" rel="noopener">1</a>。</p>
<p>整除与模运算符的联系可通过以下等式说明: <code>x == (x//y)*y + (x%y)</code>。 此外整除与模也可通过内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a> 来同时进行: <code>divmod(x, y) == (x//y, x%y)</code>。 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id18" target="_blank" rel="noopener">2</a>。</p>
<p>除了对数字执行模运算，运算符 <code>%</code> 还被字符串对象重载用于执行旧式的字符串格式化（又称插值）。 字符串格式化句法的描述参见 Python 库参考的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting" target="_blank" rel="noopener">printf 风格的字符串格式化</a> 一节。</p>
<p>整除运算符，模运算符和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a> 函数未被定义用于复数。 如果有必要可以使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a> 函数将其转换为浮点数。</p>
<p>运算符 <code>+</code> (addition) 将输出其参数的和。 两个参数或者必须都为数字，或者都为相同类型的序列。 在前一种情况下，两个数字将被转换为相同类型然后相加。 在后一种情况下，将执行序列拼接操作。</p>
<p>运算符 <code>-</code> (减) 将输出其参数的差。 两个数字参数将先被转换为相同类型。</p>
<h2 id="6-8-移位运算"><a href="#6-8-移位运算" class="headerlink" title="6.8. 移位运算"></a>6.8. 移位运算</h2><p>移位运算的优先级低于算术运算:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift_expr ::&#x3D;  a_expr | shift_expr (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;) a_expr</span><br></pre></td></tr></table></figure>

<p>这些运算符接受整数参数。 它们会将第一个参数左移或右移第二个参数所指定的比特位数。</p>
<p>右移 <em>n</em> 位被定义为被 <code>pow(2,n)</code> 整除。 左移 <em>n</em> 位被定义为乘以 <code>pow(2,n)</code>。</p>
<h2 id="6-9-二元位运算"><a href="#6-9-二元位运算" class="headerlink" title="6.9. 二元位运算"></a>6.9. 二元位运算</h2><p>三种位运算具有各不相同的优先级:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and_expr ::&#x3D;  shift_expr | and_expr &quot;&amp;&quot; shift_expr</span><br><span class="line">xor_expr ::&#x3D;  and_expr | xor_expr &quot;^&quot; and_expr</span><br><span class="line">or_expr  ::&#x3D;  xor_expr | or_expr &quot;|&quot; xor_expr</span><br></pre></td></tr></table></figure>

<p>运算符 <code>&amp;</code> 对两个参数进行按位 AND (与) 运算，两个参数必须为整数。</p>
<p>运算符 <code>^</code> 对两个参数进行按位 XOR (异或) 运算，两个参数必须为整数。</p>
<p>运算符 <code>|</code> 对两个参数进行按位 OR (或) 运算，两个参数必须为整数。</p>
<h2 id="6-10-比较运算"><a href="#6-10-比较运算" class="headerlink" title="6.10. 比较运算"></a>6.10. 比较运算</h2><p>与 C 不同，Python 中所有比较运算的优先级相同，低于任何算术、移位或位运算。 另一个与 C 不同之处在于 <code>a &lt; b &lt; c</code> 这样的表达式会按传统算术法则来解读:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">comparison    ::&#x3D;  or_expr (comp_operator or_expr)*</span><br><span class="line">comp_operator ::&#x3D;  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&#x3D;&#x3D;&quot; | &quot;&gt;&#x3D;&quot; | &quot;&lt;&#x3D;&quot; | &quot;!&#x3D;&quot;</span><br><span class="line">                   | &quot;is&quot; [&quot;not&quot;] | [&quot;not&quot;] &quot;in&quot;</span><br></pre></td></tr></table></figure>

<p>比较运算将输出布尔值: <code>True</code> 或 <code>False</code>。</p>
<p>比较运算可以任意串连，例如 <code>x &lt; y &lt;= z</code> 等价于 <code>x &lt; y and y &lt;= z</code>，除了 <code>y</code> 只被求值一次（但在两种写法下当 <code>x &lt; y</code> 值为假时 <code>z</code> 都不会被求值）。</p>
<p>正式的说法是这样：如果 <em>a</em>, <em>b</em>, <em>c</em>, …, <em>y</em>, <em>z</em> 为表达式而 <em>op1</em>, <em>op2</em>, …, <em>opN</em> 为比较运算符，则 <code>a op1 b op2 c ... y opN z</code> 就等价于 <code>a op1 b and b op2 c and ... y opN z</code>，后者的不同之处只是每个表达式最多只被求值一次。</p>
<p>请注意 <code>a op1 b op2 c</code> 不意味着在 <em>a</em> 和 <em>c</em> 之间进行任何比较，因此，如 <code>x &lt; y &gt; z</code> 这样的写法是完全合法的（虽然也许不太好看）。</p>
<h3 id="6-10-1-值比较"><a href="#6-10-1-值比较" class="headerlink" title="6.10.1. 值比较"></a>6.10.1. 值比较</h3><p>运算符 <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code> 和 <code>!=</code> 将比较两个对象的值。 两个对象不要求为相同类型。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#objects" target="_blank" rel="noopener">对象、值与类型</a> 一章已说明对象都有相应的值（还有类型和标识号）。 对象值在 Python 中是一个相当抽象的概念：例如，对象值并没有一个规范的访问方法。 而且，对象值并不要求具有特定的构建方式，例如由其全部数据属性组成等。 比较运算符实现了一个特定的对象值概念。 人们可以认为这是通过实现对象比较间接地定义了对象值。</p>
<p>由于所有类型都是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 的（直接或间接）子类型，它们都从 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 继承了默认的比较行为。 类型可以通过实现 <em>丰富比较方法</em> 例如 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 来定义自己的比较行为，详情参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#customization" target="_blank" rel="noopener">基本定制</a>。</p>
<p>默认的一致性比较 (<code>==</code> 和 <code>!=</code>) 是基于对象的标识号。 因此，具有相同标识号的实例一致性比较结果为相等，具有不同标识号的实例一致性比较结果为不等。 规定这种默认行为的动机是希望所有对象都应该是自反射的 (即 <code>x is y</code> 就意味着 <code>x == y</code>)。</p>
<p>次序比较 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> 和 <code>&gt;=</code>) 默认没有提供；如果尝试比较会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 规定这种默认行为的原因是缺少与一致性比较类似的固定值。</p>
<p>按照默认的一致性比较行为，具有不同标识号的实例总是不相等，这可能不适合某些对象值需要有合理定义并有基于值的一致性的类型。 这样的类型需要定制自己的比较行为，实际上，许多内置类型都是这样做的。</p>
<p>以下列表描述了最主要内置类型的比较行为。</p>
<ul>
<li><p>内置数值类型 (<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typesnumeric" target="_blank" rel="noopener">数字类型 — int, float, complex</a>) 以及标准库类型 <a href="https://docs.python.org/zh-cn/3/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>fractions.Fraction</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> 可进行类型内部和跨类型的比较，例外限制是复数不支持次序比较。 在类型相关的限制以内，它们会按数学（算法）规则正确进行比较且不会有精度损失。</p>
<p>非数字值 <code>float(&#39;NaN&#39;)</code> 和 <code>decimal.Decimal(&#39;NaN&#39;)</code> 属于特例。 任何数字与非数字值的比较均返回假值。 还有一个反直觉的结果是非数字值不等于其自身。 例如，如果 <code>x = float(&#39;NaN&#39;)</code> 则 <code>3 &lt; x</code>, <code>x &lt; 3</code>, <code>x == x</code>, <code>x != x</code> 均为假值。 此行为是符合 IEEE 754 标准的。</p>
</li>
<li><p><code>None</code> 和 <code>NotImplemented</code> 都是单例对象。 <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> 建议单例对象的比较应当总是通过 <code>is</code> 或 <code>is not</code> 而不是等于运算符来进行。</p>
</li>
<li><p>二进制码序列 (<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 的实例) 可进行类型内部和跨类型的比较。 它们使用其元素的数字值按字典顺序进行比较。</p>
</li>
<li><p>字符串 (<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 的实例) 使用其字符的 Unicode 码位数字值 (内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#ord" target="_blank" rel="noopener"><code>ord()</code></a> 的结果) 按字典顺序进行比较。 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id19" target="_blank" rel="noopener">3</a></p>
<p>字符串和二进制码序列不能直接比较。</p>
</li>
<li><p>序列 (<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range</code></a> 的实例) 只可进行类型内部的比较，range 还有一个限制是不支持次序比较。 以上对象的跨类型一致性比较结果将是不相等，跨类型次序比较将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
<p>序列比较是按字典序对相应元素进行逐个比较。 内置容器通常设定同一对象与其自身是相等的。 这使得它们能跳过同一对象的相等性检测以提升运行效率并保持它们的内部不变性。</p>
<p>内置多项集间的字典序比较规则如下:</p>
<ul>
<li>两个多项集若要相等，它们必须为相同类型、相同长度，并且每对相应的元素都必须相等（例如，<code>[1,2] == (1,2)</code> 为假值，因为类型不同）。</li>
<li>对于支持次序比较的多项集，排序与其第一个不相等元素的排序相同（例如 <code>[1,2,x] &lt;= [1,2,y]</code> 的值与<code>x &lt;= y</code> 相同）。 如果对应元素不存在，较短的多项集排序在前（例如 <code>[1,2] &lt; [1,2,3]</code> 为真值）。</li>
</ul>
</li>
<li><p>两个映射 (<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 的实例) 若要相等，必须当且仅当它们具有相同的 (键, 值) 对。 键和值的一致性比较强制规定自反射性。</p>
<p>次序比较 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> 和 <code>&gt;=</code>) 将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
</li>
<li><p>集合 (<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset" target="_blank" rel="noopener"><code>frozenset</code></a> 的实例) 可进行类型内部和跨类型的比较。</p>
<p>它们将比较运算符定义为子集和超集检测。 这类关系没有定义完全排序（例如 <code>{1,2}</code> 和 <code>{2,3}</code> 两个集合不相等，即不为彼此的子集，也不为彼此的超集。 相应地，集合不适宜作为依赖于完全排序的函数的参数（例如如果给出一个集合列表作为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 的输入将产生未定义的结果）。</p>
<p>集合的比较强制规定其元素的自反射性。</p>
</li>
<li><p>大多数其他内置类型没有实现比较方法，因此它们会继承默认的比较行为。</p>
</li>
</ul>
<p>在可能的情况下，用户定义类在定制其比较行为时应当遵循一些一致性规则:</p>
<ul>
<li><p>相等比较应该是自反射的。 换句话说，相同的对象比较时应该相等:</p>
<blockquote>
<p><code>x is y</code> 意味着 <code>x == y</code></p>
</blockquote>
</li>
<li><p>比较应该是对称的。 换句话说，下列表达式应该有相同的结果:</p>
<blockquote>
<p><code>x == y</code> 和 <code>y == x</code></p>
<p><code>x != y</code> 和 <code>y != x</code></p>
<p><code>x &lt; y</code> 和 <code>y &gt; x</code></p>
<p><code>x &lt;= y</code> 和 <code>y &gt;= x</code></p>
</blockquote>
</li>
<li><p>比较应该是可传递的。 下列（简要的）例子显示了这一点:</p>
<blockquote>
<p><code>x &gt; y and y &gt; z</code> 意味着 <code>x &gt; z</code></p>
<p><code>x &lt; y and y &lt;= z</code> 意味着 <code>x &lt; z</code></p>
</blockquote>
</li>
<li><p>反向比较应该导致布尔值取反。 换句话说，下列表达式应该有相同的结果:</p>
<blockquote>
<p><code>x == y</code> 和 <code>not x != y</code></p>
<p><code>x &lt; y</code> 和 <code>not x &gt;= y</code> (对于完全排序)</p>
<p><code>x &gt; y</code> 和 <code>not x &lt;= y</code> (对于完全排序)</p>
</blockquote>
<p>最后两个表达式适用于完全排序的多项集（即序列而非集合或映射）。 另请参阅 <a href="https://docs.python.org/zh-cn/3/library/functools.html#functools.total_ordering" target="_blank" rel="noopener"><code>total_ordering()</code></a> 装饰器。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 的结果应该与是否相等一致。 相等的对象应该或者具有相同的哈希值，或者标记为不可哈希。</p>
</li>
</ul>
<p>Python 并不强制要求这些一致性规则。 实际上，非数字值就是一个不遵循这些规则的例子。</p>
<h3 id="6-10-2-成员检测运算"><a href="#6-10-2-成员检测运算" class="headerlink" title="6.10.2. 成员检测运算"></a>6.10.2. 成员检测运算</h3><p>运算符 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#not-in" target="_blank" rel="noopener"><code>not in</code></a> 用于成员检测。 如果 <em>x</em> 是 <em>s</em> 的成员则 <code>x in s</code> 求值为 <code>True</code>，否则为 <code>False</code>。 <code>x not in s</code> 返回 <code>x in s</code> 取反后的值。 所有内置序列和集合类型以及字典都支持此运算，对于字典来说 <code>in</code> 检测其是否有给定的键。 对于 list, tuple, set, frozenset, dict 或 collections.deque 这样的容器类型，表达式 <code>x in y</code> 等价于 <code>any(x is e or x == e for e in y)</code>。</p>
<p>对于字符串和字节串类型来说，当且仅当 <em>x</em> 是 <em>y</em> 的子串时 <code>x in y</code> 为 <code>True</code>。 一个等价的检测是 <code>y.find(x) != -1</code>。 空字符串总是被视为任何其他字符串的子串，因此 <code>&quot;&quot; in &quot;abc&quot;</code> 将返回 <code>True</code>。</p>
<p>对于定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a> 方法的用户自定义类来说，如果 <code>y.__contains__(x)</code> 返回真值则 <code>x in y</code> 返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>对于未定义 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a> 但定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 的用户自定义类来说，如果在对 <code>y</code> 进行迭代时产生了值 <code>z</code> 使得表达式 <code>x is z or x == z</code> 为真，则 <code>x in y</code> 为 <code>True</code>。 如果在迭代期间引发了异常，则等同于 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 引发了该异常。</p>
<p>最后将会尝试旧式的迭代协议：如果一个类定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a>，则当且仅当存在非负整数索引号 <em>i</em> 使得 <code>x is y[i] or x == y[i]</code> 并且没有更小的索引号引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 异常时 <code>x in y</code> 为 <code>True</code>。 （如果引发了任何其他异常，则等同于 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 引发了该异常）。</p>
<p>运算符 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#not-in" target="_blank" rel="noopener"><code>not in</code></a> 被定义为具有与 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 相反的逻辑值。</p>
<h3 id="6-10-3-标识号比较"><a href="#6-10-3-标识号比较" class="headerlink" title="6.10.3. 标识号比较"></a>6.10.3. 标识号比较</h3><p>运算符 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#is" target="_blank" rel="noopener"><code>is</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#is-not" target="_blank" rel="noopener"><code>is not</code></a> 用于检测对象的标识号：当且仅当 <em>x</em> 和 <em>y</em> 是同一对象时 <code>x is y</code> 为真。 一个对象的标识号可使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#id" target="_blank" rel="noopener"><code>id()</code></a> 函数来确定。 <code>x is not y</code> 会产生相反的逻辑值。 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id20" target="_blank" rel="noopener">4</a></p>
<h2 id="6-11-布尔运算"><a href="#6-11-布尔运算" class="headerlink" title="6.11. 布尔运算"></a>6.11. 布尔运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">or_test  ::&#x3D;  and_test | or_test &quot;or&quot; and_test</span><br><span class="line">and_test ::&#x3D;  not_test | and_test &quot;and&quot; not_test</span><br><span class="line">not_test ::&#x3D;  comparison | &quot;not&quot; not_test</span><br></pre></td></tr></table></figure>

<p>在执行布尔运算的情况下，或是当表达式被用于流程控制语句时，以下值会被解析为假值: <code>False</code>, <code>None</code>, 所有类型的数字零，以及空字符串和空容器（包括字符串、元组、列表、字典、集合与冻结集合）。 所有其他值都会被解析为真值。 用户自定义对象可通过提供 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a> 方法来定制其逻辑值。</p>
<p>运算符 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#not" target="_blank" rel="noopener"><code>not</code></a> 将在其参数为假值时产生 <code>True</code>，否则产生 <code>False</code>。</p>
<p>表达式 <code>x and y</code> 首先对 <em>x</em> 求值；如果 <em>x</em> 为假则返回该值；否则对 <em>y</em> 求值并返回其结果值。</p>
<p>表达式 <code>x or y</code> 首先对 <em>x</em> 求值；如果 <em>x</em> 为真则返回该值；否则对 <em>y</em> 求值并返回其结果值。</p>
<p>请注意 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#and" target="_blank" rel="noopener"><code>and</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#or" target="_blank" rel="noopener"><code>or</code></a> 都不限制其返回的值和类型必须为 <code>False</code> 和 <code>True</code>，而是返回最终求值的参数。 此行为是有必要的，例如假设 <code>s</code> 为一个当其为空时应被替换为某个默认值的字符串，表达式 <code>s or &#39;foo&#39;</code> 将产生希望的值。 由于 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#not" target="_blank" rel="noopener"><code>not</code></a> 必须创建一个新值，不论其参数为何种类型它都会返回一个布尔值（例如，<code>not &#39;foo&#39;</code> 结果为 <code>False</code> 而非 <code>&#39;&#39;</code>。）</p>
<h2 id="6-12-赋值表达式"><a href="#6-12-赋值表达式" class="headerlink" title="6.12. 赋值表达式"></a>6.12. 赋值表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assignment_expression ::&#x3D;  [identifier &quot;:&#x3D;&quot;] expression</span><br></pre></td></tr></table></figure>

<p>请参阅 <a href="https://www.python.org/dev/peps/pep-0572" target="_blank" rel="noopener"><strong>PEP 572</strong></a> 了解有关赋值表达式的详情。</p>
<h2 id="6-13-条件表达式"><a href="#6-13-条件表达式" class="headerlink" title="6.13. 条件表达式"></a>6.13. 条件表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conditional_expression ::&#x3D;  or_test [&quot;if&quot; or_test &quot;else&quot; expression]</span><br><span class="line">expression             ::&#x3D;  conditional_expression | lambda_expr</span><br><span class="line">expression_nocond      ::&#x3D;  or_test | lambda_expr_nocond</span><br></pre></td></tr></table></figure>

<p>条件表达式（有时称为“三元运算符”）在所有 Python 运算中具有最低的优先级。</p>
<p>表达式 <code>x if C else y</code> 首先是对条件 <em>C</em> 而非 <em>x</em> 求值。 如果 <em>C</em> 为真，<em>x</em> 将被求值并返回其值；否则将对 <em>y</em> 求值并返回其值。</p>
<p>请参阅 <a href="https://www.python.org/dev/peps/pep-0308" target="_blank" rel="noopener"><strong>PEP 308</strong></a> 了解有关条件表达式的详情。</p>
<h2 id="6-14-lambda-表达式"><a href="#6-14-lambda-表达式" class="headerlink" title="6.14. lambda 表达式"></a>6.14. lambda 表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda_expr        ::&#x3D;  &quot;lambda&quot; [parameter_list] &quot;:&quot; expression</span><br><span class="line">lambda_expr_nocond ::&#x3D;  &quot;lambda&quot; [parameter_list] &quot;:&quot; expression_nocond</span><br></pre></td></tr></table></figure>

<p>lambda 表达式（有时称为 lambda 构型）被用于创建匿名函数。 表达式 <code>lambda parameters: expression</code> 会产生一个函数对象 。 该未命名对象的行为类似于用以下方式定义的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def &lt;lambda&gt;(parameters):</span><br><span class="line">    return expression</span><br></pre></td></tr></table></figure>

<p>请参阅 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" target="_blank" rel="noopener">函数定义</a> 了解有关参数列表的句法。 请注意通过 lambda 表达式创建的函数不能包含语句或标注。</p>
<h2 id="6-15-表达式列表"><a href="#6-15-表达式列表" class="headerlink" title="6.15. 表达式列表"></a>6.15. 表达式列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression_list    ::&#x3D;  expression (&quot;,&quot; expression)* [&quot;,&quot;]</span><br><span class="line">starred_list       ::&#x3D;  starred_item (&quot;,&quot; starred_item)* [&quot;,&quot;]</span><br><span class="line">starred_expression ::&#x3D;  expression | (starred_item &quot;,&quot;)* [starred_item]</span><br><span class="line">starred_item       ::&#x3D;  assignment_expression | &quot;*&quot; or_expr</span><br></pre></td></tr></table></figure>

<p>除了作为列表或集合显示的一部分，包含至少一个逗号的表达式列表将生成一个元组。 元组的长度就是列表中表达式的数量。 表达式将从左至右被求值。</p>
<p>一个星号 <code>*</code> 表示 <em>可迭代拆包</em>。 其操作数必须为一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a>。 该可迭代对象将被拆解为迭代项的序列，并被包含于在拆包位置上新建的元组、列表或集合之中。</p>
<p><em>3.5 新版功能:</em> 表达式列表中的可迭代对象拆包，最初由 <a href="https://www.python.org/dev/peps/pep-0448" target="_blank" rel="noopener"><strong>PEP 448</strong></a> 提出。</p>
<p>末尾的逗号仅在创建单独元组 (或称 <em>单例</em>) 时需要；在所有其他情况下都是可选项。 没有末尾逗号的单独表达式不会创建一个元组，而是产生该表达式的值。 （要创建一个空元组，应使用一对内容为空的圆括号: <code>()</code>。）</p>
<h2 id="6-16-求值顺序"><a href="#6-16-求值顺序" class="headerlink" title="6.16. 求值顺序"></a>6.16. 求值顺序</h2><p>Python 按从左至右的顺序对表达式求值。 但注意在对赋值操作求值时，右侧会先于左侧被求值。</p>
<p>在以下几行中，表达式将按其后缀的算术优先顺序被求值。:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expr1, expr2, expr3, expr4</span><br><span class="line">(expr1, expr2, expr3, expr4)</span><br><span class="line">&#123;expr1: expr2, expr3: expr4&#125;</span><br><span class="line">expr1 + expr2 * (expr3 - expr4)</span><br><span class="line">expr1(expr2, expr3, *expr4, **expr5)</span><br><span class="line">expr3, expr4 &#x3D; expr1, expr2</span><br></pre></td></tr></table></figure>



<h2 id="6-17-运算符优先级"><a href="#6-17-运算符优先级" class="headerlink" title="6.17. 运算符优先级"></a>6.17. 运算符优先级</h2><p>下表对 Python 中运算符的优先顺序进行了总结，从最低优先级（最后绑定）到最高优先级（最先绑定）。 相同单元格内的运算符具有相同优先级。 除非句法显式地给出，否则运算符均指二元运算。 相同单元格内的运算符均从左至右分组（除了幂运算是从右至左分组）。</p>
<p>请注意比较、成员检测和标识号检测均为相同优先级，并具有如 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#comparisons" target="_blank" rel="noopener">比较运算</a> 一节所描述的从左至右串连特性。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>:=</code></td>
<td align="left">赋值表达式</td>
</tr>
<tr>
<td align="left"><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a></td>
<td align="left">lambda 表达式</td>
</tr>
<tr>
<td align="left"><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#if-expr" target="_blank" rel="noopener"><code>if</code></a> – <code>else</code></td>
<td align="left">条件表达式</td>
</tr>
<tr>
<td align="left"><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#or" target="_blank" rel="noopener"><code>or</code></a></td>
<td align="left">布尔逻辑或 OR</td>
</tr>
<tr>
<td align="left"><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#and" target="_blank" rel="noopener"><code>and</code></a></td>
<td align="left">布尔逻辑与 AND</td>
</tr>
<tr>
<td align="left"><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#not" target="_blank" rel="noopener"><code>not</code></a> <code>x</code></td>
<td align="left">布尔逻辑非 NOT</td>
</tr>
<tr>
<td align="left"><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#not-in" target="_blank" rel="noopener"><code>not in</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#is" target="_blank" rel="noopener"><code>is</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#is-not" target="_blank" rel="noopener"><code>is not</code></a>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code></td>
<td align="left">比较运算，包括成员检测和标识号检测</td>
</tr>
<tr>
<td align="left">`</td>
<td align="left">`</td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="left">按位异或 XOR</td>
</tr>
<tr>
<td align="left"><code>&amp;</code></td>
<td align="left">按位与 AND</td>
</tr>
<tr>
<td align="left"><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td align="left">移位</td>
</tr>
<tr>
<td align="left"><code>+</code>, <code>-</code></td>
<td align="left">加和减</td>
</tr>
<tr>
<td align="left"><code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
<td align="left">乘，矩阵乘，除，整除，取余 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id21" target="_blank" rel="noopener">5</a></td>
</tr>
<tr>
<td align="left"><code>+x</code>, <code>-x</code>, <code>~x</code></td>
<td align="left">正，负，按位非 NOT</td>
</tr>
<tr>
<td align="left"><code>**</code></td>
<td align="left">乘方 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id22" target="_blank" rel="noopener">6</a></td>
</tr>
<tr>
<td align="left"><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> <code>x</code></td>
<td align="left">await 表达式</td>
</tr>
<tr>
<td align="left"><code>x[index]</code>, <code>x[index:index]</code>, <code>x(arguments...)</code>, <code>x.attribute</code></td>
<td align="left">抽取，切片，调用，属性引用</td>
</tr>
<tr>
<td align="left"><code>(expressions...)</code>,<code>[expressions...]</code>, <code>{key: value...}</code>, <code>{expressions...}</code></td>
<td align="left">绑定或加圆括号的表达式，列表显示，字典显示，集合显示</td>
</tr>
</tbody></table>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id9" target="_blank" rel="noopener">1</a></p>
<p>虽然 <code>abs(x%y) &lt; abs(y)</code> 在数学中必为真，但对于浮点数而言，由于舍入的存在，其在数值上未必为真。 例如，假设在某个平台上的 Python 浮点数为一个 IEEE 754 双精度数值，为了使 <code>-1e-100 % 1e100</code> 具有与 <code>1e100</code> 相同的正负性，计算结果将是 <code>-1e-100 + 1e100</code>，这在数值上正好等于 <code>1e100</code>。 函数 <a href="https://docs.python.org/zh-cn/3/library/math.html#math.fmod" target="_blank" rel="noopener"><code>math.fmod()</code></a> 返回的结果则会具有与第一个参数相同的正负性，因此在这种情况下将返回 <code>-1e-100</code>。 何种方式更适宜取决于具体的应用。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id10" target="_blank" rel="noopener">2</a></p>
<p>如果 x 恰好非常接近于 y 的整数倍，则由于舍入的存在 <code>x//y</code> 可能会比 <code>(x-x%y)//y</code> 大。 在这种情况下，Python 会返回后一个结果，以便保持令 <code>divmod(x,y)[0] * y + x % y</code> 尽量接近 <code>x</code>.</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id12" target="_blank" rel="noopener">3</a></p>
<p>Unicode 标准明确区分 <em>码位</em> (例如 U+0041) 和 <em>抽象字符</em> (例如 “大写拉丁字母 A”)。 虽然 Unicode 中的大多数抽象字符都只用一个码位来代表，但也存在一些抽象字符可使用由多个码位组成的序列来表示。 例如，抽象字符 “带有下加符的大写拉丁字母 C” 可以用 U+00C7 码位上的单个 <em>预设字符</em> 来表示，也可以用一个 U+0043 码位上的 <em>基础字符</em> (大写拉丁字母 C) 加上一个 U+0327 码位上的 <em>组合字符</em> (组合下加符) 组成的序列来表示。对于字符串，比较运算符会按 Unicode 码位级别进行比较。 这可能会违反人类的直觉。 例如，<code>&quot;\u00C7&quot; == &quot;\u0043\u0327&quot;</code> 为 <code>False</code>，虽然两个字符串都代表同一个抽象字符 “带有下加符的大写拉丁字母 C”。要按抽象字符级别（即对人类来说更直观的方式）对字符串进行比较，应使用 <a href="https://docs.python.org/zh-cn/3/library/unicodedata.html#unicodedata.normalize" target="_blank" rel="noopener"><code>unicodedata.normalize()</code></a>。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id13" target="_blank" rel="noopener">4</a></p>
<p>由于存在自动垃圾收集、空闲列表以及描述器的动态特性，你可能会注意到在特定情况下使用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#is" target="_blank" rel="noopener"><code>is</code></a> 运算符会出现看似不正常的行为，例如涉及到实例方法或常量之间的比较时就是如此。 更多信息请查看有关它们的文档。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id15" target="_blank" rel="noopener">5</a></p>
<p><code>%</code> 运算符也被用于字符串格式化；在此场合下会使用同样的优先级。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/expressions.html#id16" target="_blank" rel="noopener">6</a></p>
<p>幂运算符 <code>**</code> 绑定的紧密程度低于在其右侧的算术或按位一元运算符，也就是说 <code>2**-1</code> 为 <code>0.5</code>。</p>
</li>
</ul>
<h1 id="7-简单语句"><a href="#7-简单语句" class="headerlink" title="7. 简单语句"></a>7. 简单语句</h1><p>简单语句由一个单独的逻辑行构成。 多条简单语句可以存在于同一行内并以分号分隔。 简单语句的句法为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">simple_stmt ::&#x3D;  expression_stmt</span><br><span class="line">                 | assert_stmt</span><br><span class="line">                 | assignment_stmt</span><br><span class="line">                 | augmented_assignment_stmt</span><br><span class="line">                 | annotated_assignment_stmt</span><br><span class="line">                 | pass_stmt</span><br><span class="line">                 | del_stmt</span><br><span class="line">                 | return_stmt</span><br><span class="line">                 | yield_stmt</span><br><span class="line">                 | raise_stmt</span><br><span class="line">                 | break_stmt</span><br><span class="line">                 | continue_stmt</span><br><span class="line">                 | import_stmt</span><br><span class="line">                 | future_stmt</span><br><span class="line">                 | global_stmt</span><br><span class="line">                 | nonlocal_stmt</span><br></pre></td></tr></table></figure>



<h2 id="7-1-表达式语句"><a href="#7-1-表达式语句" class="headerlink" title="7.1. 表达式语句"></a>7.1. 表达式语句</h2><p>表达式语句用于计算和写入值（大多是在交互模式下），或者（通常情况）调用一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 <code>None</code>)。 表达式语句的其他使用方式也是允许且有特定用处的。 表达式语句的句法为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression_stmt ::&#x3D;  starred_expression</span><br></pre></td></tr></table></figure>

<p>表达式语句会对指定的表达式列表（也可能为单一表达式）进行求值。</p>
<p>在交互模式下，如果结果值不为 <code>None</code>，它会通过内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数转换为一个字符串，该结果字符串将以单独一行的形式写入标准输出（例外情况是如果结果为 <code>None</code>，则该过程调用不产生任何输出。）</p>
<h2 id="7-2-赋值语句"><a href="#7-2-赋值语句" class="headerlink" title="7.2. 赋值语句"></a>7.2. 赋值语句</h2><p>赋值语句用于将名称（重）绑定到特定值，以及修改属性或可变对象的成员项:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">assignment_stmt ::&#x3D;  (target_list &quot;&#x3D;&quot;)+ (starred_expression | yield_expression)</span><br><span class="line">target_list     ::&#x3D;  target (&quot;,&quot; target)* [&quot;,&quot;]</span><br><span class="line">target          ::&#x3D;  identifier</span><br><span class="line">                     | &quot;(&quot; [target_list] &quot;)&quot;</span><br><span class="line">                     | &quot;[&quot; [target_list] &quot;]&quot;</span><br><span class="line">                     | attributeref</span><br><span class="line">                     | subscription</span><br><span class="line">                     | slicing</span><br><span class="line">                     | &quot;*&quot; target</span><br></pre></td></tr></table></figure>

<p>(请参阅 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#primaries" target="_blank" rel="noopener">原型</a> 一节了解 <em>属性引用</em>, <em>抽取</em> 和 <em>切片</em> 的句法定义。)</p>
<p>赋值语句会对指定的表达式列表进行求值（注意这可能为单一表达式或是由逗号分隔的列表，后者将产生一个元组）并将单一结果对象从左至右逐个赋值给目标列表。</p>
<p>赋值是根据目标（列表）的格式递归地定义的。 当目标为一个可变对象（属性引用、抽取或切片）的组成部分时，该可变对象必须最终执行赋值并决定其有效性，如果赋值操作不可接受也可能引发异常。 各种类型可用的规则和引发的异常通过对象类型的定义给出（参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#types" target="_blank" rel="noopener">标准类型层级结构</a> 一节）。</p>
<p>对象赋值的目标对象可以包含于圆括号或方括号内，具体操作按以下方式递归地定义。</p>
<ul>
<li>如果目标列表为后面不带逗号、可以包含于圆括号内的单一目标，则将对象赋值给该目标。</li>
<li>否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋值给对应的目标。<ul>
<li>如果目标列表包含一个带有星号前缀的目标，这称为“加星”目标：则该对象至少必须为与目标列表项数减一相同项数的可迭代对象。 该可迭代对象前面的项将按从左至右的顺序被赋值给加星目标之前的目标。 该可迭代对象末尾的项将被赋值给加星目标之后的目标。 然后该可迭代对象中剩余项的列表将被赋值给加星目标（该列表可以为空）。</li>
<li>否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋值给对应的目标。</li>
</ul>
</li>
</ul>
<p>对象赋值给单个目标的操作按以下方式递归地定义。</p>
<ul>
<li><p>如果目标为标识符（名称）:</p>
<ul>
<li>如果该名称未出现于当前代码块的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句中：该名称将被绑定到当前局部命名空间的对象。</li>
<li>否则：该名称将被分别绑定到全局命名空间或由 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 所确定的外层命名空间的对象。</li>
</ul>
<p>如果该名称已经被绑定则将被重新绑定。 这可能导致之前被绑定到该名称的对象的引用计数变为零，造成该对象进入释放过程并调用其析构器（如果存在）。</p>
</li>
<li><p>如果该对象为属性引用：引用中的原型表达式会被求值。 它应该产生一个具有可赋值属性的对象；否则将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 该对象会被要求将可赋值对象赋值给指定的属性；如果它无法执行赋值，则会引发异常 (通常应为 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 但并不强制要求)。</p>
<p>注意：如果该对象为类实例并且属性引用在赋值运算符的两侧都出现，则右侧表达式 <code>a.x</code> 可以访问实例属性或（如果实例属性不存在）类属性。 左侧目标 <code>a.x</code> 将总是设定为实例属性，并在必要时创建该实例属性。 因此 <code>a.x</code> 的两次出现不一定指向相同的属性：如果右侧表达式指向一个类属性，则左侧会创建一个新的实例属性作为赋值的目标:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Cls:</span><br><span class="line">    x &#x3D; 3             # class variable</span><br><span class="line">inst &#x3D; Cls()</span><br><span class="line">inst.x &#x3D; inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3</span><br></pre></td></tr></table></figure>

<p>此描述不一定作用于描述器属性，例如通过 <a href="https://docs.python.org/zh-cn/3/library/functions.html#property" target="_blank" rel="noopener"><code>property()</code></a> 创建的特征属性。</p>
</li>
<li><p>如果目标为一个抽取项：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）或一个映射对象（例如字典）。 接下来，该抽取表达式会被求值。</p>
<p>如果原型为一个可变序列对象（例如列表），抽取应产生一个整数。 如其为负值，则再加上序列长度。 结果值必须为一个小于序列长度的非负整数，序列将把被赋值对象赋值给该整数指定索引号的项。 如果索引超出范围，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> (给被抽取序列赋值不能向列表添加新项)。</p>
<p>如果原型为一个映射对象（例如字典），抽取必须具有与该映射的键类型相兼容的类型，然后映射中会创建一个将抽取映射到被赋值对象的键/值对。 这可以是替换一个现有键/值对并保持相同键值，也可以是插入一个新键/值对（如果具有相同值的键不存在）。</p>
<p>对于用户定义对象，会调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a> 方法并附带适当的参数。</p>
</li>
<li><p>如果目标为一个切片：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）。 被赋值对象应当是一个相同类型的序列对象。 接下来，下界与上界表达式如果存在的话将被求值；默认值分别为零和序列长度。 上下边界值应当为整数。 如果某一边界为负值，则会加上序列长度。 求出的边界会被裁剪至介于零和序列长度的开区间中。 最后，将要求序列对象以被赋值序列的项替换该切片。 切片的长度可能与被赋值序列的长度不同，这会在目标序列允许的情况下改变目标序列的长度。</p>
</li>
</ul>
<p><strong>CPython implementation detail:</strong> 在当前实现中，目标的句法被当作与表达式的句法相同，无效的句法会在代码生成阶段被拒绝，导致不太详细的错误信息。</p>
<p>虽然赋值的定义意味着左手边与右手边的重叠是“同时”进行的（例如 <code>a, b = b, a</code> 会交换两个变量的值），但在赋值给变量的多项集 <em>之内</em> 的重叠是从左至右进行的，这有时会令人混淆。 例如，以下程序将会打印出 <code>[0, 2]</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; [0, 1]</span><br><span class="line">i &#x3D; 0</span><br><span class="line">i, x[i] &#x3D; 1, 2         # i is updated, then x[i] is updated</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-3132" target="_blank" rel="noopener"><strong>PEP 3132</strong></a> - 扩展的可迭代对象拆包</p>
<p>对 <code>*target</code> 特性的规范说明。</p>
</li>
</ul>
<h3 id="7-2-1-增强赋值语句"><a href="#7-2-1-增强赋值语句" class="headerlink" title="7.2.1. 增强赋值语句"></a>7.2.1. 增强赋值语句</h3><p>增强赋值语句就是在单个语句中将二元运算和赋值语句合为一体:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">augmented_assignment_stmt ::&#x3D;  augtarget augop (expression_list | yield_expression)</span><br><span class="line">augtarget                 ::&#x3D;  identifier | attributeref | subscription | slicing</span><br><span class="line">augop                     ::&#x3D;  &quot;+&#x3D;&quot; | &quot;-&#x3D;&quot; | &quot;*&#x3D;&quot; | &quot;@&#x3D;&quot; | &quot;&#x2F;&#x3D;&quot; | &quot;&#x2F;&#x2F;&#x3D;&quot; | &quot;%&#x3D;&quot; | &quot;**&#x3D;&quot;</span><br><span class="line">                               | &quot;&gt;&gt;&#x3D;&quot; | &quot;&lt;&lt;&#x3D;&quot; | &quot;&amp;&#x3D;&quot; | &quot;^&#x3D;&quot; | &quot;|&#x3D;&quot;</span><br></pre></td></tr></table></figure>

<p>（请参阅 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#primaries" target="_blank" rel="noopener">原型</a> 一节了解最后三种符号的句法定义。）</p>
<p>增强赋值语句将对目标和表达式列表求值（与普通赋值语句不同的是，前者不能为可迭代对象拆包），对两个操作数相应类型的赋值执行指定的二元运算，并将结果赋值给原始目标。 目标仅会被求值一次。</p>
<p>增强赋值语句例如 <code>x += 1</code> 可以改写为 <code>x = x + 1</code> 获得类似但并非完全等价的效果。 在增强赋值的版本中，<code>x</code> 仅会被求值一次。 而且，在可能的情况下，实际的运算是 <em>原地</em> 执行的，也就是说并不是创建一个新对象并将其赋值给目标，而是直接修改原对象。</p>
<p>不同于普通赋值，增强赋值会在对右手边求值 <em>之前</em> 对左手边求值。 例如，<code>a[i] += f(x)</code> 首先查找 <code>a[i]</code>，然后对 <code>f(x)</code> 求值并执行加法操作，最后将结果写回到 <code>a[i]</code>。</p>
<p>除了在单个语句中赋值给元组和多个目标的例外情况，增强赋值语句的赋值操作处理方式与普通赋值相同。 类似地，除了可能存在 <em>原地</em> 操作行为的例外情况，增强赋值语句执行的二元运算也与普通二元运算相同。</p>
<p>对于属性引用类目标，针对常规赋值的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#attr-target-note" target="_blank" rel="noopener">关于类和实例属性的警告</a> 也同样适用。</p>
<h3 id="7-2-2-带标注的赋值语句"><a href="#7-2-2-带标注的赋值语句" class="headerlink" title="7.2.2. 带标注的赋值语句"></a>7.2.2. 带标注的赋值语句</h3><p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-variable-annotation" target="_blank" rel="noopener">标注</a> 赋值就是在单个语句中将变量或属性标注和可选的赋值语句合为一体:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">annotated_assignment_stmt ::&#x3D;  augtarget &quot;:&quot; expression</span><br><span class="line">                               [&quot;&#x3D;&quot; (starred_expression | yield_expression)]</span><br></pre></td></tr></table></figure>

<p>与普通 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#assignment" target="_blank" rel="noopener">赋值语句</a> 的差别在于仅允许单个目标。</p>
<p>对于将简单名称作为赋值目标的情况，如果是在类或模块作用域中，标注会被求值并存入一个特殊的类或模块属性 <code>__annotations__</code> 中，这是一个将变量名称（如为私有会被移除）映射到被求值标注的字典。 此属性为可写并且在类或模块体开始执行时如果静态地发现标注就会自动创建。</p>
<p>对于将表达式作为赋值目标的情况，如果是在类或模块作用域中，标注会被求值，但不会保存。</p>
<p>如果一个名称在函数作用域内被标注，则该名称为该作用域的局部变量。 标注绝不会在函数作用域内被求值和保存。</p>
<p>如果存在右手边，带标注的赋值会在对标注求值之前（如果适用）执行实际的赋值。 如果用作表达式目标的右手边不存在，则解释器会对目标求值，但最后的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 调用除外。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> - 变量标注的语法</p>
<p>该提议增加了标注变量（也包括类变量和实例变量）类型的语法，而不再是通过注释来进行表达。</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> - 类型提示</p>
<p>该提议增加了 <a href="https://docs.python.org/zh-cn/3/library/typing.html#module-typing" target="_blank" rel="noopener"><code>typing</code></a> 模块以便为类型标注提供标准句法，可被静态分析工具和 IDE 所使用。</p>
</li>
</ul>
<p><em>在 3.8 版更改:</em> 现在带有标注的赋值允许在右边以同样的表达式作为常规赋值。 之前，某些表达式（例如未加圆括号的元组表达式）会导致语法错误。</p>
<h2 id="7-3-assert-语句"><a href="#7-3-assert-语句" class="headerlink" title="7.3. assert 语句"></a>7.3. <code>assert</code> 语句</h2><p>assert 语句是在程序中插入调试性断言的简便方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert_stmt ::&#x3D;  &quot;assert&quot; expression [&quot;,&quot; expression]</span><br></pre></td></tr></table></figure>

<p>简单形式 <code>assert expression</code> 等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __debug__:</span><br><span class="line">    if not expression: raise AssertionError</span><br></pre></td></tr></table></figure>

<p>扩展形式 <code>assert expression1, expression2</code> 等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __debug__:</span><br><span class="line">    if not expression1: raise AssertionError(expression2)</span><br></pre></td></tr></table></figure>

<p>以上等价形式假定 <a href="https://docs.python.org/zh-cn/3/library/constants.html#__debug__" target="_blank" rel="noopener"><code>__debug__</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#AssertionError" target="_blank" rel="noopener"><code>AssertionError</code></a> 指向具有指定名称的内置变量。 在当前实现中，内置变量 <a href="https://docs.python.org/zh-cn/3/library/constants.html#__debug__" target="_blank" rel="noopener"><code>__debug__</code></a> 在正常情况下为 <code>True</code>，在请求优化时为 <code>False</code> (对应命令行选项为 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-o" target="_blank" rel="noopener"><code>-O</code></a>)。 如果在编译时请求优化，当前代码生成器不会为 assert 语句发出任何代码。 请注意不必在错误信息中包含失败表达式的源代码；它会被作为栈追踪的一部分被显示。</p>
<p>赋值给 <a href="https://docs.python.org/zh-cn/3/library/constants.html#__debug__" target="_blank" rel="noopener"><code>__debug__</code></a> 是非法的。 该内置变量的值会在解释器启动时确定。</p>
<h2 id="7-4-pass-语句"><a href="#7-4-pass-语句" class="headerlink" title="7.4. pass 语句"></a>7.4. <code>pass</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pass_stmt ::&#x3D;  &quot;pass&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#pass" target="_blank" rel="noopener"><code>pass</code></a> 是一个空操作 — 当它被执行时，什么都不发生。 它适合当语法上需要一条语句但并不需要执行任何代码时用来临时占位，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def f(arg): pass    # a function that does nothing (yet)</span><br><span class="line"></span><br><span class="line">class C: pass       # a class with no methods (yet)</span><br></pre></td></tr></table></figure>



<h2 id="7-5-del-语句"><a href="#7-5-del-语句" class="headerlink" title="7.5. del 语句"></a>7.5. <code>del</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del_stmt ::&#x3D;  &quot;del&quot; target_list</span><br></pre></td></tr></table></figure>

<p>删除是递归定义的，与赋值的定义方式非常类似。 此处不再详细说明，只给出一些提示。</p>
<p>目标列表的删除将从左至右递归地删除每一个目标。</p>
<p>名称的删除将从局部或全局命名空间中移除该名称的绑定，具体作用域的确定是看该名称是否有在同一代码块的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句中出现。 如果该名称未被绑定，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a>。</p>
<p>属性引用、抽取和切片的删除会被传递给相应的原型对象；删除一个切片基本等价于赋值为一个右侧类型的空切片（但即便这一点也是由切片对象决定的）。</p>
<p><em>在 3.2 版更改:</em> 在之前版本中，如果一个名称作为被嵌套代码块中的自由变量出现，则将其从局部命名空间中删除是非法的。</p>
<h2 id="7-6-return-语句"><a href="#7-6-return-语句" class="headerlink" title="7.6. return 语句"></a>7.6. <code>return</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_stmt ::&#x3D;  &quot;return&quot; [expression_list]</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 在语法上只会出现于函数定义所嵌套的代码，不会出现于类定义所嵌套的代码。</p>
<p>如果提供了表达式列表，它将被求值，否则以 <code>None</code> 替代。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 会离开当前函数调用，并以表达式列表 (或 <code>None</code>) 作为返回值。</p>
<p>当 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 将控制流传出一个带有 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句时，该 <code>finally</code> 子句会先被执行然后再真正离开该函数。</p>
<p>在一个生成器函数中，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句表示生成器已完成并将导致 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 被引发。 返回值（如果有的话）会被当作一个参数用来构建 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 并成为 <code>StopIteration.value</code> 属性。</p>
<p>在一个异步生成器函数中，一个空的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句表示异步生成器已完成并将导致 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a> 被引发。 一个非空的 <code>return</code> 语句在异步生成器函数中会导致语法错误。</p>
<h2 id="7-7-yield-语句"><a href="#7-7-yield-语句" class="headerlink" title="7.7. yield 语句"></a>7.7. <code>yield</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yield_stmt ::&#x3D;  yield_expression</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 语句在语义上等同于 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#yieldexpr" target="_blank" rel="noopener">yield 表达式</a>。 yield 语句可用来省略在使用等效的 yield 表达式语句时所必须的圆括号。 例如，以下 yield 语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yield &lt;expr&gt;</span><br><span class="line">yield from &lt;expr&gt;</span><br></pre></td></tr></table></figure>

<p>等同于以下 yield 表达式语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(yield &lt;expr&gt;)</span><br><span class="line">(yield from &lt;expr&gt;)</span><br></pre></td></tr></table></figure>

<p>yield 表达式和语句仅在定义 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 函数时使用，并且仅被用于生成器函数的函数体内部。 在函数定义中使用 yield 就足以使得该定义创建的是生成器函数而非普通函数。</p>
<p>有关 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 语义的完整细节请参看 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#yieldexpr" target="_blank" rel="noopener">yield 表达式</a> 一节。</p>
<h2 id="7-8-raise-语句"><a href="#7-8-raise-语句" class="headerlink" title="7.8. raise 语句"></a>7.8. <code>raise</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise_stmt ::&#x3D;  &quot;raise&quot; [expression [&quot;from&quot; expression]]</span><br></pre></td></tr></table></figure>

<p>如果不带表达式，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 会重新引发当前作用域内最后一个激活的异常。 如果当前作用域内没有激活的异常，将会引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 来提示错误。</p>
<p>否则的话，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 会将第一个表达式求值为异常对象。 它必须为 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 的子类或实例。 如果它是一个类，当需要时会通过不带参数地实例化该类来获得异常的实例。</p>
<p>异常的 <em>类型</em> 为异常实例的类，<em>值</em> 为实例本身。</p>
<p>当异常被引发时通常会自动创建一个回溯对象并将其关联到可写的 <code>__traceback__</code> 属性。 你可以创建一个异常并同时使用 <code>with_traceback()</code> 异常方法（该方法将返回同一异常实例，并将回溯对象设为其参数）设置自己的回溯，就像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise Exception(&quot;foo occurred&quot;).with_traceback(tracebackobj)</span><br></pre></td></tr></table></figure>

<p><code>from</code> 子句用于异常串连：如果有该子句，则第二个 <em>表达式</em> 必须为另一个异常或实例，它将作为可写的 <code>__cause__</code> 属性被关联到所引发的异常。 如果引发的异常未被处理，两个异常都将被打印出来:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     print(1 &#x2F; 0)</span><br><span class="line">... except Exception as exc:</span><br><span class="line">...     raise RuntimeError(&quot;Something bad happened&quot;) from exc</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in &lt;module&gt;</span><br><span class="line">RuntimeError: Something bad happened</span><br></pre></td></tr></table></figure>

<p>如果一个异常在异常处理器或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> clause: 中被引发，类似的机制会隐式地发挥作用，之前的异常将被关联到新异常的 <code>__context__</code> 属性:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     print(1 &#x2F; 0)</span><br><span class="line">... except:</span><br><span class="line">...     raise RuntimeError(&quot;Something bad happened&quot;)</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in &lt;module&gt;</span><br><span class="line">RuntimeError: Something bad happened</span><br></pre></td></tr></table></figure>

<p>异常串连可通过在 <code>from</code> 子句中指定 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 来显式地加以抑制:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     print(1 &#x2F; 0)</span><br><span class="line">... except:</span><br><span class="line">...     raise RuntimeError(&quot;Something bad happened&quot;) from None</span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 4, in &lt;module&gt;</span><br><span class="line">RuntimeError: Something bad happened</span><br></pre></td></tr></table></figure>

<p>有关异常的更多信息可在 <a href="https://docs.python.org/zh-cn/3/reference/executionmodel.html#exceptions" target="_blank" rel="noopener">异常</a> 一节查看，有关处理异常的信息可在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener">try 语句</a> 一节查看。</p>
<p><em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 现在允许被用作 <code>raise X from Y</code> 中的 <code>Y</code>。</p>
<p><em>3.3 新版功能:</em> 使用 <code>__suppress_context__</code> 属性来抑制异常上下文的自动显示。</p>
<h2 id="7-9-break-语句"><a href="#7-9-break-语句" class="headerlink" title="7.9. break 语句"></a>7.9. <code>break</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break_stmt ::&#x3D;  &quot;break&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 在语法上只会出现于 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> 循环所嵌套的代码，但不会出现于该循环内部的函数或类定义所嵌套的代码。</p>
<p>它会终结最近的外层循环，如果循环有可选的 <code>else</code> 子句，也会跳过该子句。</p>
<p>如果一个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 循环被 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 所终结，该循环的控制目标会保持其当前值。</p>
<p>当 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 将控制流传出一个带有 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句时，该 <code>finally</code> 子句会先被执行然后再真正离开该循环。</p>
<h2 id="7-10-continue-语句"><a href="#7-10-continue-语句" class="headerlink" title="7.10. continue 语句"></a>7.10. <code>continue</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue_stmt ::&#x3D;  &quot;continue&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 在语法上只会出现于 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> 循环所嵌套的代码中，但不会出现于该循环内部的函数或类定义中。 它会继续执行最近的外层循环的下一个轮次。</p>
<p>当 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 将控制流传出一个带有 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句时，该 <code>finally</code> 子句会先被执行然后再真正开始循环的下一个轮次。</p>
<h2 id="7-11-import-语句"><a href="#7-11-import-语句" class="headerlink" title="7.11. import 语句"></a>7.11. <code>import</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import_stmt     ::&#x3D;  &quot;import&quot; module [&quot;as&quot; identifier] (&quot;,&quot; module [&quot;as&quot; identifier])*</span><br><span class="line">                     | &quot;from&quot; relative_module &quot;import&quot; identifier [&quot;as&quot; identifier]</span><br><span class="line">                     (&quot;,&quot; identifier [&quot;as&quot; identifier])*</span><br><span class="line">                     | &quot;from&quot; relative_module &quot;import&quot; &quot;(&quot; identifier [&quot;as&quot; identifier]</span><br><span class="line">                     (&quot;,&quot; identifier [&quot;as&quot; identifier])* [&quot;,&quot;] &quot;)&quot;</span><br><span class="line">                     | &quot;from&quot; module &quot;import&quot; &quot;*&quot;</span><br><span class="line">module          ::&#x3D;  (identifier &quot;.&quot;)* identifier</span><br><span class="line">relative_module ::&#x3D;  &quot;.&quot;* module | &quot;.&quot;+</span><br></pre></td></tr></table></figure>

<p>基本的 import 语句（不带 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 子句）会分两步执行:</p>
<ol>
<li>查找一个模块，如果有必要还会加载并初始化模块。</li>
<li>在局部命名空间中为 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句发生位置所处的作用域定义一个或多个名称。</li>
</ol>
<p>当语句包含多个子句（由逗号分隔）时这两个步骤将对每个子句分别执行，如同这些子句被分成独立的 import 语句一样。</p>
<p>第一个步骤即查找和加载模块的详情 <a href="https://docs.python.org/zh-cn/3/reference/import.html#importsystem" target="_blank" rel="noopener">导入系统</a> 一节中有更详细的描述，其中也描述了可被导入的多种类型的包和模块，以及可用于定制导入系统的所有钩子对象。 请注意这一步如果失败，则可能说明模块无法找到，<em>或者</em> 是在初始化模块，包括执行模块代码期间发生了错误。</p>
<p>如果成功获取到请求的模块，则可以通过以下三种方式一之在局部命名空间中使用它:</p>
<ul>
<li>如果模块名称之后带有 <code>as</code>，则跟在 <code>as</code> 之后的名称将直接绑定到所导入的模块。</li>
<li>如果没有指定其他名称，且被导入的模块为最高层级模块，则模块的名称将被绑定到局部命名空间作为对所导入模块的引用。</li>
<li>如果被导入的模块 <em>不是</em> 最高层级模块，则包含该模块的最高层级包的名称将被绑定到局部命名空间作为对该最高层级包的引用。 所导入的模块必须使用其完整限定名称来访问而不能直接访问。</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 形式使用的过程略微繁复一些:</p>
<ol>
<li>查找 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 子句中指定的模块，如有必要还会加载并初始化模块；</li>
<li>对于 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 子句中指定的每个标识符：<ol>
<li>检查被导入模块是否有该名称的属性</li>
<li>如果没有，尝试导入具有该名称的子模块，然后再次检查被导入模块是否有该属性</li>
<li>如果未找到该属性，则引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a>。</li>
<li>否则的话，将对该值的引用存入局部命名空间，如果有 <code>as</code> 子句则使用其指定的名称，否则使用该属性的名称</li>
</ol>
</li>
</ol>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import foo                 # foo imported and bound locally</span><br><span class="line">import foo.bar.baz         # foo.bar.baz imported, foo bound locally</span><br><span class="line">import foo.bar.baz as fbb  # foo.bar.baz imported and bound as fbb</span><br><span class="line">from foo.bar import baz    # foo.bar.baz imported and bound as baz</span><br><span class="line">from foo import attr       # foo imported and foo.attr bound as attr</span><br></pre></td></tr></table></figure>

<p>如果标识符列表改为一个星号 (<code>&#39;*&#39;</code>)，则在模块中定义的全部公有名称都将按 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句所在的作用域被绑定到局部命名空间。</p>
<p>一个模块所定义的 <em>公有名称</em> 是由在模块的命名空间中检测一个名为 <code>__all__</code> 的变量来确定的；如果有定义，它必须是一个字符串列表，其中的项为该模块所定义或导入的名称。 在 <code>__all__</code> 中所给出的名称都会被视为公有并且应当存在。 如果 <code>__all__</code> 没有被定义，则公有名称的集合将包含在模块的命名空间中找到的所有不以下划线字符 (<code>&#39;_&#39;</code>) 打头的名称。 <code>__all__</code> 应当包括整个公有 API。 它的目标是避免意外地导出不属于 API 的一部分的项（例如在模块内部被导入和使用的库模块）。</p>
<p>通配符形式的导入 — <code>from module import *</code> — 仅在模块层级上被允许。 尝试在类或函数定义中使用它将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。</p>
<p>当指定要导入哪个模块时，你不必指定模块的绝对名称。 当一个模块或包被包含在另一个包之中时，可以在同一个最高层级包中进行相对导入，而不必提及包名称。 通过在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 之后指定的模块或包中使用前缀点号，你可以在不指定确切名称的情况下指明在当前包层级结构中要上溯多少级。 一个前缀点号表示是执行导入的模块所在的当前包，两个点号表示上溯一个包层级。 三个点号表示上溯两级，依此类推。 因此如果你执行 <code>from . import mod</code> 时所处位置为 <code>pkg</code> 包内的一个模块，则最终你将导入 <code>pkg.mod</code>。 如果你执行 <code>from ..subpkg2 import mod</code> 时所处位置为 <code>pkg.subpkg1</code> 则你将导入 <code>pkg.subpkg2.mod</code>。 有关相对导入的规范说明包含在 <a href="https://docs.python.org/zh-cn/3/reference/import.html#relativeimports" target="_blank" rel="noopener">包相对导入</a> 一节中。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.import_module" target="_blank" rel="noopener"><code>importlib.import_module()</code></a> 被提供用来为动态地确定要导入模块的应用提供支持。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>import</code> 附带参数 <code>module</code>, <code>filename</code>, <code>sys.path</code>, <code>sys.meta_path</code>, <code>sys.path_hooks</code>。</p>
<h3 id="7-11-1-future-语句"><a href="#7-11-1-future-语句" class="headerlink" title="7.11.1. future 语句"></a>7.11.1. future 语句</h3><p><em>future 语句</em> 是一种针对编译器的指令，指明某个特定模块应当使用在特定的未来某个 Python 发行版中成为标准特性的语法或语义。</p>
<p>future 语句的目的是使得向在语言中引入了不兼容改变的 Python 未来版本的迁移更为容易。 它允许基于每个模块在某种新特性成为标准之前的发行版中使用该特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">future_stmt ::&#x3D;  &quot;from&quot; &quot;__future__&quot; &quot;import&quot; feature [&quot;as&quot; identifier]</span><br><span class="line">                 (&quot;,&quot; feature [&quot;as&quot; identifier])*</span><br><span class="line">                 | &quot;from&quot; &quot;__future__&quot; &quot;import&quot; &quot;(&quot; feature [&quot;as&quot; identifier]</span><br><span class="line">                 (&quot;,&quot; feature [&quot;as&quot; identifier])* [&quot;,&quot;] &quot;)&quot;</span><br><span class="line">feature     ::&#x3D;  identifier</span><br></pre></td></tr></table></figure>

<p>future 语句必须在靠近模块开头的位置出现。 可以出现在 future 语句之前行只有:</p>
<ul>
<li>模块的文档字符串（如果存在），</li>
<li>注释，</li>
<li>空行，以及</li>
<li>其他 future 语句。</li>
</ul>
<p>在 Python 3.7 中唯一需要使用 future 语句的特性是 <code>标注</code>。</p>
<p>future 语句所启用的所有历史特性仍然为 Python 3 所认可。 其中包括 <code>absolute_import</code>, <code>division</code>, <code>generators</code>, <code>generator_stop</code>, <code>unicode_literals</code>, <code>print_function</code>, <code>nested_scopes</code> 和 <code>with_statement</code>。 它们都已成为冗余项，因为它们总是为已启用状态，保留它们只是为了向后兼容。</p>
<p>future 语句在编译时会被识别并做特殊对待：对核心构造语义的改变常常是通过生成不同的代码来实现。 新的特性甚至可能会引入新的不兼容语法（例如新的保留字），在这种情况下编译器可能需要以不同的方式来解析模块。 这样的决定不能推迟到运行时方才作出。</p>
<p>对于任何给定的发布版本，编译器要知道哪些特性名称已被定义，如果某个 future 语句包含未知的特性则会引发编译时错误。</p>
<p>直接运行时的语义与任何 import 语句相同：存在一个后文将详细说明的标准模块 <a href="https://docs.python.org/zh-cn/3/library/__future__.html#module-__future__" target="_blank" rel="noopener"><code>__future__</code></a>，它会在执行 future 语句时以通常的方式被导入。</p>
<p>相应的运行时语义取决于 future 语句所启用的指定特性。</p>
<p>请注意以下语句没有任何特别之处:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import __future__ [as name]</span><br></pre></td></tr></table></figure>

<p>这并非 future 语句；它只是一条没有特殊语义或语法限制的普通 import 语句。</p>
<p>在默认情况下，通过对Code compiled by calls to the 内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 的调用所编译的代码如果出现于一个包含有 future 语句的模块 <code>M</code> 之中，就会使用 future 语句所关联的语法和语义。 此行为可以通过 <a href="https://docs.python.org/zh-cn/3/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 的可选参数加以控制 — 请参阅该函数的文档以了解详情。</p>
<p>在交互式解释器提示符中键入的 future 语句将在解释器会话此后的交互中有效。 如果一个解释器的启动使用了 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-i" target="_blank" rel="noopener"><code>-i</code></a> 选项启动，并传入了一个脚本名称来执行，且该脚本包含 future 语句，它将在交互式会话开始执行脚本之后保持有效。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0236" target="_blank" rel="noopener"><strong>PEP 236</strong></a> - 回到 <strong>future</strong></p>
<p>有关 <strong>future</strong> 机制的最初提议。</p>
</li>
</ul>
<h2 id="7-12-global-语句"><a href="#7-12-global-语句" class="headerlink" title="7.12. global 语句"></a>7.12. <code>global</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global_stmt ::&#x3D;  &quot;global&quot; identifier (&quot;,&quot; identifier)*</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p>
<p>在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句中列出的名称不得在同一代码块内该 <code>global</code> 语句之前的位置中使用。</p>
<p>在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句中列出的名称不得被定义为正式形参，不也得出现于 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 循环的控制目标、<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#class" target="_blank" rel="noopener"><code>class</code></a> 定义、函数定义、<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句或变量标注之中。</p>
<p><strong>CPython implementation detail:</strong> 当前的实现并未强制要求所有的上述限制，但程序不应当滥用这样的自由，因为未来的实现可能会改为强制要求，并静默地改变程序的含义。</p>
<p><strong>程序员注意事项:</strong> <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 是对解析器的指令。 它仅对与 <code>global</code> 语句同时被解析的代码起作用。 特别地，包含在提供给内置 <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 函数字符串或代码对象中的 <code>global</code> 语句并不会影响 <em>包含</em> 该函数调用的代码块，而包含在这种字符串中的代码也不会受到包含该函数调用的代码中的 <code>global</code> 语句影响。 这同样适用于 <a href="https://docs.python.org/zh-cn/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 函数。</p>
<h2 id="7-13-nonlocal-语句"><a href="#7-13-nonlocal-语句" class="headerlink" title="7.13. nonlocal 语句"></a>7.13. <code>nonlocal</code> 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nonlocal_stmt ::&#x3D;  &quot;nonlocal&quot; identifier (&quot;,&quot; identifier)*</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的除全局变量以外的变量。 这种功能很重要，因为绑定的默认行为是先搜索局部命名空间。 这个语句允许被封装的代码重新绑定局部作用域以外且非全局（模块）作用域当中的变量。</p>
<p>与 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句中列出的名称不同，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-3104" target="_blank" rel="noopener"><strong>PEP 3104</strong></a> - 访问外层作用域中的名称</p>
<p>有关 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句的规范说明。</p>
</li>
</ul>
<h1 id="8-复合语句"><a href="#8-复合语句" class="headerlink" title="8. 复合语句"></a>8. 复合语句</h1><p>复合语句是包含其它语句（语句组）的语句；它们会以某种方式影响或控制所包含其它语句的执行。 通常，复合语句会跨越多行，虽然在某些简单形式下整个复合语句也可能包含于一行之内。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 语句用来实现传统的控制流程构造。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句为一组语句指定异常处理和/和清理代码，而 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句允许在一个代码块周围执行初始化和终结化代码。 函数和类定义在语法上也属于复合语句。</p>
<p>一条复合语句由一个或多个‘子句’组成。 一个子句则包含一个句头和一个‘句体’。 特定复合语句的子句头都处于相同的缩进层级。 每个子句头以一个作为唯一标识的关键字开始并以一个冒号结束。 子句体是由一个子句控制的一组语句。 子句体可以是在子句头的冒号之后与其同处一行的一条或由分号分隔的多条简单语句，或者也可以是在其之后缩进的一行或多行语句。 只有后一种形式的子句体才能包含嵌套的复合语句；以下形式是不合法的，这主要是因为无法分清某个后续的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#else" target="_blank" rel="noopener"><code>else</code></a> 子句应该属于哪个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 子句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if test1: if test2: print(x)</span><br></pre></td></tr></table></figure>

<p>还要注意的是在这种情形下分号的绑定比冒号更紧密，因此在以下示例中，所有 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 调用或者都不执行，或者都执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if x &lt; y &lt; z: print(x); print(y); print(z)</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">compound_stmt ::&#x3D;  if_stmt</span><br><span class="line">                   | while_stmt</span><br><span class="line">                   | for_stmt</span><br><span class="line">                   | try_stmt</span><br><span class="line">                   | with_stmt</span><br><span class="line">                   | funcdef</span><br><span class="line">                   | classdef</span><br><span class="line">                   | async_with_stmt</span><br><span class="line">                   | async_for_stmt</span><br><span class="line">                   | async_funcdef</span><br><span class="line">suite         ::&#x3D;  stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT</span><br><span class="line">statement     ::&#x3D;  stmt_list NEWLINE | compound_stmt</span><br><span class="line">stmt_list     ::&#x3D;  simple_stmt (&quot;;&quot; simple_stmt)* [&quot;;&quot;]</span><br></pre></td></tr></table></figure>

<p>请注意语句总是以 <code>NEWLINE</code> 结束，之后可能跟随一个 <code>DEDENT</code>。 还要注意可选的后续子句总是以一个不能作为语句开头的关键字作为开头，因此不会产生歧义（‘悬空的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#else" target="_blank" rel="noopener"><code>else</code></a>’问题在 Python 中是通过要求嵌套的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 语句必须缩进来解决的)。</p>
<p>为了保证清晰，以下各节中语法规则采用将每个子句都放在单独行中的格式。</p>
<h2 id="8-1-if-语句"><a href="#8-1-if-语句" class="headerlink" title="8.1. if 语句"></a>8.1. <code>if</code> 语句</h2><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 语句用于有条件的执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if_stmt ::&#x3D;  &quot;if&quot; assignment_expression &quot;:&quot; suite</span><br><span class="line">             (&quot;elif&quot; assignment_expression &quot;:&quot; suite)*</span><br><span class="line">             [&quot;else&quot; &quot;:&quot; suite]</span><br></pre></td></tr></table></figure>

<p>它通过对表达式逐个求值直至找到一个真值（请参阅 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#booleans" target="_blank" rel="noopener">布尔运算</a> 了解真值与假值的定义）在子句体中选择唯一匹配的一个；然后执行该子句体（而且 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 语句的其他部分不会被执行或求值）。 如果所有表达式均为假值，则如果 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#else" target="_blank" rel="noopener"><code>else</code></a> 子句体如果存在就会被执行。</p>
<h2 id="8-2-while-语句"><a href="#8-2-while-语句" class="headerlink" title="8.2. while 语句"></a>8.2. <code>while</code> 语句</h2><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> 语句用于在表达式保持为真的情况下重复地执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while_stmt ::&#x3D;  &quot;while&quot; assignment_expression &quot;:&quot; suite</span><br><span class="line">                [&quot;else&quot; &quot;:&quot; suite]</span><br></pre></td></tr></table></figure>

<p>这将重复地检验表达式，并且如果其值为真就执行第一个子句体；如果表达式值为假（这可能在第一次检验时就发生）则如果 <code>else</code> 子句体存在就会被执行并终止循环。</p>
<p>第一个子句体中的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 语句在执行时将终止循环且不执行 <code>else</code> 子句体。 第一个子句体中的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 语句在执行时将跳过子句体中的剩余部分并返回检验表达式。</p>
<h2 id="8-3-for-语句"><a href="#8-3-for-语句" class="headerlink" title="8.3. for 语句"></a>8.3. <code>for</code> 语句</h2><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元素进行迭代:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_stmt ::&#x3D;  &quot;for&quot; target_list &quot;in&quot; expression_list &quot;:&quot; suite</span><br><span class="line">              [&quot;else&quot; &quot;:&quot; suite]</span><br></pre></td></tr></table></figure>

<p>表达式列表会被求值一次；它应该产生一个可迭代对象。 系统将为 <code>expression_list</code> 的结果创建一个迭代器，然后将为迭代器所提供的每一项执行一次子句体，具体次序与迭代器的返回顺序一致。 每一项会按标准赋值规则 (参见 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#assignment" target="_blank" rel="noopener">赋值语句</a>) 被依次赋值给目标列表，然后子句体将被执行。 当所有项被耗尽时 (这会在序列为空或迭代器引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常时立刻发生)，<code>else</code> 子句的子句体如果存在将会被执行，并终止循环。</p>
<p>第一个子句体中的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 语句在执行时将终止循环且不执行 <code>else</code> 子句体。 第一个子句体中的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 语句在执行时将跳过子句体中的剩余部分并转往下一项继续执行，或者在没有下一项时转往 <code>else</code> 子句执行。</p>
<p>for 循环会对目标列表中的变量进行赋值。 这将覆盖之前对这些变量的所有赋值，包括在 for 循环体中的赋值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in range(10):</span><br><span class="line">    print(i)</span><br><span class="line">    i &#x3D; 5             # this will not affect the for-loop</span><br><span class="line">                      # because i will be overwritten with the next</span><br><span class="line">                      # index in the range</span><br></pre></td></tr></table></figure>

<p>目标列表中的名称在循环结束时不会被删除，但如果序列为空，则它们根本不会被循环所赋值。 提示：内置函数 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a> 会返回一个可迭代的整数序列，适用于模拟 Pascal 中的 <code>for i := a to b do</code> 这种效果；例如 <code>list(range(3))</code> 会返回列表 <code>[0, 1, 2]</code>。</p>
<p>注解</p>
<p>当序列在循环中被修改时会有一个微妙的问题（这只可能发生于可变序列例如列表中）。 会有一个内部计数器被用来跟踪下一个要使用的项，每次迭代都会使计数器递增。 当计数器值达到序列长度时循环就会终止。 这意味着如果语句体从序列中删除了当前（或之前）的一项，下一项就会被跳过（因为其标号将变成已被处理的当前项的标号）。 类似地，如果语句体在序列当前项的前面插入一个新项，当前项会在循环的下一轮中再次被处理。 这会导致麻烦的程序错误，避免此问题的办法是对整个序列使用切片来创建一个临时副本，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in a[:]:</span><br><span class="line">    if x &lt; 0: a.remove(x)</span><br></pre></td></tr></table></figure>



<h2 id="8-4-try-语句"><a href="#8-4-try-语句" class="headerlink" title="8.4. try 语句"></a>8.4. <code>try</code> 语句</h2><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句可为一组语句指定异常处理器和/或清理代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try_stmt  ::&#x3D;  try1_stmt | try2_stmt</span><br><span class="line">try1_stmt ::&#x3D;  &quot;try&quot; &quot;:&quot; suite</span><br><span class="line">               (&quot;except&quot; [expression [&quot;as&quot; identifier]] &quot;:&quot; suite)+</span><br><span class="line">               [&quot;else&quot; &quot;:&quot; suite]</span><br><span class="line">               [&quot;finally&quot; &quot;:&quot; suite]</span><br><span class="line">try2_stmt ::&#x3D;  &quot;try&quot; &quot;:&quot; suite</span><br><span class="line">               &quot;finally&quot; &quot;:&quot; suite</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句指定一个或多个异常处理器。 当 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 子句中没有发生异常时，没有异常处理器会被执行。 当 <code>try</code> 子句中发生异常时，将启动对异常处理器的搜索。 此搜索会依次检查 except 子句，直至找到与该异常相匹配的子句。 如果存在无表达式的 except 子句，它必须是最后一个；它将匹配任何异常。 对于带有表达式的 except 子句，该表达式会被求值，如果结果对象与发生的异常“兼容”则该子句将匹配该异常。 一个对象如果是异常对象所属的类或基类，或者是包含有兼容该异常的项的元组则两者就是兼容的。</p>
<p>如果没有 except 子句与异常相匹配，则会在周边代码和发起调用栈上继续搜索异常处理器。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#id4" target="_blank" rel="noopener">1</a></p>
<p>如果在对 except 子句头中的表达式求值时引发了异常，则原来对处理器的搜索会被取消，并在周边代码和调用栈上启动对新异常的搜索（它会被视作是整个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句所引发的异常）。</p>
<p>当找到一个匹配的 except 子句时，该异常将被赋值给该 except 子句在 <code>as</code> 关键字之后指定的目标，如果存在此关键字的话，并且该 except 子句体将被执行。 所有 except 子句都必须有可执行的子句体。 当到达子句体的末尾时，通常会转向整个 try 语句之后继续执行。 （这意味着如果对于同一异常存在有嵌套的两个处理器，而异常发生于内层处理器的 try 子句中，则外层处理器将不会处理该异常。）</p>
<p>当使用 <code>as</code> 将目标赋值为一个异常时，它将在 except 子句结束时被清除。 这就相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">except E as N:</span><br><span class="line">    foo</span><br></pre></td></tr></table></figure>

<p>被转写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">except E as N:</span><br><span class="line">    try:</span><br><span class="line">        foo</span><br><span class="line">    finally:</span><br><span class="line">        del N</span><br></pre></td></tr></table></figure>

<p>这意味着异常必须赋值给一个不同的名称才能在 except 子句之后引用它。 异常会被清除是因为在附加了回溯信息的情况下，它们会形成堆栈帧的循环引用，使得所有局部变量保持存活直到发生下一次垃圾回收。</p>
<p>在一个 except 子句体被执行之前，有关异常的详细信息存放在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" target="_blank" rel="noopener"><code>sys</code></a> 模块中，可通过 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.exc_info" target="_blank" rel="noopener"><code>sys.exc_info()</code></a> 来访问。 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.exc_info" target="_blank" rel="noopener"><code>sys.exc_info()</code></a> 返回一个 3 元组，由异常类、异常实例和回溯对象组成（参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#types" target="_blank" rel="noopener">标准类型层级结构</a> 一节），用于在程序中标识异常发生点。 当从处理异常的函数返回时 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.exc_info" target="_blank" rel="noopener"><code>sys.exc_info()</code></a> 的值会恢复为（调用前的）原值。</p>
<p>如果控制流离开 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 子句体时没有引发异常，并且没有执行 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 语句，可选的 <code>else</code> 子句将被执行。 <code>else</code> 语句中的异常不会由之前的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句处理。</p>
<p>如果存在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a>，它将指定一个‘清理’处理程序。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 子句会被执行，包括任何 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 和 <code>else</code> 子句。 如果在这些子句中发生任何未处理的异常，该异常会被临时保存。 <code>finally</code> 子句将被执行。 如果存在被保存的异常，它会在 <code>finally</code> 子句的末尾被重新引发。 如果 <code>finally</code> 子句引发了另一个异常，被保存的异常会被设为新异常的上下文。 如果 <code>finally</code> 子句执行了 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 语句，则被保存的异常会被丢弃:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f():</span><br><span class="line">...     try:</span><br><span class="line">...         1&#x2F;0</span><br><span class="line">...     finally:</span><br><span class="line">...         return 42</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句执行期间，程序不能获取异常信息。</p>
<p>当 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 语句在一个 <code>try</code>…<code>finally</code> 语句的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 子语句体中被执行时，<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子语句也会‘在离开时’被执行。</p>
<p>函数的返回值是由最后被执行的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句所决定的。 由于 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句总是被执行，因此在 <code>finally</code> 子句中被执行的 <code>return</code> 语句总是最后被执行的:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def foo():</span><br><span class="line">...     try:</span><br><span class="line">...         return &#39;try&#39;</span><br><span class="line">...     finally:</span><br><span class="line">...         return &#39;finally&#39;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; foo()</span><br><span class="line">&#39;finally&#39;</span><br></pre></td></tr></table></figure>

<p>有关异常的更多信息可以在 <a href="https://docs.python.org/zh-cn/3/reference/executionmodel.html#exceptions" target="_blank" rel="noopener">异常</a> 一节找到，有关使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 语句生成异常的信息可以在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener">raise 语句</a> 一节找到。</p>
<p><em>在 3.8 版更改:</em> 在 Python 3.8 之前，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 语句不允许在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句中使用，这是因为具体实现存在一个问题。</p>
<h2 id="8-5-with-语句"><a href="#8-5-with-语句" class="headerlink" title="8.5. with 语句"></a>8.5. <code>with</code> 语句</h2><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句用于包装带有使用上下文管理器 (参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#context-managers" target="_blank" rel="noopener">with 语句上下文管理器</a> 一节) 定义的方法的代码块的执行。 这允许对普通的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a>…<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a>…<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 使用模式进行封装以方便地重用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with_stmt ::&#x3D;  &quot;with&quot; with_item (&quot;,&quot; with_item)* &quot;:&quot; suite</span><br><span class="line">with_item ::&#x3D;  expression [&quot;as&quot; target]</span><br></pre></td></tr></table></figure>

<p>带有一个“项目”的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的执行过程如下:</p>
<ol>
<li><p>对上下文表达式 (在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#grammar-token-with-item" target="_blank" rel="noopener"><code>with_item</code></a> 中给出的表达式) 求值以获得一个上下文管理器。</p>
</li>
<li><p>载入上下文管理器的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__" target="_blank" rel="noopener"><code>__enter__()</code></a> 以便后续使用。</p>
</li>
<li><p>载入上下文管理器的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 以便后续使用。</p>
</li>
<li><p>发起调用上下文管理器的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__" target="_blank" rel="noopener"><code>__enter__()</code></a> 方法。</p>
</li>
<li><p>如果 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中包含一个目标，来自 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__" target="_blank" rel="noopener"><code>__enter__()</code></a> 的返回值将被赋值给它。</p>
<p>注解</p>
</li>
</ol>
<p>   <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句会保证如果 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__enter__" target="_blank" rel="noopener"><code>__enter__()</code></a> 方法返回时未发生错误，则 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 将总是被调用。 因此，如果在对目标列表赋值期间发生错误，则会将其视为在语句体内部发生的错误。 参见下面的第 6 步。</p>
<ol start="6">
<li><p>执行语句体。</p>
</li>
<li><p>发起调用上下文管理器的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法。 如果语句体的退出是由异常导致的，则其类型、值和回溯信息将被作为参数传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a>。 否则的话，将提供三个 <a href="https://docs.python.org/zh-cn/3/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 参数。</p>
<p>如果语句体的退出是由异常导致的，并且来自 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法的返回值为假，则该异常会被重新引发。 如果返回值为真，则该异常会被抑制，并会继续执行 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句之后的语句。</p>
<p>如果语句体由于异常以外的任何原因退出，则来自 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 的返回值会被忽略，并会在该类退出正常的发生位置继续执行。</p>
</li>
</ol>
<p>以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with EXPRESSION as TARGET:</span><br><span class="line">    SUITE</span><br></pre></td></tr></table></figure>

<p>在语义上等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">manager &#x3D; (EXPRESSION)</span><br><span class="line">enter &#x3D; type(manager).__enter__</span><br><span class="line">exit &#x3D; type(manager).__exit__</span><br><span class="line">value &#x3D; enter(manager)</span><br><span class="line">hit_except &#x3D; False</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    TARGET &#x3D; value</span><br><span class="line">    SUITE</span><br><span class="line">except:</span><br><span class="line">    hit_except &#x3D; True</span><br><span class="line">    if not exit(manager, *sys.exc_info()):</span><br><span class="line">        raise</span><br><span class="line">finally:</span><br><span class="line">    if not hit_except:</span><br><span class="line">        exit(manager, None, None, None)</span><br></pre></td></tr></table></figure>

<p>如果有多个项目，则会视作存在多个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句嵌套来处理多个上下文管理器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with A() as a, B() as b:</span><br><span class="line">    SUITE</span><br></pre></td></tr></table></figure>

<p>在语义上等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with A() as a:</span><br><span class="line">    with B() as b:</span><br><span class="line">        SUITE</span><br></pre></td></tr></table></figure>

<p><em>在 3.1 版更改:</em> 支持多个上下文表达式。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a> - “with” 语句</p>
<p>Python <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的规范描述、背景和示例。</p>
</li>
</ul>
<h2 id="8-6-函数定义"><a href="#8-6-函数定义" class="headerlink" title="8.6. 函数定义"></a>8.6. 函数定义</h2><p>函数定义就是对用户自定义函数的定义（参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#types" target="_blank" rel="noopener">标准类型层级结构</a> 一节）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">funcdef                   ::&#x3D;  [decorators] &quot;def&quot; funcname &quot;(&quot; [parameter_list] &quot;)&quot;</span><br><span class="line">                               [&quot;-&gt;&quot; expression] &quot;:&quot; suite</span><br><span class="line">decorators                ::&#x3D;  decorator+</span><br><span class="line">decorator                 ::&#x3D;  &quot;@&quot; dotted_name [&quot;(&quot; [argument_list [&quot;,&quot;]] &quot;)&quot;] NEWLINE</span><br><span class="line">dotted_name               ::&#x3D;  identifier (&quot;.&quot; identifier)*</span><br><span class="line">parameter_list            ::&#x3D;  defparameter (&quot;,&quot; defparameter)* &quot;,&quot; &quot;&#x2F;&quot; [&quot;,&quot; [parameter_list_no_posonly]]</span><br><span class="line">                                 | parameter_list_no_posonly</span><br><span class="line">parameter_list_no_posonly ::&#x3D;  defparameter (&quot;,&quot; defparameter)* [&quot;,&quot; [parameter_list_starargs]]</span><br><span class="line">                               | parameter_list_starargs</span><br><span class="line">parameter_list_starargs   ::&#x3D;  &quot;*&quot; [parameter] (&quot;,&quot; defparameter)* [&quot;,&quot; [&quot;**&quot; parameter [&quot;,&quot;]]]</span><br><span class="line">                               | &quot;**&quot; parameter [&quot;,&quot;]</span><br><span class="line">parameter                 ::&#x3D;  identifier [&quot;:&quot; expression]</span><br><span class="line">defparameter              ::&#x3D;  parameter [&quot;&#x3D;&quot; expression]</span><br><span class="line">funcname                  ::&#x3D;  identifier</span><br></pre></td></tr></table></figure>

<p>函数定义是一条可执行语句。 它执行时会在当前局部命名空间中将函数名称绑定到一个函数对象（函数可执行代码的包装器）。 这个函数对象包含对当前全局命名空间的引用，作为函数被调用时所使用的全局命名空间。</p>
<p>函数定义并不会执行函数体；只有当函数被调用时才会执行此操作。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#id5" target="_blank" rel="noopener">2</a></p>
<p>一个函数定义可以被一个或多个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a> 表达式所包装。 当函数被定义时将在包含该函数定义的作用域中对装饰器表达式求值。 求值结果必须是一个可调用对象，它会以该函数对象作为唯一参数被发起调用。 其返回值将被绑定到函数名称而非函数对象。 多个装饰器会以嵌套方式被应用。 例如以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@f1(arg)</span><br><span class="line">@f2</span><br><span class="line">def func(): pass</span><br></pre></td></tr></table></figure>

<p>大致等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def func(): pass</span><br><span class="line">func &#x3D; f1(arg)(f2(func))</span><br></pre></td></tr></table></figure>

<p>不同之处在于原始函数并不会被临时绑定到名称 <code>func</code>。</p>
<p>当一个或多个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-parameter" target="_blank" rel="noopener">形参</a> 具有 <em>形参</em> <code>=</code> <em>表达式</em> 这样的形式时，该函数就被称为具有“默认形参值”。 对于一个具有默认值的形参，其对应的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-argument" target="_blank" rel="noopener">argument</a> 可以在调用中被省略，在此情况下会用形参的默认值来替代。 如果一个形参具有默认值，后续所有在 “<code>*</code>“ 之前的形参也必须具有默认值 — 这个句法限制并未在语法中明确表达。</p>
<p><strong>默认形参值会在执行函数定义时按从左至右的顺序被求值。</strong> 这意味着当函数被定义时将对表达式求值一次，相同的“预计算”值将在每次调用时被使用。 这一点在默认形参为可变对象，例如列表或字典的时候尤其需要重点理解：如果函数修改了该对象（例如向列表添加了一项），则实际上默认值也会被修改。 这通常不是人们所预期的。 绕过此问题的一个方法是使用 <code>None</code> 作为默认值，并在函数体中显式地对其进行测试，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def whats_on_the_telly(penguin&#x3D;None):</span><br><span class="line">    if penguin is None:</span><br><span class="line">        penguin &#x3D; []</span><br><span class="line">    penguin.append(&quot;property of the zoo&quot;)</span><br><span class="line">    return penguin</span><br></pre></td></tr></table></figure>

<p>函数调用的语义在 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#calls" target="_blank" rel="noopener">调用</a> 一节中有更详细的描述。 函数调用总是会给形参列表中列出的所有形参赋值，或用位置参数，或用关键字参数，或用默认值。 如果存在 “<code>*identifier</code>“ 这样的形式，它会被初始化为一个元组来接收任何额外的位置参数，默认为空元组。 如果存在 “<code>**identifier</code>“ 这样的形式，它会被初始化为一个新的有序映射来接收任何额外的关键字参数，默认为一个相同类型的空映射。 在 “<code>*</code>“ 或 “<code>*identifier</code>“ 之后的形参都是仅关键字形参，只能通过关键字参数传入值。</p>
<p>形参可以带有 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-function-annotation" target="_blank" rel="noopener">标注</a>，其形式为在形参名称后加上 “<code>: expression</code>“。 任何形参都可以带有标注，甚至 <code>*identifier</code> 或 <code>**identifier</code> 这样的形参也可以。 函数可以带有“返回”标注，其形式为在形参列表后加上 “<code>-&gt; expression</code>“。 这些标注可以是任何有效的 Python 表达式。 标注的存在不会改变函数的语义。 标注值可以作为函数对象的 <code>__annotations__</code> 属性中以对应形参名称为键的字典值被访问。 如果使用了 <code>annotations</code> import from <a href="https://docs.python.org/zh-cn/3/library/__future__.html#module-__future__" target="_blank" rel="noopener"><code>__future__</code></a> 的方式，则标注会在运行时保存为字符串以启用延迟求值特性。 否则，它们会在执行函数定义时被求值。 在这种情况下，标注的求值顺序可能与它们在源代码中出现的顺序不同。</p>
<p>创建匿名函数（未绑定到一个名称的函数）以便立即在表达式中使用也是可能的。 这需要使用 lambda 表达式，具体描述见 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener">lambda 表达式</a> 一节。 请注意 lambda 只是简单函数定义的一种简化写法；在 “<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a>“ 语句中定义的函数也可以像用 lambda 表达式定义的函数一样被传递或赋值给其他名称。 “<code>def</code>“ 形式实际上更为强大，因为它允许执行多条语句和使用标注。</p>
<p><strong>程序员注意事项:</strong> 函数属于一类对象。 在一个函数内部执行的 “<code>def</code>“ 语句会定义一个局部函数并可被返回或传递。 在嵌套函数中使用的自由变量可以访问包含该 def 语句的函数的局部变量。 详情参见 <a href="https://docs.python.org/zh-cn/3/reference/executionmodel.html#naming" target="_blank" rel="noopener">命名与绑定</a> 一节。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-3107" target="_blank" rel="noopener"><strong>PEP 3107</strong></a> - 函数标注</p>
<p>最初的函数标注规范说明。</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> - 类型提示</p>
<p>标注的标准含意定义：类型提示。</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> - 变量标注的语法</p>
<p>变量声明的类型提示功能，包括类变量和实例变量</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-0563" target="_blank" rel="noopener"><strong>PEP 563</strong></a> - 延迟的标注求值</p>
<p>支持在运行时通过以字符串形式保存标注而非不是即求值来实现标注内部的向前引用。</p>
</li>
</ul>
<h2 id="8-7-类定义"><a href="#8-7-类定义" class="headerlink" title="8.7. 类定义"></a>8.7. 类定义</h2><p>类定义就是对类对象的定义 (参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#types" target="_blank" rel="noopener">标准类型层级结构</a> 一节):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classdef    ::&#x3D;  [decorators] &quot;class&quot; classname [inheritance] &quot;:&quot; suite</span><br><span class="line">inheritance ::&#x3D;  &quot;(&quot; [argument_list] &quot;)&quot;</span><br><span class="line">classname   ::&#x3D;  identifier</span><br></pre></td></tr></table></figure>

<p>类定义是一条可执行语句。 其中继承列表通常给出基类的列表 (进阶用法请参见 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#metaclasses" target="_blank" rel="noopener">元类</a>)，列表中的每一项都应当被求值为一个允许子类的类对象。 没有继承列表的类默认继承自基类 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>；因此，:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>随后类体将在一个新的执行帧 (参见 <a href="https://docs.python.org/zh-cn/3/reference/executionmodel.html#naming" target="_blank" rel="noopener">命名与绑定</a>) 中被执行，使用新创建的局部命名空间和原有的全局命名空间。 （通常，类体主要包含函数定义。） 当类体结束执行时，其执行帧将被丢弃而其局部命名空间会被保存。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#id6" target="_blank" rel="noopener">3</a> 一个类对象随后会被创建，其基类使用给定的继承列表，属性字典使用保存的局部命名空间。 类名称将在原有的全局命名空间中绑定到该类对象。</p>
<p>在类体内定义的属性的顺序保存在新类的 <code>__dict__</code> 中。 请注意此顺序的可靠性只限于类刚被创建时，并且只适用于使用定义语法所定义的类。</p>
<p>类的创建可使用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#metaclasses" target="_blank" rel="noopener">元类</a> 进行重度定制。</p>
<p>类也可以被装饰：就像装饰函数一样，:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@f1(arg)</span><br><span class="line">@f2</span><br><span class="line">class Foo: pass</span><br></pre></td></tr></table></figure>

<p>大致等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Foo: pass</span><br><span class="line">Foo &#x3D; f1(arg)(f2(Foo))</span><br></pre></td></tr></table></figure>

<p>装饰器表达式的求值规则与函数装饰器相同。 结果随后会被绑定到类名称。</p>
<p><strong>程序员注意事项:</strong> 在类定义内定义的变量是类属性；它们将被类实例所共享。 实例属性可通过 <code>self.name = value</code> 在方法中设定。 类和实例属性均可通过 “<code>self.name</code>“ 表示法来访问，当通过此方式访问时实例属性会隐藏同名的类属性。 类属性可被用作实例属性的默认值，但在此场景下使用可变值可能导致未预期的结果。 可以使用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#descriptors" target="_blank" rel="noopener">描述器</a> 来创建具有不同实现细节的实例变量。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-3115" target="_blank" rel="noopener"><strong>PEP 3115</strong></a> - Python 3000 中的元类</p>
<p>将元类声明修改为当前语法的提议，以及关于如何构建带有元类的类的语义描述。</p>
</li>
<li><p><a href="https://www.python.org/dev/peps/pep-3129" target="_blank" rel="noopener"><strong>PEP 3129</strong></a> - 类装饰器</p>
<p>增加类装饰器的提议。 函数和方法装饰器是在 <a href="https://www.python.org/dev/peps/pep-0318" target="_blank" rel="noopener"><strong>PEP 318</strong></a> 中被引入的。</p>
</li>
</ul>
<h2 id="8-8-协程"><a href="#8-8-协程" class="headerlink" title="8.8. 协程"></a>8.8. 协程</h2><p><em>3.5 新版功能.</em></p>
<h3 id="8-8-1-协程函数定义"><a href="#8-8-1-协程函数定义" class="headerlink" title="8.8.1. 协程函数定义"></a>8.8.1. 协程函数定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async_funcdef ::&#x3D;  [decorators] &quot;async&quot; &quot;def&quot; funcname &quot;(&quot; [parameter_list] &quot;)&quot;</span><br><span class="line">                   [&quot;-&gt;&quot; expression] &quot;:&quot; suite</span><br></pre></td></tr></table></figure>

<p>Python 协程可以在多个位置上挂起和恢复执行 (参见 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a>)。 在协程函数体内部，<code>await</code> 和 <code>async</code> 标识符已成为保留关键字；<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式，<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 以及 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-with" target="_blank" rel="noopener"><code>async with</code></a> 只能在协程函数体中使用。</p>
<p>使用 <code>async def</code> 语法定义的函数总是为协程函数，即使它们不包含 <code>await</code> 或 <code>async</code> 关键字。</p>
<p>在协程函数体中使用 <code>yield from</code> 表达式将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。</p>
<p>协程函数的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async def func(param1, param2):</span><br><span class="line">    do_stuff()</span><br><span class="line">    await some_coroutine()</span><br></pre></td></tr></table></figure>



<h3 id="8-8-2-async-for-语句"><a href="#8-8-2-async-for-语句" class="headerlink" title="8.8.2. async for 语句"></a>8.8.2. <code>async for</code> 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async_for_stmt ::&#x3D;  &quot;async&quot; for_stmt</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-iterable" target="_blank" rel="noopener">asynchronous iterable</a> 能够在其 <em>iter</em> 实现中调用异步代码，而 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 可以在其 <em>next</em> 方法中调用异步代码。</p>
<p><code>async for</code> 语句允许方便地对异步迭代器进行迭代。</p>
<p>以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async for TARGET in ITER:</span><br><span class="line">    SUITE</span><br><span class="line">else:</span><br><span class="line">    SUITE2</span><br></pre></td></tr></table></figure>

<p>在语义上等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iter &#x3D; (ITER)</span><br><span class="line">iter &#x3D; type(iter).__aiter__(iter)</span><br><span class="line">running &#x3D; True</span><br><span class="line"></span><br><span class="line">while running:</span><br><span class="line">    try:</span><br><span class="line">        TARGET &#x3D; await type(iter).__anext__(iter)</span><br><span class="line">    except StopAsyncIteration:</span><br><span class="line">        running &#x3D; False</span><br><span class="line">    else:</span><br><span class="line">        SUITE</span><br><span class="line">else:</span><br><span class="line">    SUITE2</span><br></pre></td></tr></table></figure>

<p>另请参阅 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__aiter__" target="_blank" rel="noopener"><code>__aiter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 了解详情。</p>
<p>在协程函数体之外使用 <code>async for</code> 语句将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。</p>
<h3 id="8-8-3-async-with-语句"><a href="#8-8-3-async-with-语句" class="headerlink" title="8.8.3. async with 语句"></a>8.8.3. <code>async with</code> 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async_with_stmt ::&#x3D;  &quot;async&quot; with_stmt</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-asynchronous-context-manager" target="_blank" rel="noopener">asynchronous context manager</a> 是一种 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-context-manager" target="_blank" rel="noopener">context manager</a>，能够在其 <em>enter</em> 和 <em>exit</em> 方法中暂停执行。</p>
<p>以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async with EXPRESSION as TARGET:</span><br><span class="line">    SUITE</span><br></pre></td></tr></table></figure>

<p>在语义上等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">manager &#x3D; (EXPRESSION)</span><br><span class="line">aexit &#x3D; type(manager).__aexit__</span><br><span class="line">aenter &#x3D; type(manager).__aenter__</span><br><span class="line">value &#x3D; await aenter(manager)</span><br><span class="line">hit_except &#x3D; False</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    TARGET &#x3D; value</span><br><span class="line">    SUITE</span><br><span class="line">except:</span><br><span class="line">    hit_except &#x3D; True</span><br><span class="line">    if not await aexit(manager, *sys.exc_info()):</span><br><span class="line">        raise</span><br><span class="line">finally:</span><br><span class="line">    if not hit_except:</span><br><span class="line">        await aexit(manager, None, None, None)</span><br></pre></td></tr></table></figure>

<p>另请参阅 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__aenter__" target="_blank" rel="noopener"><code>__aenter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__aexit__" target="_blank" rel="noopener"><code>__aexit__()</code></a> 了解详情。</p>
<p>在协程函数体之外使用 <code>async with</code> 语句将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。</p>
<p>参见</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> - 使用 async 和 await 语法实现协程</p>
<p>将协程作为 Python 中的一个正式的单独概念，并增加相应的支持语法。</p>
</li>
</ul>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#id1" target="_blank" rel="noopener">1</a></p>
<p>异常会被传播给发起调用栈，除非存在一个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句正好引发了另一个异常。 新引发的异常将导致旧异常的丢失。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#id2" target="_blank" rel="noopener">2</a></p>
<p>作为函数体的第一条语句出现的字符串字面值会被转换为函数的 <code>__doc__</code> 属性，也就是该函数的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#id3" target="_blank" rel="noopener">3</a></p>
<p>作为类体的第一条语句出现的字符串字面值会被转换为命名空间的 <code>__doc__</code> 条目，也就是该类的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。</p>
</li>
</ul>
<h1 id="9-最高层级组件"><a href="#9-最高层级组件" class="headerlink" title="9. 最高层级组件"></a>9. 最高层级组件</h1><p>Python 解释器可以从多种源获得输入：作为标准输入或程序参数传入的脚本，以交互方式键入的语句，导入的模块源文件等等。 这一章将给出在这些情况下所用的语法。</p>
<h2 id="9-1-完整的-Python-程序"><a href="#9-1-完整的-Python-程序" class="headerlink" title="9.1. 完整的 Python 程序"></a>9.1. 完整的 Python 程序</h2><p>虽然语言规范描述不必规定如何发起调用语言解释器，但对完整的 Python 程序加以说明还是很有用的。 一个完整的 Python 程序会在最小初始化环境中被执行：所有内置和标准模块均为可用，但均处于未初始化状态，只有 <a href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" target="_blank" rel="noopener"><code>sys</code></a> (各种系统服务), <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> (内置函数、异常以及 <code>None</code>) 和 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 除外。 最后一个模块用于为完整程序的执行提供局部和全局命名空间。</p>
<p>适用于一个完整 Python 程序的语法即下节所描述的文件输入。</p>
<p>解释器也可以通过交互模式被发起调用；在此情况下，它并不读取和执行一个完整程序，而是每次读取和执行一条语句（可能为复合语句）。 此时的初始环境与一个完整程序的相同；每条语句会在 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 的命名空间中被执行。</p>
<p>一个完整程序可通过三种形式被传递给解释器：使用 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-c" target="_blank" rel="noopener"><code>-c</code></a> <em>字符串</em> 命令行选项，使用一个文件作为第一个命令行参数，或者使用标准输入。 如果文件或标准输入是一个 tty 设置，解释器会进入交互模式；否则的话，它会将文件当作一个完整程序来执行。</p>
<h2 id="9-2-文件输入"><a href="#9-2-文件输入" class="headerlink" title="9.2. 文件输入"></a>9.2. 文件输入</h2><p>所有从非交互式文件读取的输入都具有相同的形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_input ::&#x3D;  (NEWLINE | statement)*</span><br></pre></td></tr></table></figure>

<p>此语法用于下列几种情况:</p>
<ul>
<li>解析一个完整 Python 程序时（从文件或字符串）；</li>
<li>解析一个模块时；</li>
<li>解析一个传递给 <a href="https://docs.python.org/zh-cn/3/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 函数的字符串时；</li>
</ul>
<h2 id="9-3-交互式输入"><a href="#9-3-交互式输入" class="headerlink" title="9.3. 交互式输入"></a>9.3. 交互式输入</h2><p>交互模式下的输入使用以下语法进行解析:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interactive_input ::&#x3D;  [stmt_list] NEWLINE | compound_stmt NEWLINE</span><br></pre></td></tr></table></figure>

<p>请注意在交互模式下一条（最高层级）复合语句必须带有一个空行；这对于帮助解析器确定输入的结束是必须的。</p>
<h2 id="9-4-表达式输入"><a href="#9-4-表达式输入" class="headerlink" title="9.4. 表达式输入"></a>9.4. 表达式输入</h2><p><a href="https://docs.python.org/zh-cn/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 被用于表达式输入。 它会忽略开头的空白。 传递给 <a href="https://docs.python.org/zh-cn/3/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 的字符串参数必须具有以下形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval_input ::&#x3D;  expression_list NEWLINE*</span><br></pre></td></tr></table></figure>

<h1 id="10-完整的语法规范"><a href="#10-完整的语法规范" class="headerlink" title="10. 完整的语法规范"></a>10. 完整的语法规范</h1><p>这是完整的Python语法，它被送入解析器生成器，以生成解析Python源文件的解析器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"># Grammar for Python</span><br><span class="line"></span><br><span class="line"># NOTE WELL: You should also follow all the steps listed at</span><br><span class="line"># https:&#x2F;&#x2F;devguide.python.org&#x2F;grammar&#x2F;</span><br><span class="line"></span><br><span class="line"># Start symbols for the grammar:</span><br><span class="line">#       single_input is a single interactive statement;</span><br><span class="line">#       file_input is a module or sequence of commands read from an input file;</span><br><span class="line">#       eval_input is the input for the eval() functions.</span><br><span class="line">#       func_type_input is a PEP 484 Python 2 function type comment</span><br><span class="line"># NB: compound_stmt in single_input is followed by extra NEWLINE!</span><br><span class="line"># NB: due to the way TYPE_COMMENT is tokenized it will always be followed by a NEWLINE</span><br><span class="line">single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE</span><br><span class="line">file_input: (NEWLINE | stmt)* ENDMARKER</span><br><span class="line">eval_input: testlist NEWLINE* ENDMARKER</span><br><span class="line"></span><br><span class="line">decorator: &#39;@&#39; dotted_name [ &#39;(&#39; [arglist] &#39;)&#39; ] NEWLINE</span><br><span class="line">decorators: decorator+</span><br><span class="line">decorated: decorators (classdef | funcdef | async_funcdef)</span><br><span class="line"></span><br><span class="line">async_funcdef: ASYNC funcdef</span><br><span class="line">funcdef: &#39;def&#39; NAME parameters [&#39;-&gt;&#39; test] &#39;:&#39; [TYPE_COMMENT] func_body_suite</span><br><span class="line"></span><br><span class="line">parameters: &#39;(&#39; [typedargslist] &#39;)&#39;</span><br><span class="line"></span><br><span class="line"># The following definition for typedarglist is equivalent to this set of rules:</span><br><span class="line">#</span><br><span class="line">#     arguments &#x3D; argument (&#39;,&#39; [TYPE_COMMENT] argument)*</span><br><span class="line">#     argument &#x3D; tfpdef [&#39;&#x3D;&#39; test]</span><br><span class="line">#     kwargs &#x3D; &#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]</span><br><span class="line">#     args &#x3D; &#39;*&#39; [tfpdef]</span><br><span class="line">#     kwonly_kwargs &#x3D; (&#39;,&#39; [TYPE_COMMENT] argument)* (TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [kwargs]])</span><br><span class="line">#     args_kwonly_kwargs &#x3D; args kwonly_kwargs | kwargs</span><br><span class="line">#     poskeyword_args_kwonly_kwargs &#x3D; arguments ( TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [args_kwonly_kwargs]])</span><br><span class="line">#     typedargslist_no_posonly  &#x3D; poskeyword_args_kwonly_kwargs | args_kwonly_kwargs</span><br><span class="line">#     typedarglist &#x3D; (arguments &#39;,&#39; [TYPE_COMMENT] &#39;&#x2F;&#39; [&#39;,&#39; [[TYPE_COMMENT] typedargslist_no_posonly]])|(typedargslist_no_posonly)&quot;</span><br><span class="line">#</span><br><span class="line"># It needs to be fully expanded to allow our LL(1) parser to work on it.</span><br><span class="line"></span><br><span class="line">typedargslist: (</span><br><span class="line">  (tfpdef [&#39;&#x3D;&#39; test] (&#39;,&#39; [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test])* &#39;,&#39; [TYPE_COMMENT] &#39;&#x2F;&#39; [&#39;,&#39; [ [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test] (</span><br><span class="line">        &#39;,&#39; [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test])* (TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [</span><br><span class="line">        &#39;*&#39; [tfpdef] (&#39;,&#39; [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test])* (TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [&#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]]])</span><br><span class="line">      | &#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]]])</span><br><span class="line">  | &#39;*&#39; [tfpdef] (&#39;,&#39; [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test])* (TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [&#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]]])</span><br><span class="line">  | &#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]]] )</span><br><span class="line">|  (tfpdef [&#39;&#x3D;&#39; test] (&#39;,&#39; [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test])* (TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [</span><br><span class="line">   &#39;*&#39; [tfpdef] (&#39;,&#39; [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test])* (TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [&#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]]])</span><br><span class="line">  | &#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]]])</span><br><span class="line">  | &#39;*&#39; [tfpdef] (&#39;,&#39; [TYPE_COMMENT] tfpdef [&#39;&#x3D;&#39; test])* (TYPE_COMMENT | [&#39;,&#39; [TYPE_COMMENT] [&#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT]]])</span><br><span class="line">  | &#39;**&#39; tfpdef [&#39;,&#39;] [TYPE_COMMENT])</span><br><span class="line">)</span><br><span class="line">tfpdef: NAME [&#39;:&#39; test]</span><br><span class="line"></span><br><span class="line"># The following definition for varargslist is equivalent to this set of rules:</span><br><span class="line">#</span><br><span class="line">#     arguments &#x3D; argument (&#39;,&#39; argument )*</span><br><span class="line">#     argument &#x3D; vfpdef [&#39;&#x3D;&#39; test]</span><br><span class="line">#     kwargs &#x3D; &#39;**&#39; vfpdef [&#39;,&#39;]</span><br><span class="line">#     args &#x3D; &#39;*&#39; [vfpdef]</span><br><span class="line">#     kwonly_kwargs &#x3D; (&#39;,&#39; argument )* [&#39;,&#39; [kwargs]]</span><br><span class="line">#     args_kwonly_kwargs &#x3D; args kwonly_kwargs | kwargs</span><br><span class="line">#     poskeyword_args_kwonly_kwargs &#x3D; arguments [&#39;,&#39; [args_kwonly_kwargs]]</span><br><span class="line">#     vararglist_no_posonly &#x3D; poskeyword_args_kwonly_kwargs | args_kwonly_kwargs</span><br><span class="line">#     varargslist &#x3D; arguments &#39;,&#39; &#39;&#x2F;&#39; [&#39;,&#39;[(vararglist_no_posonly)]] | (vararglist_no_posonly)</span><br><span class="line">#</span><br><span class="line"># It needs to be fully expanded to allow our LL(1) parser to work on it.</span><br><span class="line"></span><br><span class="line">varargslist: vfpdef [&#39;&#x3D;&#39; test ](&#39;,&#39; vfpdef [&#39;&#x3D;&#39; test])* &#39;,&#39; &#39;&#x2F;&#39; [&#39;,&#39; [ (vfpdef [&#39;&#x3D;&#39; test] (&#39;,&#39; vfpdef [&#39;&#x3D;&#39; test])* [&#39;,&#39; [</span><br><span class="line">        &#39;*&#39; [vfpdef] (&#39;,&#39; vfpdef [&#39;&#x3D;&#39; test])* [&#39;,&#39; [&#39;**&#39; vfpdef [&#39;,&#39;]]]</span><br><span class="line">      | &#39;**&#39; vfpdef [&#39;,&#39;]]]</span><br><span class="line">  | &#39;*&#39; [vfpdef] (&#39;,&#39; vfpdef [&#39;&#x3D;&#39; test])* [&#39;,&#39; [&#39;**&#39; vfpdef [&#39;,&#39;]]]</span><br><span class="line">  | &#39;**&#39; vfpdef [&#39;,&#39;]) ]] | (vfpdef [&#39;&#x3D;&#39; test] (&#39;,&#39; vfpdef [&#39;&#x3D;&#39; test])* [&#39;,&#39; [</span><br><span class="line">        &#39;*&#39; [vfpdef] (&#39;,&#39; vfpdef [&#39;&#x3D;&#39; test])* [&#39;,&#39; [&#39;**&#39; vfpdef [&#39;,&#39;]]]</span><br><span class="line">      | &#39;**&#39; vfpdef [&#39;,&#39;]]]</span><br><span class="line">  | &#39;*&#39; [vfpdef] (&#39;,&#39; vfpdef [&#39;&#x3D;&#39; test])* [&#39;,&#39; [&#39;**&#39; vfpdef [&#39;,&#39;]]]</span><br><span class="line">  | &#39;**&#39; vfpdef [&#39;,&#39;]</span><br><span class="line">)</span><br><span class="line">vfpdef: NAME</span><br><span class="line"></span><br><span class="line">stmt: simple_stmt | compound_stmt</span><br><span class="line">simple_stmt: small_stmt (&#39;;&#39; small_stmt)* [&#39;;&#39;] NEWLINE</span><br><span class="line">small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |</span><br><span class="line">             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)</span><br><span class="line">expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |</span><br><span class="line">                     [(&#39;&#x3D;&#39; (yield_expr|testlist_star_expr))+ [TYPE_COMMENT]] )</span><br><span class="line">annassign: &#39;:&#39; test [&#39;&#x3D;&#39; (yield_expr|testlist_star_expr)]</span><br><span class="line">testlist_star_expr: (test|star_expr) (&#39;,&#39; (test|star_expr))* [&#39;,&#39;]</span><br><span class="line">augassign: (&#39;+&#x3D;&#39; | &#39;-&#x3D;&#39; | &#39;*&#x3D;&#39; | &#39;@&#x3D;&#39; | &#39;&#x2F;&#x3D;&#39; | &#39;%&#x3D;&#39; | &#39;&amp;&#x3D;&#39; | &#39;|&#x3D;&#39; | &#39;^&#x3D;&#39; |</span><br><span class="line">            &#39;&lt;&lt;&#x3D;&#39; | &#39;&gt;&gt;&#x3D;&#39; | &#39;**&#x3D;&#39; | &#39;&#x2F;&#x2F;&#x3D;&#39;)</span><br><span class="line"># For normal and annotated assignments, additional restrictions enforced by the interpreter</span><br><span class="line">del_stmt: &#39;del&#39; exprlist</span><br><span class="line">pass_stmt: &#39;pass&#39;</span><br><span class="line">flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt</span><br><span class="line">break_stmt: &#39;break&#39;</span><br><span class="line">continue_stmt: &#39;continue&#39;</span><br><span class="line">return_stmt: &#39;return&#39; [testlist_star_expr]</span><br><span class="line">yield_stmt: yield_expr</span><br><span class="line">raise_stmt: &#39;raise&#39; [test [&#39;from&#39; test]]</span><br><span class="line">import_stmt: import_name | import_from</span><br><span class="line">import_name: &#39;import&#39; dotted_as_names</span><br><span class="line"># note below: the (&#39;.&#39; | &#39;...&#39;) is necessary because &#39;...&#39; is tokenized as ELLIPSIS</span><br><span class="line">import_from: (&#39;from&#39; ((&#39;.&#39; | &#39;...&#39;)* dotted_name | (&#39;.&#39; | &#39;...&#39;)+)</span><br><span class="line">              &#39;import&#39; (&#39;*&#39; | &#39;(&#39; import_as_names &#39;)&#39; | import_as_names))</span><br><span class="line">import_as_name: NAME [&#39;as&#39; NAME]</span><br><span class="line">dotted_as_name: dotted_name [&#39;as&#39; NAME]</span><br><span class="line">import_as_names: import_as_name (&#39;,&#39; import_as_name)* [&#39;,&#39;]</span><br><span class="line">dotted_as_names: dotted_as_name (&#39;,&#39; dotted_as_name)*</span><br><span class="line">dotted_name: NAME (&#39;.&#39; NAME)*</span><br><span class="line">global_stmt: &#39;global&#39; NAME (&#39;,&#39; NAME)*</span><br><span class="line">nonlocal_stmt: &#39;nonlocal&#39; NAME (&#39;,&#39; NAME)*</span><br><span class="line">assert_stmt: &#39;assert&#39; test [&#39;,&#39; test]</span><br><span class="line"></span><br><span class="line">compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt</span><br><span class="line">async_stmt: ASYNC (funcdef | with_stmt | for_stmt)</span><br><span class="line">if_stmt: &#39;if&#39; namedexpr_test &#39;:&#39; suite (&#39;elif&#39; namedexpr_test &#39;:&#39; suite)* [&#39;else&#39; &#39;:&#39; suite]</span><br><span class="line">while_stmt: &#39;while&#39; namedexpr_test &#39;:&#39; suite [&#39;else&#39; &#39;:&#39; suite]</span><br><span class="line">for_stmt: &#39;for&#39; exprlist &#39;in&#39; testlist &#39;:&#39; [TYPE_COMMENT] suite [&#39;else&#39; &#39;:&#39; suite]</span><br><span class="line">try_stmt: (&#39;try&#39; &#39;:&#39; suite</span><br><span class="line">           ((except_clause &#39;:&#39; suite)+</span><br><span class="line">            [&#39;else&#39; &#39;:&#39; suite]</span><br><span class="line">            [&#39;finally&#39; &#39;:&#39; suite] |</span><br><span class="line">           &#39;finally&#39; &#39;:&#39; suite))</span><br><span class="line">with_stmt: &#39;with&#39; with_item (&#39;,&#39; with_item)*  &#39;:&#39; [TYPE_COMMENT] suite</span><br><span class="line">with_item: test [&#39;as&#39; expr]</span><br><span class="line"># NB compile.c makes sure that the default except clause is last</span><br><span class="line">except_clause: &#39;except&#39; [test [&#39;as&#39; NAME]]</span><br><span class="line">suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT</span><br><span class="line"></span><br><span class="line">namedexpr_test: test [&#39;:&#x3D;&#39; test]</span><br><span class="line">test: or_test [&#39;if&#39; or_test &#39;else&#39; test] | lambdef</span><br><span class="line">test_nocond: or_test | lambdef_nocond</span><br><span class="line">lambdef: &#39;lambda&#39; [varargslist] &#39;:&#39; test</span><br><span class="line">lambdef_nocond: &#39;lambda&#39; [varargslist] &#39;:&#39; test_nocond</span><br><span class="line">or_test: and_test (&#39;or&#39; and_test)*</span><br><span class="line">and_test: not_test (&#39;and&#39; not_test)*</span><br><span class="line">not_test: &#39;not&#39; not_test | comparison</span><br><span class="line">comparison: expr (comp_op expr)*</span><br><span class="line"># &lt;&gt; isn&#39;t actually a valid comparison operator in Python. It&#39;s here for the</span><br><span class="line"># sake of a __future__ import described in PEP 401 (which really works :-)</span><br><span class="line">comp_op: &#39;&lt;&#39;|&#39;&gt;&#39;|&#39;&#x3D;&#x3D;&#39;|&#39;&gt;&#x3D;&#39;|&#39;&lt;&#x3D;&#39;|&#39;&lt;&gt;&#39;|&#39;!&#x3D;&#39;|&#39;in&#39;|&#39;not&#39; &#39;in&#39;|&#39;is&#39;|&#39;is&#39; &#39;not&#39;</span><br><span class="line">star_expr: &#39;*&#39; expr</span><br><span class="line">expr: xor_expr (&#39;|&#39; xor_expr)*</span><br><span class="line">xor_expr: and_expr (&#39;^&#39; and_expr)*</span><br><span class="line">and_expr: shift_expr (&#39;&amp;&#39; shift_expr)*</span><br><span class="line">shift_expr: arith_expr ((&#39;&lt;&lt;&#39;|&#39;&gt;&gt;&#39;) arith_expr)*</span><br><span class="line">arith_expr: term ((&#39;+&#39;|&#39;-&#39;) term)*</span><br><span class="line">term: factor ((&#39;*&#39;|&#39;@&#39;|&#39;&#x2F;&#39;|&#39;%&#39;|&#39;&#x2F;&#x2F;&#39;) factor)*</span><br><span class="line">factor: (&#39;+&#39;|&#39;-&#39;|&#39;~&#39;) factor | power</span><br><span class="line">power: atom_expr [&#39;**&#39; factor]</span><br><span class="line">atom_expr: [AWAIT] atom trailer*</span><br><span class="line">atom: (&#39;(&#39; [yield_expr|testlist_comp] &#39;)&#39; |</span><br><span class="line">       &#39;[&#39; [testlist_comp] &#39;]&#39; |</span><br><span class="line">       &#39;&#123;&#39; [dictorsetmaker] &#39;&#125;&#39; |</span><br><span class="line">       NAME | NUMBER | STRING+ | &#39;...&#39; | &#39;None&#39; | &#39;True&#39; | &#39;False&#39;)</span><br><span class="line">testlist_comp: (namedexpr_test|star_expr) ( comp_for | (&#39;,&#39; (namedexpr_test|star_expr))* [&#39;,&#39;] )</span><br><span class="line">trailer: &#39;(&#39; [arglist] &#39;)&#39; | &#39;[&#39; subscriptlist &#39;]&#39; | &#39;.&#39; NAME</span><br><span class="line">subscriptlist: subscript (&#39;,&#39; subscript)* [&#39;,&#39;]</span><br><span class="line">subscript: test | [test] &#39;:&#39; [test] [sliceop]</span><br><span class="line">sliceop: &#39;:&#39; [test]</span><br><span class="line">exprlist: (expr|star_expr) (&#39;,&#39; (expr|star_expr))* [&#39;,&#39;]</span><br><span class="line">testlist: test (&#39;,&#39; test)* [&#39;,&#39;]</span><br><span class="line">dictorsetmaker: ( ((test &#39;:&#39; test | &#39;**&#39; expr)</span><br><span class="line">                   (comp_for | (&#39;,&#39; (test &#39;:&#39; test | &#39;**&#39; expr))* [&#39;,&#39;])) |</span><br><span class="line">                  ((test | star_expr)</span><br><span class="line">                   (comp_for | (&#39;,&#39; (test | star_expr))* [&#39;,&#39;])) )</span><br><span class="line"></span><br><span class="line">classdef: &#39;class&#39; NAME [&#39;(&#39; [arglist] &#39;)&#39;] &#39;:&#39; suite</span><br><span class="line"></span><br><span class="line">arglist: argument (&#39;,&#39; argument)*  [&#39;,&#39;]</span><br><span class="line"></span><br><span class="line"># The reason that keywords are test nodes instead of NAME is that using NAME</span><br><span class="line"># results in an ambiguity. ast.c makes sure it&#39;s a NAME.</span><br><span class="line"># &quot;test &#39;&#x3D;&#39; test&quot; is really &quot;keyword &#39;&#x3D;&#39; test&quot;, but we have no such token.</span><br><span class="line"># These need to be in a single rule to avoid grammar that is ambiguous</span><br><span class="line"># to our LL(1) parser. Even though &#39;test&#39; includes &#39;*expr&#39; in star_expr,</span><br><span class="line"># we explicitly match &#39;*&#39; here, too, to give it proper precedence.</span><br><span class="line"># Illegal combinations and orderings are blocked in ast.c:</span><br><span class="line"># multiple (test comp_for) arguments are blocked; keyword unpackings</span><br><span class="line"># that precede iterable unpackings are blocked; etc.</span><br><span class="line">argument: ( test [comp_for] |</span><br><span class="line">            test &#39;:&#x3D;&#39; test |</span><br><span class="line">            test &#39;&#x3D;&#39; test |</span><br><span class="line">            &#39;**&#39; test |</span><br><span class="line">            &#39;*&#39; test )</span><br><span class="line"></span><br><span class="line">comp_iter: comp_for | comp_if</span><br><span class="line">sync_comp_for: &#39;for&#39; exprlist &#39;in&#39; or_test [comp_iter]</span><br><span class="line">comp_for: [ASYNC] sync_comp_for</span><br><span class="line">comp_if: &#39;if&#39; test_nocond [comp_iter]</span><br><span class="line"></span><br><span class="line"># not used in grammar, but may appear in &quot;node&quot; passed from Parser to Compiler</span><br><span class="line">encoding_decl: NAME</span><br><span class="line"></span><br><span class="line">yield_expr: &#39;yield&#39; [yield_arg]</span><br><span class="line">yield_arg: &#39;from&#39; test | testlist_star_expr</span><br><span class="line"></span><br><span class="line"># the TYPE_COMMENT in suites is only parsed for funcdefs,</span><br><span class="line"># but can&#39;t go elsewhere due to ambiguity</span><br><span class="line">func_body_suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT</span><br><span class="line"></span><br><span class="line">func_type_input: func_type NEWLINE* ENDMARKER</span><br><span class="line">func_type: &#39;(&#39; [typelist] &#39;)&#39; &#39;-&gt;&#39; test</span><br><span class="line"># typelist is a modified typedargslist (see above)</span><br><span class="line">typelist: (test (&#39;,&#39; test)* [&#39;,&#39;</span><br><span class="line">       [&#39;*&#39; [test] (&#39;,&#39; test)* [&#39;,&#39; &#39;**&#39; test] | &#39;**&#39; test]]</span><br><span class="line">     |  &#39;*&#39; [test] (&#39;,&#39; test)* [&#39;,&#39; &#39;**&#39; test] | &#39;**&#39; test)</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">蕾米亚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://omimo.ga/2020/d98b1daa.html">http://omimo.ga/2020/d98b1daa.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://omimo.ga" target="_blank">彭彭和丁满</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/8a2b378.html"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover3.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">20200325疫情信息</div></div></a></div><div class="next-post pull_right"><a href="/2020/b23cbeff.html"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover5.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python入门教程</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/b23cbeff.html" title="python入门教程"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover5.gif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-24</div><div class="relatedPosts_title">python入门教程</div></div></a></div><div class="relatedPosts_item"><a href="/2020/3c368bb6.html" title="python常用库模块"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/wdsrkrrjmqo.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-12</div><div class="relatedPosts_title">python常用库模块</div></div></a></div><div class="relatedPosts_item"><a href="/2019/4f239c31.html" title="Python Interview"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/朝天门.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-03-03</div><div class="relatedPosts_title">Python Interview</div></div></a></div><div class="relatedPosts_item"><a href="/2017/5c1674cb.html" title="Python—Virtualenv---pyenv简明教程(MAC版)"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover2.gif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2017-05-24</div><div class="relatedPosts_title">Python—Virtualenv---pyenv简明教程(MAC版)</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'x8zJ7Nuyh3yChQgtKcdg4zwC-MdYXbMMI',
  appKey: 'pWRle3EfOO23aYlB3O1SyOQs',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2020 By 蕾米亚</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>