<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>python入门教程 | 彭彭和丁满</title><meta name="description" content="python入门教程"><meta name="keywords" content="python"><meta name="author" content="蕾米亚"><meta name="copyright" content="蕾米亚"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="python入门教程"><meta name="twitter:description" content="python入门教程"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover5.gif"><meta property="og:type" content="article"><meta property="og:title" content="python入门教程"><meta property="og:url" content="http://omimo.ga/2020/b23cbeff.html"><meta property="og:site_name" content="彭彭和丁满"><meta property="og:description" content="python入门教程"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover5.gif"><meta property="article:published_time" content="2020-03-24T07:39:46.000Z"><meta property="article:modified_time" content="2020-03-24T07:39:46.000Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://omimo.ga/2020/b23cbeff.html"><link rel="prev" title="python语言参考" href="http://omimo.ga/2020/d98b1daa.html"><link rel="next" title="20200324疫情信息" href="http://omimo.ga/2020/d5346afd.html"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?568a96aacae5c6fda285d9376b556b06";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://www.omimo.ga","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/img/longmao.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">161</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">57</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">29</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-folder-open"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/front/"><i class="fa-fw fa fa-link"></i><span> 导航</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-课前甜点"><span class="toc-number">1.</span> <span class="toc-text">1. 课前甜点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-使用-Python-解释器"><span class="toc-number">2.</span> <span class="toc-text">2. 使用 Python 解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-调用解释器"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 调用解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-传入参数"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. 传入参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-交互模式"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. 交互模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-解释器的运行环境"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 解释器的运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-源文件的字符编码"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. 源文件的字符编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Python-的非正式介绍"><span class="toc-number">3.</span> <span class="toc-text">3. Python 的非正式介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Python-作为计算器使用"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. Python 作为计算器使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-数字"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1. 数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-字符串"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2. 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-列表"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3. 列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-走向编程的第一步"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 走向编程的第一步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-其他流程控制工具"><span class="toc-number">4.</span> <span class="toc-text">4. 其他流程控制工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-if-语句"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. if 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-for-语句"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. for 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-range-函数"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. range() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-break-和-continue-语句，以及循环中的-else-子句"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. break 和 continue 语句，以及循环中的 else 子句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-pass-语句"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. pass 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-定义函数"><span class="toc-number">4.6.</span> <span class="toc-text">4.6. 定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-函数定义的更多形式"><span class="toc-number">4.7.</span> <span class="toc-text">4.7. 函数定义的更多形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-参数默认值"><span class="toc-number">4.7.1.</span> <span class="toc-text">4.7.1. 参数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-关键字参数"><span class="toc-number">4.7.2.</span> <span class="toc-text">4.7.2. 关键字参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-特殊参数"><span class="toc-number">4.7.3.</span> <span class="toc-text">4.7.3. 特殊参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-3-1-位置或关键字参数"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">4.7.3.1. 位置或关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-3-2-仅限位置参数"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">4.7.3.2. 仅限位置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-3-3-仅限关键字参数"><span class="toc-number">4.7.3.3.</span> <span class="toc-text">4.7.3.3. 仅限关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-3-4-函数示例"><span class="toc-number">4.7.3.4.</span> <span class="toc-text">4.7.3.4. 函数示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-3-5-概括"><span class="toc-number">4.7.3.5.</span> <span class="toc-text">4.7.3.5. 概括</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-任意的参数列表"><span class="toc-number">4.7.4.</span> <span class="toc-text">4.7.4. 任意的参数列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-5-解包参数列表"><span class="toc-number">4.7.5.</span> <span class="toc-text">4.7.5. 解包参数列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-6-Lambda-表达式"><span class="toc-number">4.7.6.</span> <span class="toc-text">4.7.6. Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-7-文档字符串"><span class="toc-number">4.7.7.</span> <span class="toc-text">4.7.7. 文档字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-8-函数标注"><span class="toc-number">4.7.8.</span> <span class="toc-text">4.7.8. 函数标注</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-小插曲：编码风格"><span class="toc-number">4.8.</span> <span class="toc-text">4.8. 小插曲：编码风格</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-数据结构"><span class="toc-number">5.</span> <span class="toc-text">5. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-列表的更多特性"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 列表的更多特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-列表作为栈使用"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1. 列表作为栈使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-列表作为队列使用"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2. 列表作为队列使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-列表推导式"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3. 列表推导式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-嵌套的列表推导式"><span class="toc-number">5.1.4.</span> <span class="toc-text">5.1.4. 嵌套的列表推导式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-del-语句"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. del 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-元组和序列"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 元组和序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-集合"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-字典"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-循环的技巧"><span class="toc-number">5.6.</span> <span class="toc-text">5.6. 循环的技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-深入条件控制"><span class="toc-number">5.7.</span> <span class="toc-text">5.7. 深入条件控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-序列和其它类型的比较"><span class="toc-number">5.8.</span> <span class="toc-text">5.8. 序列和其它类型的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-模块"><span class="toc-number">6.</span> <span class="toc-text">6. 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-有关模块的更多信息"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 有关模块的更多信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-以脚本的方式执行模块"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1. 以脚本的方式执行模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-模块搜索路径"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2. 模块搜索路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-“编译过的”Python文件"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3. “编译过的”Python文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-标准模块"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 标准模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-dir-函数"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. dir() 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-包"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. 包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-从包中导入"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1. 从包中导入 *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-子包参考"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2. 子包参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-多个目录中的包"><span class="toc-number">6.4.3.</span> <span class="toc-text">6.4.3. 多个目录中的包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-输入输出"><span class="toc-number">7.</span> <span class="toc-text">7. 输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-更漂亮的输出格式"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 更漂亮的输出格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-格式化字符串文字"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1. 格式化字符串文字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-字符串的-format-方法"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2. 字符串的 format() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-手动格式化字符串"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3. 手动格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-旧的字符串格式化方法"><span class="toc-number">7.1.4.</span> <span class="toc-text">7.1.4. 旧的字符串格式化方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-读写文件"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-文件对象的方法"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1. 文件对象的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-使用-json-保存结构化数据"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2. 使用 json 保存结构化数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-错误和异常"><span class="toc-number">8.</span> <span class="toc-text">8. 错误和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-语法错误"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. 语法错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-异常"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-处理异常"><span class="toc-number">8.3.</span> <span class="toc-text">8.3. 处理异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-抛出异常"><span class="toc-number">8.4.</span> <span class="toc-text">8.4. 抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-用户自定义异常"><span class="toc-number">8.5.</span> <span class="toc-text">8.5. 用户自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-定义清理操作"><span class="toc-number">8.6.</span> <span class="toc-text">8.6. 定义清理操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-预定义的清理操作"><span class="toc-number">8.7.</span> <span class="toc-text">8.7. 预定义的清理操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-类"><span class="toc-number">9.</span> <span class="toc-text">9. 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-名称和对象"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. 名称和对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Python-作用域和命名空间"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. Python 作用域和命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-作用域和命名空间示例"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1. 作用域和命名空间示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-初探类"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. 初探类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-类定义语法"><span class="toc-number">9.3.1.</span> <span class="toc-text">9.3.1. 类定义语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-类对象"><span class="toc-number">9.3.2.</span> <span class="toc-text">9.3.2. 类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-实例对象"><span class="toc-number">9.3.3.</span> <span class="toc-text">9.3.3. 实例对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-方法对象"><span class="toc-number">9.3.4.</span> <span class="toc-text">9.3.4. 方法对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-类和实例变量"><span class="toc-number">9.3.5.</span> <span class="toc-text">9.3.5. 类和实例变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-补充说明"><span class="toc-number">9.4.</span> <span class="toc-text">9.4. 补充说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-继承"><span class="toc-number">9.5.</span> <span class="toc-text">9.5. 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-1-多重继承"><span class="toc-number">9.5.1.</span> <span class="toc-text">9.5.1. 多重继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-私有变量"><span class="toc-number">9.6.</span> <span class="toc-text">9.6. 私有变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-杂项说明"><span class="toc-number">9.7.</span> <span class="toc-text">9.7. 杂项说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-迭代器"><span class="toc-number">9.8.</span> <span class="toc-text">9.8. 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-生成器"><span class="toc-number">9.9.</span> <span class="toc-text">9.9. 生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10-生成器表达式"><span class="toc-number">9.10.</span> <span class="toc-text">9.10. 生成器表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-标准库简介"><span class="toc-number">10.</span> <span class="toc-text">10. 标准库简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-操作系统接口"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. 操作系统接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-文件通配符"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. 文件通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-命令行参数"><span class="toc-number">10.3.</span> <span class="toc-text">10.3. 命令行参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-错误输出重定向和程序终止"><span class="toc-number">10.4.</span> <span class="toc-text">10.4. 错误输出重定向和程序终止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-字符串模式匹配"><span class="toc-number">10.5.</span> <span class="toc-text">10.5. 字符串模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-数学"><span class="toc-number">10.6.</span> <span class="toc-text">10.6. 数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-互联网访问"><span class="toc-number">10.7.</span> <span class="toc-text">10.7. 互联网访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-8-日期和时间"><span class="toc-number">10.8.</span> <span class="toc-text">10.8. 日期和时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-9-数据压缩"><span class="toc-number">10.9.</span> <span class="toc-text">10.9. 数据压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-10-性能测量"><span class="toc-number">10.10.</span> <span class="toc-text">10.10. 性能测量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-11-质量控制"><span class="toc-number">10.11.</span> <span class="toc-text">10.11. 质量控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-12-自带电池"><span class="toc-number">10.12.</span> <span class="toc-text">10.12. 自带电池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-标准库简介-——-第二部分"><span class="toc-number">11.</span> <span class="toc-text">11. 标准库简介 —— 第二部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-格式化输出"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. 格式化输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-模板"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. 模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-使用二进制数据记录格式"><span class="toc-number">11.3.</span> <span class="toc-text">11.3. 使用二进制数据记录格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-多线程"><span class="toc-number">11.4.</span> <span class="toc-text">11.4. 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-日志"><span class="toc-number">11.5.</span> <span class="toc-text">11.5. 日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-弱引用"><span class="toc-number">11.6.</span> <span class="toc-text">11.6. 弱引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-用于操作列表的工具"><span class="toc-number">11.7.</span> <span class="toc-text">11.7. 用于操作列表的工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-8-十进制浮点运算"><span class="toc-number">11.8.</span> <span class="toc-text">11.8. 十进制浮点运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-虚拟环境和包"><span class="toc-number">12.</span> <span class="toc-text">12. 虚拟环境和包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-概述"><span class="toc-number">12.1.</span> <span class="toc-text">12.1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-创建虚拟环境"><span class="toc-number">12.2.</span> <span class="toc-text">12.2. 创建虚拟环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-使用pip管理包"><span class="toc-number">12.3.</span> <span class="toc-text">12.3. 使用pip管理包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-接下来？"><span class="toc-number">13.</span> <span class="toc-text">13. 接下来？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-交互式编辑和编辑历史"><span class="toc-number">14.</span> <span class="toc-text">14. 交互式编辑和编辑历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-Tab-补全和编辑历史"><span class="toc-number">14.1.</span> <span class="toc-text">14.1. Tab 补全和编辑历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-默认交互式解释器的替代品"><span class="toc-number">14.2.</span> <span class="toc-text">14.2. 默认交互式解释器的替代品</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-浮点算术：争议和限制"><span class="toc-number">15.</span> <span class="toc-text">15. 浮点算术：争议和限制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-表示性错误"><span class="toc-number">15.1.</span> <span class="toc-text">15.1. 表示性错误</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-附录"><span class="toc-number">16.</span> <span class="toc-text">16. 附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-交互模式"><span class="toc-number">16.1.</span> <span class="toc-text">16.1. 交互模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-错误处理"><span class="toc-number">16.1.1.</span> <span class="toc-text">16.1.1. 错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-可执行的Python脚本"><span class="toc-number">16.1.2.</span> <span class="toc-text">16.1.2. 可执行的Python脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-3-交互式启动文件"><span class="toc-number">16.1.3.</span> <span class="toc-text">16.1.3. 交互式启动文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-4-定制模块"><span class="toc-number">16.1.4.</span> <span class="toc-text">16.1.4. 定制模块</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover5.gif)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">彭彭和丁满</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-folder-open"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/front/"><i class="fa-fw fa fa-link"></i><span> 导航</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">python入门教程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-24 15:39:46"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-03-24 15:39:46"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-03-24</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">54.6k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 209 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/b23cbeff.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/b23cbeff.html" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>转自python管方文档：<a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/tutorial/index.html</a></p>
<h1 id="1-课前甜点"><a href="#1-课前甜点" class="headerlink" title="1. 课前甜点"></a>1. 课前甜点</h1><p>如果你经常在电脑上工作，总会有些任务会想让它自动化。比如，对一大堆文本文件进行查找替换，对很多照片文件按照比较复杂的规则重命名并放入不同的文件夹。也可能你想写一个小型的数据库应用，一个特定的界面应用，或者一个简单的游戏。</p>
<p>如果你是专业的软件开发人员，你可能需要编写一些C/C++/Java库，但总觉得通常的开发的流程（编写、编译、测试、再次编译等）太慢了。可能给这样的库写一组测试，就是很麻烦的工作了。或许你写了个软件，可以支持插件扩展语言，但你不想为了自己这一个应用，专门设计和实现一种新语言了。</p>
<p>那么，Python正好能满足你的需要。</p>
<p>对于这些任务，你也可以写Unix脚本或者Windows批处理完成，但是shell脚本最擅长移动文件和替换文本，并不适合GUI界面或者游戏开发。你可以写一个C/C++/Java程序，但是可能第一版本的草稿都要很长的开发时间。Python的使用则更加简单，可以在Windows，Mac OS X，以及Unix操作系统上使用，而且可以帮你更快地完成工作。</p>
<p>Python很容易使用，但它是一种真正的编程语言，提供了很多数据结构，也支持大型程序，远超shell脚本或批处理文件的功能。Python还提供比C语言更多的错误检查，而且作为一种“超高级语言”，它有高级的内置数据类型，比如灵活的数组和字典。正因为这些更加通用的数据类型，Python能够应付更多的问题，超过Awk甚至Perl，而且很多东西在Python中至少和那些语言同样简单。</p>
<p>Python 允许你划分程序模块，在其他的 Python 程序中重用。它内置了很多的标准模块，你可以在此基础上开发程序——也可以作为例子，开始学习 Python 编程。例如，文件输入输出，系统调用，套接字，甚至图形界面接口工作包比如 Tk 。</p>
<p>Python是一种解释型语言，在程序开发阶段可以为你节省大量时间，因为不需要编译和链接。解释器可以交互式使用，这样就可以方便地尝试语言特性，写一些一次性的程序，或者在自底向上的程序开发中测试功能。它也是一个顺手的桌面计算器。</p>
<p>Python程序的书写是紧凑而易读的。Python代码通常比同样功能的C，C++，Java代码要短很多，原因列举如下：</p>
<ul>
<li>高级数据类型允许在一个表达式中表示复杂的操作；</li>
<li>代码块的划分是按照缩进而不是成对的花括号；</li>
<li>不需要预先定义变量或参数。</li>
</ul>
<p>Python是“可扩展的”：如果你知道怎么写C语言程序，就能很容易地给解释器添加新的内置函数或模块，不论是让关键的程序以最高速度运行，还是把Python程序链接到只提供预编译程序的库（比如硬件相关的图形库）。一旦你真正链接上了，就能在Python解释器中扩展或者控制C语言编写的应用了。</p>
<p>顺便提一下，这种语言的名字（Python意为“蟒蛇”）来自于BBC节目“Monty Python的飞行马戏团”，而与爬行动物没有关系。在文档中用Monty Python来开玩笑不只是可以的，还是推荐的！</p>
<p>现在你已经对Python跃跃欲试了，想要深入了解一些细节了。因为学习语言的最佳方式是使用它，本教程邀请你一边阅读，一边在Python解释器中玩耍。</p>
<p>在下一章节，会讲解使用解释器的方法。看起来相当枯燥，但是对于尝试后续的例子来说，是非常关键的。</p>
<p>教程的其他部分将通过示例介绍Python语言和系统中的不同功能，开始是比较简单的表达式、语句和数据类型，然后是函数和模块，最终接触一些高级概念，比如异常、用户定义的类。</p>
<h1 id="2-使用-Python-解释器"><a href="#2-使用-Python-解释器" class="headerlink" title="2. 使用 Python 解释器"></a>2. 使用 Python 解释器</h1><h2 id="2-1-调用解释器"><a href="#2-1-调用解释器" class="headerlink" title="2.1. 调用解释器"></a>2.1. 调用解释器</h2><p>Python 解释器在其被使用的机器上通常安装为 <code>/usr/local/bin/python3.8</code>；将 <code>/usr/local/bin</code> 加入你的 Unix 终端的搜索路径就可以通过键入以下命令来启动它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3.8</span><br></pre></td></tr></table></figure>

<p>就能运行了 <a href="https://docs.python.org/zh-cn/3/tutorial/interpreter.html#id2" target="_blank" rel="noopener">1</a> 。安装时可以选择安装目录，所以解释器也可能在别的地方；可以问问你身边的 Python 大牛，或者你的系统管理员。（比如 <code>/usr/local/python</code> 也是比较常用的备选路径）</p>
<p>在 Windows 机器上当你从 <a href="https://docs.python.org/zh-cn/3/using/windows.html#windows-store" target="_blank" rel="noopener">Microsoft Store</a> 安装 Python 之后，<code>python3.8</code> 命令将可使用。 如果你安装了 <a href="https://docs.python.org/zh-cn/3/using/windows.html#launcher" target="_blank" rel="noopener">py.exe 启动器</a>，你将可以使用 <code>py</code> 命令。 参阅 <a href="https://docs.python.org/zh-cn/3/using/windows.html#setting-envvars" target="_blank" rel="noopener">附录：设置环境变量</a> 了解其他启动 Python 的方式。</p>
<p>在主提示符中输入文件结束字符（在 Unix 系统中是 Control-D，Windows 系统中是 Control-Z）就退出解释器并返回退出状态为0。如果这样不管用，你还可以写这个命令退出：<code>quit()</code>。</p>
<p>解释器的行编辑功能在支持 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html" target="_blank" rel="noopener">GNU Readline</a> 库的系统中也包括交互式编辑，历史替换和代码补全等。 检测是否支持行编辑最快速的方式是在首次出现 Python 提示符时输入 Control-P。 如果听到“哔”提示音，就说明支持行编辑；请参阅附录 <a href="https://docs.python.org/zh-cn/3/tutorial/interactive.html#tut-interacting" target="_blank" rel="noopener">交互式编辑和编辑历史</a> 了解有关功能键的介绍。 如果什么都没发生，或是回显了 <code>^P</code>，说明不支持行编辑；你只能用退格键从当前行中删除字符。</p>
<p>解释器运行的时候有点像 Unix 命令行：在一个标准输入 tty 设备上调用，它能交互式地读取和执行命令；调用时提供文件名参数，或者有个文件重定向到标准输入的话，它就会读取和执行文件中的 <em>脚本</em>。</p>
<p>另一种启动解释器的方式是 <code>python -c command [arg] ...</code>，其中 <em>command</em> 要换成想执行的指令，就像命令行的 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-c" target="_blank" rel="noopener"><code>-c</code></a> 选项。由于 Python 代码中经常会包含对终端来说比较特殊的字符，通常情况下都建议用英文单引号把 <em>command</em> 括起来。</p>
<p>有些 Python 模块也可以作为脚本使用。可以这样输入：<code>python -m module [arg] ...</code>，这会执行 <em>module</em> 的源文件，就跟你在命令行把路径写全了一样。</p>
<p>在运行脚本的时候，有时可能也会需要在运行后进入交互模式。这种时候在文件参数前，加上选项 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-i" target="_blank" rel="noopener"><code>-i</code></a> 就可以了。</p>
<p>关于所有的命令行选项，请参考 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#using-on-general" target="_blank" rel="noopener">命令行与环境</a>。</p>
<h3 id="2-1-1-传入参数"><a href="#2-1-1-传入参数" class="headerlink" title="2.1.1. 传入参数"></a>2.1.1. 传入参数</h3><p>如果可能的话，解释器会读取命令行参数，转化为字符串列表存入 <code>sys</code> 模块中的 <code>argv</code> 变量中。执行命令 <code>import sys</code> 你可以导入这个模块并访问这个列表。这个列表最少也会有一个元素；如果没有给定输入参数，<code>sys.argv[0]</code> 就是个空字符串。如果脚本名是标准输入，<code>sys.argv[0]</code> 就是 <code>&#39;-&#39;</code>。使用 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-c" target="_blank" rel="noopener"><code>-c</code></a> <em>command</em> 时，<code>sys.argv[0]</code> 就会是 <code>&#39;-c&#39;</code>。如果使用选项 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-m" target="_blank" rel="noopener"><code>-m</code></a> <em>module*，<code>sys.argv[0]</code> 就是包含目录的模块全名。在 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-c" target="_blank" rel="noopener"><code>-c</code></a> *command</em> 或 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-m" target="_blank" rel="noopener"><code>-m</code></a> <em>module</em> 之后的选项不会被解释器处理，而会直接留在 <code>sys.argv</code> 中给命令或模块来处理。</p>
<h3 id="2-1-2-交互模式"><a href="#2-1-2-交互模式" class="headerlink" title="2.1.2. 交互模式"></a>2.1.2. 交互模式</h3><p>在终端（tty）输入并执行指令时，我们说解释器是运行在 <em>交互模式（interactive mode）</em>。在这种模式中，它会显示 <em>主提示符（primary prompt）</em>，提示输入下一条指令，通常用三个大于号（<code>&gt;&gt;&gt;</code>）表示；连续输入行的时候，它会显示 <em>次要提示符</em>，默认是三个点（<code>...</code>）。进入解释器时，它会先显示欢迎信息、版本信息、版权声明，然后就会出现提示符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3.8</span><br><span class="line">Python 3.8 (default, Sep 16 2015, 09:25:04)</span><br><span class="line">[GCC 4.8.2] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>多行指令需要在连续的多行中输入。比如，以 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 为例：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; the_world_is_flat &#x3D; True</span><br><span class="line">&gt;&gt;&gt; if the_world_is_flat:</span><br><span class="line">...     print(&quot;Be careful not to fall off!&quot;)</span><br><span class="line">...</span><br><span class="line">Be careful not to fall off!</span><br></pre></td></tr></table></figure>

<p>有关交互模式的更多内容，请参考 <a href="https://docs.python.org/zh-cn/3/tutorial/appendix.html#tut-interac" target="_blank" rel="noopener">交互模式</a>。</p>
<h2 id="2-2-解释器的运行环境"><a href="#2-2-解释器的运行环境" class="headerlink" title="2.2. 解释器的运行环境"></a>2.2. 解释器的运行环境</h2><h3 id="2-2-1-源文件的字符编码"><a href="#2-2-1-源文件的字符编码" class="headerlink" title="2.2.1. 源文件的字符编码"></a>2.2.1. 源文件的字符编码</h3><p>默认情况下，Python 源码文件以 UTF-8 编码方式处理。在这种编码方式中，世界上大多数语言的字符都可以同时用于字符串字面值、变量或函数名称以及注释中——尽管标准库中只用常规的 ASCII 字符作为变量或函数名，而且任何可移植的代码都应该遵守此约定。要正确显示这些字符，你的编辑器必须能识别 UTF-8 编码，而且必须使用能支持打开的文件中所有字符的字体。</p>
<p>如果不使用默认编码，要声明文件所使用的编码，文件的 <em>第一</em> 行要写成特殊的注释。语法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: encoding -*-</span><br></pre></td></tr></table></figure>

<p>其中 <em>encoding</em> 可以是 Python 支持的任意一种 <a href="https://docs.python.org/zh-cn/3/library/codecs.html#module-codecs" target="_blank" rel="noopener"><code>codecs</code></a>。</p>
<p>比如，要声明使用 Windows-1252 编码，你的源码文件要写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: cp1252 -*-</span><br></pre></td></tr></table></figure>

<p>关于 <em>第一行</em> 规则的一种例外情况是，源码以 <a href="https://docs.python.org/zh-cn/3/tutorial/appendix.html#tut-scripts" target="_blank" rel="noopener">UNIX “shebang” 行</a> 开头。这种情况下，编码声明就要写在文件的第二行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: cp1252 -*-</span><br></pre></td></tr></table></figure>

<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/interpreter.html#id1" target="_blank" rel="noopener">1</a></p>
<p>在Unix系统中，Python 3.x解释器默认安装后的执行文件并不叫作 <code>python</code>，这样才不会与同时安装的Python 2.x冲突。</p>
</li>
</ul>
<h1 id="3-Python-的非正式介绍"><a href="#3-Python-的非正式介绍" class="headerlink" title="3. Python 的非正式介绍"></a>3. Python 的非正式介绍</h1><p>在下面的例子中，通过提示符 (<a href="https://docs.python.org/zh-cn/3/glossary.html#term-0" target="_blank" rel="noopener">&gt;&gt;&gt;</a> 与 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-1" target="_blank" rel="noopener">…</a>) 的出现与否来区分输入和输出：如果你想复现这些例子，当提示符出现后，你必须在提示符后键入例子中的每一个词；不以提示符开头的那些行是解释器的输出。注意例子中某行中出现第二个提示符意味着你必须键入一个空白行；这是用来结束多行命令的。</p>
<p>这个手册中的许多例子都包含注释，甚至交互性命令中也有。Python中的注释以井号 <code>#</code> 开头，并且一直延伸到该文本行结束为止。注释可以出现在一行的开头或者是空白和代码的后边，但是不能出现在字符串中间。字符串中的井号就是井号。因为注释是用来阐明代码的，不会被 Python 解释，所以在键入这些例子时，注释是可以被忽略的。</p>
<p>几个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># this is the first comment</span><br><span class="line">spam &#x3D; 1  # and this is the second comment</span><br><span class="line">          # ... and now a third!</span><br><span class="line">text &#x3D; &quot;# This is not a comment because it&#39;s inside quotes.&quot;</span><br></pre></td></tr></table></figure>



<h2 id="3-1-Python-作为计算器使用"><a href="#3-1-Python-作为计算器使用" class="headerlink" title="3.1. Python 作为计算器使用"></a>3.1. Python 作为计算器使用</h2><p>让我们尝试一些简单的 Python 命令。启动解释器，等待界面中的提示符，<code>&gt;&gt;&gt;</code> （这应该花不了多少时间）。</p>
<h3 id="3-1-1-数字"><a href="#3-1-1-数字" class="headerlink" title="3.1.1. 数字"></a>3.1.1. 数字</h3><p>解释器就像一个简单的计算器一样：你可以在里面输入一个表达式然后它会写出答案。 表达式的语法很直接：运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 的用法和其他大部分语言一样（比如 Pascal 或者 C 语言）；括号 (<code>()</code>) 用来分组。比如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 + 2</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 50 - 5*6</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; (50 - 5*6) &#x2F; 4</span><br><span class="line">5.0</span><br><span class="line">&gt;&gt;&gt; 8 &#x2F; 5  # division always returns a floating point number</span><br><span class="line">1.6</span><br></pre></td></tr></table></figure>

<p>整数（比如 <code>2</code>、<code>4</code>、<code>20</code> ）的类型是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>，有小数部分的（比如 <code>5.0</code>、<code>1.6</code> ）的类型是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>。 在这个手册的后半部分我们会看到更多的数字类型。</p>
<p>除法运算 (<code>/</code>) 永远返回浮点数类型。如果要做 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-floor-division" target="_blank" rel="noopener">floor division</a> 得到一个整数结果（忽略小数部分）你可以使用 <code>//</code> 运算符；如果要计算余数，可以使用 <code>%</code></p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 17 &#x2F; 3  # classic division returns a float</span><br><span class="line">5.666666666666667</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; 17 &#x2F;&#x2F; 3  # floor division discards the fractional part</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; 17 % 3  # the % operator returns the remainder of the division</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 5 * 3 + 2  # result * divisor + remainder</span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<p>在Python中，可以使用 <code>**</code> 运算符来计算乘方 <a href="https://docs.python.org/zh-cn/3/tutorial/introduction.html#id3" target="_blank" rel="noopener">1</a></p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 ** 2  # 5 squared</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; 2 ** 7  # 2 to the power of 7</span><br><span class="line">128</span><br></pre></td></tr></table></figure>

<p>等号 (<code>=</code>) 用于给一个变量赋值。然后在下一个交互提示符之前不会有结果显示出来:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; width &#x3D; 20</span><br><span class="line">&gt;&gt;&gt; height &#x3D; 5 * 9</span><br><span class="line">&gt;&gt;&gt; width * height</span><br><span class="line">900</span><br></pre></td></tr></table></figure>

<p>如果一个变量未定义(未赋值)，试图使用它时会向你提示错误:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n  # try to access an undefined variable</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &#39;n&#39; is not defined</span><br></pre></td></tr></table></figure>

<p>Python中提供浮点数的完整支持；包含多种混合类型运算数的运算会把整数转换为浮点数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 4 * 3.75 - 1</span><br><span class="line">14.0</span><br></pre></td></tr></table></figure>

<p>在交互模式下，上一次打印出来的表达式被赋值给变量 <code>_</code>。这意味着当你把Python用作桌面计算器时，继续计算会相对简单，比如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tax &#x3D; 12.5 &#x2F; 100</span><br><span class="line">&gt;&gt;&gt; price &#x3D; 100.50</span><br><span class="line">&gt;&gt;&gt; price * tax</span><br><span class="line">12.5625</span><br><span class="line">&gt;&gt;&gt; price + _</span><br><span class="line">113.0625</span><br><span class="line">&gt;&gt;&gt; round(_, 2)</span><br><span class="line">113.06</span><br></pre></td></tr></table></figure>

<p>这个变量应该被使用者当作是只读类型。不要向它显式地赋值——你会创建一个和它名字相同独立的本地变量，它会使用魔法行为屏蔽内部变量。</p>
<p>除了 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>，Python也支持其他类型的数字，例如 <a href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 或者 <a href="https://docs.python.org/zh-cn/3/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a>。Python 也内置对 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typesnumeric" target="_blank" rel="noopener">复数</a> 的支持，使用后缀 <code>j</code> 或者 <code>J</code> 就可以表示虚数部分（例如 <code>3+5j</code> ）。</p>
<h3 id="3-1-2-字符串"><a href="#3-1-2-字符串" class="headerlink" title="3.1.2. 字符串"></a>3.1.2. 字符串</h3><p>除了数字，Python 也可以操作字符串。字符串有多种形式，可以使用单引号（<code>&#39;……&#39;</code>），双引号（<code>&quot;……&quot;</code>）都可以获得同样的结果 <a href="https://docs.python.org/zh-cn/3/tutorial/introduction.html#id4" target="_blank" rel="noopener">2</a>。反斜杠 <code>\</code> 可以用来转义:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;spam eggs&#39;  # single quotes</span><br><span class="line">&#39;spam eggs&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;doesn\&#39;t&#39;  # use \&#39; to escape the single quote...</span><br><span class="line">&quot;doesn&#39;t&quot;</span><br><span class="line">&gt;&gt;&gt; &quot;doesn&#39;t&quot;  # ...or use double quotes instead</span><br><span class="line">&quot;doesn&#39;t&quot;</span><br><span class="line">&gt;&gt;&gt; &#39;&quot;Yes,&quot; they said.&#39;</span><br><span class="line">&#39;&quot;Yes,&quot; they said.&#39;</span><br><span class="line">&gt;&gt;&gt; &quot;\&quot;Yes,\&quot; they said.&quot;</span><br><span class="line">&#39;&quot;Yes,&quot; they said.&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;&quot;Isn\&#39;t,&quot; they said.&#39;</span><br><span class="line">&#39;&quot;Isn\&#39;t,&quot; they said.&#39;</span><br></pre></td></tr></table></figure>

<p>在交互式解释器中，输出的字符串外面会加上引号，特殊字符会使用反斜杠来转义。 虽然有时这看起来会与输入不一样（外面所加的引号可能会改变），但两个字符串是相同的。 如果字符串中有单引号而没有双引号，该字符串外将加双引号来表示，否则就加单引号。 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数会生成可读性更强的输出，即略去两边的引号，并且打印出经过转义的特殊字符:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;&quot;Isn\&#39;t,&quot; they said.&#39;</span><br><span class="line">&#39;&quot;Isn\&#39;t,&quot; they said.&#39;</span><br><span class="line">&gt;&gt;&gt; print(&#39;&quot;Isn\&#39;t,&quot; they said.&#39;)</span><br><span class="line">&quot;Isn&#39;t,&quot; they said.</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;First line.\nSecond line.&#39;  # \n means newline</span><br><span class="line">&gt;&gt;&gt; s  # without print(), \n is included in the output</span><br><span class="line">&#39;First line.\nSecond line.&#39;</span><br><span class="line">&gt;&gt;&gt; print(s)  # with print(), \n produces a new line</span><br><span class="line">First line.</span><br><span class="line">Second line.</span><br></pre></td></tr></table></figure>

<p>如果你不希望前置了 <code>\</code> 的字符转义成特殊字符，可以使用 <em>原始字符串</em> 方式，在引号前添加 <code>r</code> 即可:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#39;C:\some\name&#39;)  # here \n means newline!</span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line">&gt;&gt;&gt; print(r&#39;C:\some\name&#39;)  # note the r before the quote</span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure>

<p>字符串字面值可以跨行连续输入。一种方式是用三重引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 <code>\</code> 即可。如下例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;&quot;&quot;\</span><br><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname               Hostname to connect to</span><br><span class="line">&quot;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>将产生如下输出（注意最开始的换行没有包括进来）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname               Hostname to connect to</span><br></pre></td></tr></table></figure>

<p>字符串可以用 <code>+</code> 进行连接（粘到一起），也可以用 <code>*</code> 进行重复:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # 3 times &#39;un&#39;, followed by &#39;ium&#39;</span><br><span class="line">&gt;&gt;&gt; 3 * &#39;un&#39; + &#39;ium&#39;</span><br><span class="line">&#39;unununium&#39;</span><br></pre></td></tr></table></figure>

<p>相邻的两个或多个 <em>字符串字面值</em> （引号引起来的字符）将会自动连接到一起.</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Py&#39; &#39;thon&#39;</span><br><span class="line">&#39;Python&#39;</span><br></pre></td></tr></table></figure>

<p>把很长的字符串拆开分别输入的时候尤其有用:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text &#x3D; (&#39;Put several strings within parentheses &#39;</span><br><span class="line">...         &#39;to have them joined together.&#39;)</span><br><span class="line">&gt;&gt;&gt; text</span><br><span class="line">&#39;Put several strings within parentheses to have them joined together.&#39;</span><br></pre></td></tr></table></figure>

<p>只能对两个字面值这样操作，变量或表达式不行:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; prefix &#x3D; &#39;Py&#39;</span><br><span class="line">&gt;&gt;&gt; prefix &#39;thon&#39;  # can&#39;t concatenate a variable and a string literal</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    prefix &#39;thon&#39;</span><br><span class="line">                ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; (&#39;un&#39; * 3) &#39;ium&#39;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    (&#39;un&#39; * 3) &#39;ium&#39;</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>如果你想连接变量，或者连接变量和字面值，可以用 <code>+</code> 号:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; prefix + &#39;thon&#39;</span><br><span class="line">&#39;Python&#39;</span><br></pre></td></tr></table></figure>

<p>字符串是可以被 <em>索引</em> （下标访问）的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word &#x3D; &#39;Python&#39;</span><br><span class="line">&gt;&gt;&gt; word[0]  # character in position 0</span><br><span class="line">&#39;P&#39;</span><br><span class="line">&gt;&gt;&gt; word[5]  # character in position 5</span><br><span class="line">&#39;n&#39;</span><br></pre></td></tr></table></figure>

<p>索引也可以用负数，这种会从右边开始数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word[-1]  # last character</span><br><span class="line">&#39;n&#39;</span><br><span class="line">&gt;&gt;&gt; word[-2]  # second-last character</span><br><span class="line">&#39;o&#39;</span><br><span class="line">&gt;&gt;&gt; word[-6]</span><br><span class="line">&#39;P&#39;</span><br></pre></td></tr></table></figure>

<p>注意 -0 和 0 是一样的，所以负数索引从 -1 开始。</p>
<p>除了索引，字符串还支持 <em>切片*。索引可以得到单个字符，而 *切片</em> 可以获取子字符串:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word[0:2]  # characters from position 0 (included) to 2 (excluded)</span><br><span class="line">&#39;Py&#39;</span><br><span class="line">&gt;&gt;&gt; word[2:5]  # characters from position 2 (included) to 5 (excluded)</span><br><span class="line">&#39;tho&#39;</span><br></pre></td></tr></table></figure>

<p>注意切片的开始总是被包括在结果中，而结束不被包括。这使得 <code>s[:i] + s[i:]</code> 总是等于 <code>s</code></p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word[:2] + word[2:]</span><br><span class="line">&#39;Python&#39;</span><br><span class="line">&gt;&gt;&gt; word[:4] + word[4:]</span><br><span class="line">&#39;Python&#39;</span><br></pre></td></tr></table></figure>

<p>切片的索引有默认值；省略开始索引时默认为0，省略结束索引时默认为到字符串的结束:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word[:2]   # character from the beginning to position 2 (excluded)</span><br><span class="line">&#39;Py&#39;</span><br><span class="line">&gt;&gt;&gt; word[4:]   # characters from position 4 (included) to the end</span><br><span class="line">&#39;on&#39;</span><br><span class="line">&gt;&gt;&gt; word[-2:]  # characters from the second-last (included) to the end</span><br><span class="line">&#39;on&#39;</span><br></pre></td></tr></table></figure>

<p>您也可以这么理解切片：将索引视作指向字符 <em>之间</em> ，第一个字符的左侧标为0，最后一个字符的右侧标为 <em>n</em> ，其中 <em>n</em> 是字符串长度。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> +---+---+---+---+---+---+</span><br><span class="line"> | P | y | t | h | o | n |</span><br><span class="line"> +---+---+---+---+---+---+</span><br><span class="line"> 0   1   2   3   4   5   6</span><br><span class="line">-6  -5  -4  -3  -2  -1</span><br></pre></td></tr></table></figure>

<p>第一行数标注了字符串非负的索引的位置，第二行标注了对应的负的索引。那么从 <em>i</em> 到 <em>j</em> 的切片就包括了标有 <em>i</em> 和 <em>j</em> 的位置之间的所有字符。</p>
<p>对于使用非负索引的切片，如果索引不越界，那么得到的切片长度就是起止索引之差。例如， <code>word[1:3]</code> 的长度为2.</p>
<p>使用过大的索引会产生一个错误:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word[42]  # the word only has 6 characters</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: string index out of range</span><br></pre></td></tr></table></figure>

<p>但是，切片中的越界索引会被自动处理:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word[4:42]</span><br><span class="line">&#39;on&#39;</span><br><span class="line">&gt;&gt;&gt; word[42:]</span><br><span class="line">&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>Python 中的字符串不能被修改，它们是 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-immutable" target="_blank" rel="noopener">immutable</a> 的。因此，向字符串的某个索引位置赋值会产生一个错误:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; word[0] &#x3D; &#39;J&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#39;str&#39; object does not support item assignment</span><br><span class="line">&gt;&gt;&gt; word[2:] &#x3D; &#39;py&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#39;str&#39; object does not support item assignment</span><br></pre></td></tr></table></figure>

<p>如果需要一个不同的字符串，应当新建一个:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;J&#39; + word[1:]</span><br><span class="line">&#39;Jython&#39;</span><br><span class="line">&gt;&gt;&gt; word[:2] + &#39;py&#39;</span><br><span class="line">&#39;Pypy&#39;</span><br></pre></td></tr></table></figure>

<p>内建函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 返回一个字符串的长度:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &#39;supercalifragilisticexpialidocious&#39;</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">34</span><br></pre></td></tr></table></figure>

<p>参见</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#textseq" target="_blank" rel="noopener">文本序列类型 — str</a></p>
<p>字符串是一种 <em>序列类型</em> ，因此也支持序列类型的各种操作。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#string-methods" target="_blank" rel="noopener">字符串的方法</a></p>
<p>字符串支持许多变换和查找的方法。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings" target="_blank" rel="noopener">格式化字符串字面值</a></p>
<p>内嵌表达式的字符串字面值。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/string.html#formatstrings" target="_blank" rel="noopener">格式字符串语法</a></p>
<p>使用 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 进行字符串格式化。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting" target="_blank" rel="noopener">printf 风格的字符串格式化</a></p>
<p>这里详述了使用 <code>%</code> 运算符进行字符串格式化。</p>
</li>
</ul>
<h3 id="3-1-3-列表"><a href="#3-1-3-列表" class="headerlink" title="3.1.3. 列表"></a>3.1.3. 列表</h3><p>Python 中可以通过组合一些值得到多种 <em>复合</em> 数据类型。其中最常用的 <em>列表</em> ，可以通过方括号括起、逗号分隔的一组值得到。一个 <em>列表</em> 可以包含不同类型的元素，但通常使用时各个元素类型相同:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squares &#x3D; [1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; squares</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure>

<p>和字符串（以及各种内置的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-sequence" target="_blank" rel="noopener">sequence</a> 类型）一样，列表也支持索引和切片:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squares[0]  # indexing returns the item</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; squares[-1]</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; squares[-3:]  # slicing returns a new list</span><br><span class="line">[9, 16, 25]</span><br></pre></td></tr></table></figure>

<p>所有的切片操作都返回一个包含所请求元素的新列表。 这意味着以下切片操作会返回列表的一个 <a href="https://docs.python.org/zh-cn/3/library/copy.html#shallow-vs-deep-copy" target="_blank" rel="noopener">浅拷贝</a>:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squares[:]</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure>

<p>列表同样支持拼接操作:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squares + [36, 49, 64, 81, 100]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>与 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-immutable" target="_blank" rel="noopener">immutable</a> 的字符串不同, 列表是一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable" target="_blank" rel="noopener">mutable</a> 类型，就是说，它自己的内容可以改变:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; cubes &#x3D; [1, 8, 27, 65, 125]  # something&#39;s wrong here</span><br><span class="line">&gt;&gt;&gt; 4 ** 3  # the cube of 4 is 64, not 65!</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; cubes[3] &#x3D; 64  # replace the wrong value</span><br><span class="line">&gt;&gt;&gt; cubes</span><br><span class="line">[1, 8, 27, 64, 125]</span><br></pre></td></tr></table></figure>

<p>你也可以在列表结尾，通过 <code>append()</code> <em>方法</em> 添加新元素 (我们会在后面解释更多关于方法的内容):</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; cubes.append(216)  # add the cube of 6</span><br><span class="line">&gt;&gt;&gt; cubes.append(7 ** 3)  # and the cube of 7</span><br><span class="line">&gt;&gt;&gt; cubes</span><br><span class="line">[1, 8, 27, 64, 125, 216, 343]</span><br></pre></td></tr></table></figure>

<p>给切片赋值也是可以的，这样甚至可以改变列表大小，或者把列表整个清空:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; letters &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span><br><span class="line">&gt;&gt;&gt; letters</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</span><br><span class="line">&gt;&gt;&gt; # replace some values</span><br><span class="line">&gt;&gt;&gt; letters[2:5] &#x3D; [&#39;C&#39;, &#39;D&#39;, &#39;E&#39;]</span><br><span class="line">&gt;&gt;&gt; letters</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;f&#39;, &#39;g&#39;]</span><br><span class="line">&gt;&gt;&gt; # now remove them</span><br><span class="line">&gt;&gt;&gt; letters[2:5] &#x3D; []</span><br><span class="line">&gt;&gt;&gt; letters</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;f&#39;, &#39;g&#39;]</span><br><span class="line">&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list</span><br><span class="line">&gt;&gt;&gt; letters[:] &#x3D; []</span><br><span class="line">&gt;&gt;&gt; letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 也可以作用到列表上:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; letters &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br><span class="line">&gt;&gt;&gt; len(letters)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>也可以嵌套列表 (创建包含其他列表的列表), 比如说:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">&gt;&gt;&gt; n &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; x &#x3D; [a, n]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]]</span><br><span class="line">&gt;&gt;&gt; x[0]</span><br><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line">&gt;&gt;&gt; x[0][1]</span><br><span class="line">&#39;b&#39;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-走向编程的第一步"><a href="#3-2-走向编程的第一步" class="headerlink" title="3.2. 走向编程的第一步"></a>3.2. 走向编程的第一步</h2><p>当然，我们可以将 Python 用于更复杂的任务，而不是仅仅两个和两个一起添加。 例如，我们可以编写 <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">斐波那契数列</a> 的初始子序列，如下所示:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # Fibonacci series:</span><br><span class="line">... # the sum of two elements defines the next</span><br><span class="line">... a, b &#x3D; 0, 1</span><br><span class="line">&gt;&gt;&gt; while a &lt; 10:</span><br><span class="line">...     print(a)</span><br><span class="line">...     a, b &#x3D; b, a+b</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>这个例子引入了几个新的特点。</p>
<ul>
<li><p>第一行含有一个 <em>多重赋值</em>: 变量 <code>a</code> 和 <code>b</code> 同时得到了新值 0 和 1. 最后一行又用了一次多重赋值, 这体现出了右手边的表达式，在任何赋值发生之前就被求值了。右手边的表达式是从左到右被求值的。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> 循环只要它的条件（这里指： <code>a &lt; 10</code>）保持为真就会一直执行。Python 和 C 一样，任何非零整数都为真；零为假。这个条件也可以是字符串或是列表的值，事实上任何序列都可以；长度非零就为真，空序列就为假。在这个例子里，判断条件是一个简单的比较。标准的比较操作符的写法和 C 语言里是一样： <code>&lt;</code> （小于）、 <code>&gt;</code> （大于）、 <code>==</code> （等于）、 <code>&lt;=</code> （小于或等于)、 <code>&gt;=</code> （大于或等于）以及 <code>!=</code> （不等于）。</p>
</li>
<li><p><em>循环体</em> 是 <em>缩进的</em> ：缩进是 Python 组织语句的方式。在交互式命令行里，你得给每个缩进的行敲下 Tab 键或者（多个）空格键。实际上用文本编辑器的话，你要准备更复杂的输入方式；所有像样的文本编辑器都有自动缩进的设置。交互式命令行里，当一个组合的语句输入时, 需要在最后敲一个空白行表示完成（因为语法分析器猜不出来你什么时候打的是最后一行）。注意，在同一块语句中的每一行，都要缩进相同的长度。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数将所有传进来的参数值打印出来. 它和直接输入你要显示的表达式(比如我们之前在计算器的例子里做的)不一样， print() 能处理多个参数，包括浮点数，字符串。 字符串会打印不带引号的内容, 并且在参数项之间会插入一个空格, 这样你就可以很好的把东西格式化, 像这样:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i &#x3D; 256*256</span><br><span class="line">&gt;&gt;&gt; print(&#39;The value of i is&#39;, i)</span><br><span class="line">The value of i is 65536</span><br></pre></td></tr></table></figure>

<p>关键字参数 <em>end</em> 可以用来取消输出后面的换行, 或是用另外一个字符串来结尾:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b &#x3D; 0, 1</span><br><span class="line">&gt;&gt;&gt; while a &lt; 1000:</span><br><span class="line">...     print(a, end&#x3D;&#39;,&#39;)</span><br><span class="line">...     a, b &#x3D; b, a+b</span><br><span class="line">...</span><br><span class="line">0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/introduction.html#id1" target="_blank" rel="noopener">1</a></p>
<p>因为 <code>**</code> 比 <code>-</code> 有更高的优先级, 所以 <code>-3**2</code> 会被解释成 <code>-(3**2)</code> ，因此结果是 <code>-9</code>. 为了避免这个并且得到结果 <code>9</code>, 你可以用这个式子 <code>(-3)**2</code>.</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/introduction.html#id2" target="_blank" rel="noopener">2</a></p>
<p>和其他语言不一样的是, 特殊字符比如说 <code>\n</code> 在单引号 (<code>&#39;...&#39;</code>) 和双引号 (<code>&quot;...&quot;</code>) 里有一样的意义. 这两种引号唯一的区别是，你不需要在单引号里转义双引号 <code>&quot;</code> (但是你必须把单引号转义成 <code>\&#39;</code>) ， 反之亦然.</p>
</li>
</ul>
<h1 id="4-其他流程控制工具"><a href="#4-其他流程控制工具" class="headerlink" title="4. 其他流程控制工具"></a>4. 其他流程控制工具</h1><p>除了刚刚介绍过的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> 语句，Python 中也会使用其他语言中常见的流程控制语句，只是稍有变化。</p>
<h2 id="4-1-if-语句"><a href="#4-1-if-语句" class="headerlink" title="4.1. if 语句"></a>4.1. <code>if</code> 语句</h2><p>可能最为人所熟知的编程语句就是 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 语句了。例如：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; int(input(&quot;Please enter an integer: &quot;))</span><br><span class="line">Please enter an integer: 42</span><br><span class="line">&gt;&gt;&gt; if x &lt; 0:</span><br><span class="line">...     x &#x3D; 0</span><br><span class="line">...     print(&#39;Negative changed to zero&#39;)</span><br><span class="line">... elif x &#x3D;&#x3D; 0:</span><br><span class="line">...     print(&#39;Zero&#39;)</span><br><span class="line">... elif x &#x3D;&#x3D; 1:</span><br><span class="line">...     print(&#39;Single&#39;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&#39;More&#39;)</span><br><span class="line">...</span><br><span class="line">More</span><br></pre></td></tr></table></figure>

<p>可以有零个或多个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#elif" target="_blank" rel="noopener"><code>elif</code></a> 部分，以及一个可选的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#else" target="_blank" rel="noopener"><code>else</code></a> 部分。 关键字 ‘<code>elif</code>‘ 是 ‘else if’ 的缩写，适合用于避免过多的缩进。 一个 <code>if</code> … <code>elif</code> … <code>elif</code> … 序列可以看作是其他语言中的 <code>switch</code> 或 <code>case</code> 语句的替代。</p>
<h2 id="4-2-for-语句"><a href="#4-2-for-语句" class="headerlink" title="4.2. for 语句"></a>4.2. <code>for</code> 语句</h2><p>Python 中的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 语句与你在 C 或 Pascal 中可能用到的有所不同。 Python 中的 <code>for</code> 语句并不总是对算术递增的数值进行迭代（如同 Pascal），或是给予用户定义迭代步骤和暂停条件的能力（如同 C），而是对任意序列进行迭代（例如列表或字符串），条目的迭代顺序与它们在序列中出现的顺序一致。 例如（此处英文为双关语）:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # Measure some strings:</span><br><span class="line">... words &#x3D; [&#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]</span><br><span class="line">&gt;&gt;&gt; for w in words:</span><br><span class="line">...     print(w, len(w))</span><br><span class="line">...</span><br><span class="line">cat 3</span><br><span class="line">window 6</span><br><span class="line">defenestrate 12</span><br></pre></td></tr></table></figure>

<p>在遍历同一个集合时修改该集合的代码可能很难获得正确的结果。通常，更直接的做法是循环遍历该集合的副本或创建新集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Strategy:  Iterate over a copy</span><br><span class="line">for user, status in users.copy().items():</span><br><span class="line">    if status &#x3D;&#x3D; &#39;inactive&#39;:</span><br><span class="line">        del users[user]</span><br><span class="line"></span><br><span class="line"># Strategy:  Create a new collection</span><br><span class="line">active_users &#x3D; &#123;&#125;</span><br><span class="line">for user, status in users.items():</span><br><span class="line">    if status &#x3D;&#x3D; &#39;active&#39;:</span><br><span class="line">        active_users[user] &#x3D; status</span><br></pre></td></tr></table></figure>



<h2 id="4-3-range-函数"><a href="#4-3-range-函数" class="headerlink" title="4.3. range() 函数"></a>4.3. <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a> 函数</h2><p>如果你确实需要遍历一个数字序列，内置函数 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a> 会派上用场。它生成算术级数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in range(5):</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>给定的终止数值并不在要生成的序列里；<code>range(10)</code> 会生成10个值，并且是以合法的索引生成一个长度为10的序列。range也可以以另一个数字开头，或者以指定的幅度增加（甚至是负数；有时这也被叫做 ‘步进’）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">range(5, 10)</span><br><span class="line">   5, 6, 7, 8, 9</span><br><span class="line"></span><br><span class="line">range(0, 10, 3)</span><br><span class="line">   0, 3, 6, 9</span><br><span class="line"></span><br><span class="line">range(-10, -100, -30)</span><br><span class="line">  -10, -40, -70</span><br></pre></td></tr></table></figure>

<p>要以序列的索引来迭代，您可以将 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 组合如下:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [&#39;Mary&#39;, &#39;had&#39;, &#39;a&#39;, &#39;little&#39;, &#39;lamb&#39;]</span><br><span class="line">&gt;&gt;&gt; for i in range(len(a)):</span><br><span class="line">...     print(i, a[i])</span><br><span class="line">...</span><br><span class="line">0 Mary</span><br><span class="line">1 had</span><br><span class="line">2 a</span><br><span class="line">3 little</span><br><span class="line">4 lamb</span><br></pre></td></tr></table></figure>

<p>然而，在大多数这类情况下，使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 函数比较方便，请参见 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-loopidioms" target="_blank" rel="noopener">循环的技巧</a> 。</p>
<p>如果你只打印 range，会出现奇怪的结果:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(range(10))</span><br><span class="line">range(0, 10)</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a> 所返回的对象在许多方面表现得像一个列表，但实际上却并不是。此对象会在你迭代它时基于所希望的序列返回连续的项，但它没有真正生成列表，这样就能节省空间。</p>
<p>我们称这样对象为 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a>，也就是说，适合作为这样的目标对象：函数和结构期望中从获取连续的项直到所提供的项全部耗尽。 我们已经看到 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 语句就是这样一种结构，而接受可迭代对象的函数的一个例子是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sum" target="_blank" rel="noopener"><code>sum()</code></a>:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(range(4))  # 0 + 1 + 2 + 3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>稍后我们将看到更多返回可迭代对象以及将可迭代对象作为参数的函数。 最后，也许你会很好奇如何从一个指定范围内获取一个列表。 以下是解决方案：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(4))</span><br><span class="line">[0, 1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>在 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-structures" target="_blank" rel="noopener">数据结构</a> 章节中，我们将讨论 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list()</code></a> 的更多细节。</p>
<h2 id="4-4-break-和-continue-语句，以及循环中的-else-子句"><a href="#4-4-break-和-continue-语句，以及循环中的-else-子句" class="headerlink" title="4.4. break 和 continue 语句，以及循环中的 else 子句"></a>4.4. <code>break</code> 和 <code>continue</code> 语句，以及循环中的 <code>else</code> 子句</h2><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 语句，和 C 中的类似，用于跳出最近的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> 循环.</p>
<p>循环语句可能带有 <code>else</code> 子句；它会在循环耗尽了可迭代对象 (使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a>) 或循环条件变为假值 (使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a>) 时被执行，但不会在循环被 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 语句终止时被执行。 以下搜索素数的循环就是这样的一个例子:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in range(2, 10):</span><br><span class="line">...     for x in range(2, n):</span><br><span class="line">...         if n % x &#x3D;&#x3D; 0:</span><br><span class="line">...             print(n, &#39;equals&#39;, x, &#39;*&#39;, n&#x2F;&#x2F;x)</span><br><span class="line">...             break</span><br><span class="line">...     else:</span><br><span class="line">...         # loop fell through without finding a factor</span><br><span class="line">...         print(n, &#39;is a prime number&#39;)</span><br><span class="line">...</span><br><span class="line">2 is a prime number</span><br><span class="line">3 is a prime number</span><br><span class="line">4 equals 2 * 2</span><br><span class="line">5 is a prime number</span><br><span class="line">6 equals 2 * 3</span><br><span class="line">7 is a prime number</span><br><span class="line">8 equals 2 * 4</span><br><span class="line">9 equals 3 * 3</span><br></pre></td></tr></table></figure>

<p>（是的，这是正确的代码。仔细看： <code>else</code> 子句属于 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 循环， <strong>不属于</strong> <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 语句。）</p>
<p>当和循环一起使用时，<code>else</code> 子句与 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中的 <code>else</code> 子句的共同点多于 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 语句中的同类子句: <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中的 <code>else</code> 子句会在未发生异常时执行，而循环中的 <code>else</code> 子句则会在未发生 <code>break</code> 时执行。 有关 <code>try</code> 语句和异常的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/errors.html#tut-handling" target="_blank" rel="noopener">处理异常</a>。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 语句也是借鉴自 C 语言，表示继续循环中的下一次迭代:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for num in range(2, 10):</span><br><span class="line">...     if num % 2 &#x3D;&#x3D; 0:</span><br><span class="line">...         print(&quot;Found an even number&quot;, num)</span><br><span class="line">...         continue</span><br><span class="line">...     print(&quot;Found a number&quot;, num)</span><br><span class="line">Found an even number 2</span><br><span class="line">Found a number 3</span><br><span class="line">Found an even number 4</span><br><span class="line">Found a number 5</span><br><span class="line">Found an even number 6</span><br><span class="line">Found a number 7</span><br><span class="line">Found an even number 8</span><br><span class="line">Found a number 9</span><br></pre></td></tr></table></figure>



<h2 id="4-5-pass-语句"><a href="#4-5-pass-语句" class="headerlink" title="4.5. pass 语句"></a>4.5. <code>pass</code> 语句</h2><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#pass" target="_blank" rel="noopener"><code>pass</code></a> 语句什么也不做。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这通常用于创建最小的类:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyEmptyClass:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#pass" target="_blank" rel="noopener"><code>pass</code></a> 的另一个可以使用的场合是在你编写新的代码时作为一个函数或条件子句体的占位符，允许你保持在更抽象的层次上进行思考。 <code>pass</code> 会被静默地忽略:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def initlog(*args):</span><br><span class="line">...     pass   # Remember to implement this!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="4-6-定义函数"><a href="#4-6-定义函数" class="headerlink" title="4.6. 定义函数"></a>4.6. 定义函数</h2><p>我们可以创建一个输出任意范围内 Fibonacci 数列的函数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib(n):    # write Fibonacci series up to n</span><br><span class="line">...     &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;</span><br><span class="line">...     a, b &#x3D; 0, 1</span><br><span class="line">...     while a &lt; n:</span><br><span class="line">...         print(a, end&#x3D;&#39; &#39;)</span><br><span class="line">...         a, b &#x3D; b, a+b</span><br><span class="line">...     print()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; # Now call the function we just defined:</span><br><span class="line">... fib(2000)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</span><br></pre></td></tr></table></figure>

<p>关键字 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> 引入一个函数 <em>定义</em>。它必须后跟函数名称和带括号的形式参数列表。构成函数体的语句从下一行开始，并且必须缩进。</p>
<p>函数体的第一个语句可以（可选的）是字符串文字；这个字符串文字是函数的文档字符串或 <em>docstring</em> 。（有关文档字符串的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#tut-docstrings" target="_blank" rel="noopener">文档字符串</a> 部分）有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码；在你编写的代码中包含文档字符串是一种很好的做法，所以要养成习惯。</p>
<p>函数的 <em>执行</em> 会引入一个用于函数局部变量的新符号表。 更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。 因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句中定义的全局变量，或者是在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句中定义的外层函数的变量），尽管它们可以被引用。</p>
<p>在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；因此，实参是通过 <em>按值调用</em> 传递的（其中 <em>值</em> 始终是对象 <em>引用</em> 而不是对象的值）。<a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#id2" target="_blank" rel="noopener">1</a> 当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。</p>
<p>函数定义会把函数名引入当前的符号表中。函数名称的值具有解释器将其识别为用户定义函数的类型。这个值可以分配给另一个名称，该名称也可以作为一个函数使用。这用作一般的重命名机制:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fib</span><br><span class="line">&lt;function fib at 10042ed0&gt;</span><br><span class="line">&gt;&gt;&gt; f &#x3D; fib</span><br><span class="line">&gt;&gt;&gt; f(100)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89</span><br></pre></td></tr></table></figure>

<p>如果你学过其他语言，你可能会认为 <code>fib</code> 不是函数而是一个过程，因为它并不返回值。事实上，即使没有 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句的函数也会返回一个值，尽管它是一个相当无聊的值。这个值称为 <code>None</code> （它是内置名称）。一般来说解释器不会打印出单独的返回值 <code>None</code> ，如果你真想看到它，你可以使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a></p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fib(0)</span><br><span class="line">&gt;&gt;&gt; print(fib(0))</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<p>写一个返回斐波那契数列的列表（而不是把它打印出来）的函数，非常简单:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib2(n):  # return Fibonacci series up to n</span><br><span class="line">...     &quot;&quot;&quot;Return a list containing the Fibonacci series up to n.&quot;&quot;&quot;</span><br><span class="line">...     result &#x3D; []</span><br><span class="line">...     a, b &#x3D; 0, 1</span><br><span class="line">...     while a &lt; n:</span><br><span class="line">...         result.append(a)    # see below</span><br><span class="line">...         a, b &#x3D; b, a+b</span><br><span class="line">...     return result</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f100 &#x3D; fib2(100)    # call it</span><br><span class="line">&gt;&gt;&gt; f100                # write the result</span><br><span class="line">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span><br></pre></td></tr></table></figure>

<p>此示例中，像往常一样，演示了一些新的 Python 功能:</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句会从函数内部返回一个值。 不带表达式参数的 <code>return</code> 会返回 <code>None</code>。 函数执行完毕退出也会返回 <code>None</code>。</li>
<li><code>result.append(a)</code> 语句调用了列表对象 <code>result</code> 的 <em>方法</em> 。方法是“属于”一个对象的函数，它被命名为 <code>obj.methodname</code> ，其中 <code>obj</code> 是某个对象（也可能是一个表达式）， <code>methodname</code> 是由对象类型中定义的方法的名称。不同的类型可以定义不同的方法。不同类型的方法可以有相同的名称而不会引起歧义。（可以使用 <em>类</em> 定义自己的对象类型和方法，请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-classes" target="_blank" rel="noopener">类</a> ）示例中的方法 <code>append()</code> 是为列表对象定义的；它会在列表的最后添加一个新的元素。在这个示例中它相当于 <code>result = result + [a]</code> ，但更高效。</li>
</ul>
<h2 id="4-7-函数定义的更多形式"><a href="#4-7-函数定义的更多形式" class="headerlink" title="4.7. 函数定义的更多形式"></a>4.7. 函数定义的更多形式</h2><p>给函数定义有可变数目的参数也是可行的。这里有三种形式，可以组合使用。</p>
<h3 id="4-7-1-参数默认值"><a href="#4-7-1-参数默认值" class="headerlink" title="4.7.1. 参数默认值"></a>4.7.1. 参数默认值</h3><p>最有用的形式是对一个或多个参数指定一个默认值。这样创建的函数，可以用比定义时允许的更少的参数调用，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def ask_ok(prompt, retries&#x3D;4, reminder&#x3D;&#39;Please try again!&#39;):</span><br><span class="line">    while True:</span><br><span class="line">        ok &#x3D; input(prompt)</span><br><span class="line">        if ok in (&#39;y&#39;, &#39;ye&#39;, &#39;yes&#39;):</span><br><span class="line">            return True</span><br><span class="line">        if ok in (&#39;n&#39;, &#39;no&#39;, &#39;nop&#39;, &#39;nope&#39;):</span><br><span class="line">            return False</span><br><span class="line">        retries &#x3D; retries - 1</span><br><span class="line">        if retries &lt; 0:</span><br><span class="line">            raise ValueError(&#39;invalid user response&#39;)</span><br><span class="line">        print(reminder)</span><br></pre></td></tr></table></figure>

<p>这个函数可以通过几种方式调用:</p>
<ul>
<li>只给出必需的参数：<code>ask_ok(&#39;Do you really want to quit?&#39;)</code></li>
<li>给出一个可选的参数：<code>ask_ok(&#39;OK to overwrite the file?&#39;, 2)</code></li>
<li>或者给出所有的参数：<code>ask_ok(&#39;OK to overwrite the file?&#39;, 2, &#39;Come on, only yes or no!&#39;)</code></li>
</ul>
<p>这个示例还介绍了 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 关键字。它可以测试一个序列是否包含某个值。</p>
<p>默认值是在 <em>定义过程</em> 中在函数定义处计算的，所以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 5</span><br><span class="line"></span><br><span class="line">def f(arg&#x3D;i):</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">i &#x3D; 6</span><br><span class="line">f()</span><br></pre></td></tr></table></figure>

<p>会打印 <code>5</code>。</p>
<p><strong>重要警告：</strong> 默认值只会执行一次。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def f(a, L&#x3D;[]):</span><br><span class="line">    L.append(a)</span><br><span class="line">    return L</span><br><span class="line"></span><br><span class="line">print(f(1))</span><br><span class="line">print(f(2))</span><br><span class="line">print(f(3))</span><br></pre></td></tr></table></figure>

<p>这将打印出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1]</span><br><span class="line">[1, 2]</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>如果你不想要在后续调用之间共享默认值，你可以这样写这个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f(a, L&#x3D;None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L &#x3D; []</span><br><span class="line">    L.append(a)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure>



<h3 id="4-7-2-关键字参数"><a href="#4-7-2-关键字参数" class="headerlink" title="4.7.2. 关键字参数"></a>4.7.2. 关键字参数</h3><p>也可以使用形如 <code>kwarg=value</code> 的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-keyword-argument" target="_blank" rel="noopener">关键字参数</a> 来调用函数。例如下面的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def parrot(voltage, state&#x3D;&#39;a stiff&#39;, action&#x3D;&#39;voom&#39;, type&#x3D;&#39;Norwegian Blue&#39;):</span><br><span class="line">    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end&#x3D;&#39; &#39;)</span><br><span class="line">    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)</span><br><span class="line">    print(&quot;-- Lovely plumage, the&quot;, type)</span><br><span class="line">    print(&quot;-- It&#39;s&quot;, state, &quot;!&quot;)</span><br></pre></td></tr></table></figure>

<p>接受一个必需的参数（<code>voltage</code>）和三个可选的参数（<code>state</code>, <code>action</code>，和 <code>type</code>）。这个函数可以通过下面的任何一种方式调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">parrot(1000)                                          # 1 positional argument</span><br><span class="line">parrot(voltage&#x3D;1000)                                  # 1 keyword argument</span><br><span class="line">parrot(voltage&#x3D;1000000, action&#x3D;&#39;VOOOOOM&#39;)             # 2 keyword arguments</span><br><span class="line">parrot(action&#x3D;&#39;VOOOOOM&#39;, voltage&#x3D;1000000)             # 2 keyword arguments</span><br><span class="line">parrot(&#39;a million&#39;, &#39;bereft of life&#39;, &#39;jump&#39;)         # 3 positional arguments</span><br><span class="line">parrot(&#39;a thousand&#39;, state&#x3D;&#39;pushing up the daisies&#39;)  # 1 positional, 1 keyword</span><br></pre></td></tr></table></figure>

<p>但下面的函数调用都是无效的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">parrot()                     # required argument missing</span><br><span class="line">parrot(voltage&#x3D;5.0, &#39;dead&#39;)  # non-keyword argument after a keyword argument</span><br><span class="line">parrot(110, voltage&#x3D;220)     # duplicate value for the same argument</span><br><span class="line">parrot(actor&#x3D;&#39;John Cleese&#39;)  # unknown keyword argument</span><br></pre></td></tr></table></figure>

<p>在函数调用中，关键字参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的其中一个参数匹配（比如 <code>actor</code> 不是函数 <code>parrot</code> 的有效参数），它们的顺序并不重要。这也包括非可选参数，（比如 <code>parrot(voltage=1000)</code> 也是有效的）。不能对同一个参数多次赋值。下面是一个因为此限制而失败的例子:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def function(a):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; function(0, a&#x3D;0)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: function() got multiple values for keyword argument &#39;a&#39;</span><br></pre></td></tr></table></figure>

<p>当存在一个形式为 <code>**name</code> 的最后一个形参时，它会接收一个字典 (参见 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typesmapping" target="_blank" rel="noopener">映射类型 — dict</a>)，其中包含除了与已有形参相对应的关键字参数以外的所有关键字参数。 这可以与一个形式为 <code>*name</code>，接收一个包含除了与已有形参列表以外的位置参数的 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-tuples" target="_blank" rel="noopener">元组</a> 的形参 (将在下一小节介绍) 组合使用 (<code>*name</code> 必须出现在 <code>**name</code> 之前。) 例如，如果我们这样定义一个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def cheeseshop(kind, *arguments, **keywords):</span><br><span class="line">    print(&quot;-- Do you have any&quot;, kind, &quot;?&quot;)</span><br><span class="line">    print(&quot;-- I&#39;m sorry, we&#39;re all out of&quot;, kind)</span><br><span class="line">    for arg in arguments:</span><br><span class="line">        print(arg)</span><br><span class="line">    print(&quot;-&quot; * 40)</span><br><span class="line">    for kw in keywords:</span><br><span class="line">        print(kw, &quot;:&quot;, keywords[kw])</span><br></pre></td></tr></table></figure>

<p>它可以像这样调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cheeseshop(&quot;Limburger&quot;, &quot;It&#39;s very runny, sir.&quot;,</span><br><span class="line">           &quot;It&#39;s really very, VERY runny, sir.&quot;,</span><br><span class="line">           shopkeeper&#x3D;&quot;Michael Palin&quot;,</span><br><span class="line">           client&#x3D;&quot;John Cleese&quot;,</span><br><span class="line">           sketch&#x3D;&quot;Cheese Shop Sketch&quot;)</span><br></pre></td></tr></table></figure>

<p>当然它会打印:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- Do you have any Limburger ?</span><br><span class="line">-- I&#39;m sorry, we&#39;re all out of Limburger</span><br><span class="line">It&#39;s very runny, sir.</span><br><span class="line">It&#39;s really very, VERY runny, sir.</span><br><span class="line">----------------------------------------</span><br><span class="line">shopkeeper : Michael Palin</span><br><span class="line">client : John Cleese</span><br><span class="line">sketch : Cheese Shop Sketch</span><br></pre></td></tr></table></figure>

<p>注意打印时关键字参数的顺序保证与调用函数时提供它们的顺序是相匹配的。</p>
<h3 id="4-7-3-特殊参数"><a href="#4-7-3-特殊参数" class="headerlink" title="4.7.3. 特殊参数"></a>4.7.3. 特殊参数</h3><p>默认情况下，函数的参数传递形式可以是位置参数或是显式的关键字参数。 为了确保可读性和运行效率，限制允许的参数传递形式是有意义的，这样开发者只需查看函数定义即可确定参数项是仅按位置、按位置也按关键字，还是仅按关键字传递。</p>
<p>函数的定义看起来可以像是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def f(pos1, pos2, &#x2F;, pos_or_kwd, *, kwd1, kwd2):</span><br><span class="line">      -----------    ----------     ----------</span><br><span class="line">        |             |                  |</span><br><span class="line">        |        Positional or keyword   |</span><br><span class="line">        |                                - Keyword only</span><br><span class="line">         -- Positional only</span><br></pre></td></tr></table></figure>

<p>在这里 <code>/</code> 和 <code>*</code> 是可选的。 如果使用这些符号则表明可以通过何种形参将参数值传递给函数：仅限位置、位置或关键字，以及仅限关键字。 关键字形参也被称为命名形参。</p>
<h4 id="4-7-3-1-位置或关键字参数"><a href="#4-7-3-1-位置或关键字参数" class="headerlink" title="4.7.3.1. 位置或关键字参数"></a>4.7.3.1. 位置或关键字参数</h4><p>如果函数定义中未使用 <code>/</code> 和 <code>*</code>，则参数可以按位置或按关键字传递给函数。</p>
<h4 id="4-7-3-2-仅限位置参数"><a href="#4-7-3-2-仅限位置参数" class="headerlink" title="4.7.3.2. 仅限位置参数"></a>4.7.3.2. 仅限位置参数</h4><p>在这里还可以发现更多细节，特定形参可以被标记为 <em>仅限位置*。 如果是 *仅限位置</em> 的形参，则其位置是重要的，并且该形参不能作为关键字传入。 仅限位置形参要放在 <code>/</code> (正斜杠) 之前。 这个 <code>/</code> 被用来从逻辑上分隔仅限位置形参和其它形参。 如果函数定义中没有 <code>/</code>，则表示没有仅限位置形参。</p>
<p>在 <code>/</code> 之后的形参可以为 <em>位置或关键字</em> 或 <em>仅限关键字</em>。</p>
<h4 id="4-7-3-3-仅限关键字参数"><a href="#4-7-3-3-仅限关键字参数" class="headerlink" title="4.7.3.3. 仅限关键字参数"></a>4.7.3.3. 仅限关键字参数</h4><p>要将形参标记为 <em>仅限关键字*，即指明该形参必须以关键字参数的形式传入，应在参数列表的第一个 *仅限关键字</em> 形参之前放置一个 <code>*</code>。</p>
<h4 id="4-7-3-4-函数示例"><a href="#4-7-3-4-函数示例" class="headerlink" title="4.7.3.4. 函数示例"></a>4.7.3.4. 函数示例</h4><p>请考虑以下示例函数定义并特别注意 <code>/</code> 和 <code>*</code> 标记:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def standard_arg(arg):</span><br><span class="line">...     print(arg)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def pos_only_arg(arg, &#x2F;):</span><br><span class="line">...     print(arg)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def kwd_only_arg(*, arg):</span><br><span class="line">...     print(arg)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def combined_example(pos_only, &#x2F;, standard, *, kwd_only):</span><br><span class="line">...     print(pos_only, standard, kwd_only)</span><br></pre></td></tr></table></figure>

<p>第一个函数定义 <code>standard_arg</code> 是最常见的形式，对调用方式没有任何限制，参数可以按位置也可以按关键字传入:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; standard_arg(2)</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; standard_arg(arg&#x3D;2)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>第二个函数 <code>pos_only_arg</code> 在函数定义中带有 <code>/</code>，限制仅使用位置形参。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pos_only_arg(1)</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; pos_only_arg(arg&#x3D;1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: pos_only_arg() got an unexpected keyword argument &#39;arg&#39;</span><br></pre></td></tr></table></figure>

<p>第三个函数 <code>kwd_only_args</code> 在函数定义中通过 <code>*</code> 指明仅允许关键字参数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; kwd_only_arg(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; kwd_only_arg(arg&#x3D;3)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>而最后一个则在同一函数定义中使用了全部三种调用方式:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; combined_example(1, 2, 3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: combined_example() takes 2 positional arguments but 3 were given</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; combined_example(1, 2, kwd_only&#x3D;3)</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; combined_example(1, standard&#x3D;2, kwd_only&#x3D;3)</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; combined_example(pos_only&#x3D;1, standard&#x3D;2, kwd_only&#x3D;3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: combined_example() got an unexpected keyword argument &#39;pos_only&#39;</span><br></pre></td></tr></table></figure>

<p>最后，请考虑这个函数定义，它的位置参数 <code>name</code> 和 <code>**kwds</code> 之间由于存在关键字名称 <code>name</code> 而可能产生潜在冲突:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(name, **kwds):</span><br><span class="line">    return &#39;name&#39; in kwds</span><br></pre></td></tr></table></figure>

<p>任何调用都不可能让它返回 <code>True</code>，因为关键字 <code>&#39;name&#39;</code> 将总是绑定到第一个形参。 例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; foo(1, **&#123;&#39;name&#39;: 2&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: foo() got multiple values for argument &#39;name&#39;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>但使用 <code>/</code> (仅限位置参数) 就可能做到，因为它允许 <code>name</code> 作为位置参数，也允许 <code>&#39;name&#39;</code> 作为关键字参数的关键字名称:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(name, &#x2F;, **kwds):</span><br><span class="line">    return &#39;name&#39; in kwds</span><br><span class="line">&gt;&gt;&gt; foo(1, **&#123;&#39;name&#39;: 2&#125;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>换句话说，仅限位置形参的名称可以在 <code>**kwds</code> 中使用而不产生歧义。</p>
<h4 id="4-7-3-5-概括"><a href="#4-7-3-5-概括" class="headerlink" title="4.7.3.5. 概括"></a>4.7.3.5. 概括</h4><p>用例将确定要在函数定义中使用的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def f(pos1, pos2, &#x2F;, pos_or_kwd, *, kwd1, kwd2):</span><br></pre></td></tr></table></figure>

<p>作为指导：</p>
<ul>
<li>如果你希望形参名称对用户来说不可用，则使用仅限位置形参。 这适用于形参名称没有实际意义，以及当你希望强制规定调用时的参数顺序，或是需要同时收受一些位置形参和任意关键字形参等情况。</li>
<li>当形参名称有实际意义，以及显式指定形参名称可使函数定义更易理解，或者当你想要防止用户过于依赖传入参数的位置时，则使用仅限关键字形参。</li>
<li>对于 API 来说，使用仅限位置形参可以防止形参名称在未来被修改时造成破坏性的 API 变动。</li>
</ul>
<h3 id="4-7-4-任意的参数列表"><a href="#4-7-4-任意的参数列表" class="headerlink" title="4.7.4. 任意的参数列表"></a>4.7.4. 任意的参数列表</h3><p>最后，最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个元组里（参见 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-tuples" target="_blank" rel="noopener">元组和序列</a> ）。在可变数量的参数之前，可能会出现零个或多个普通参数。:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def write_multiple_items(file, separator, *args):</span><br><span class="line">    file.write(separator.join(args))</span><br></pre></td></tr></table></figure>

<p>一般来说，这些 <code>可变参数</code> 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数。出现在 <code>*args</code> 参数之后的任何形式参数都是 ‘仅关键字参数’，也就是说它们只能作为关键字参数而不能是位置参数。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def concat(*args, sep&#x3D;&quot;&#x2F;&quot;):</span><br><span class="line">...     return sep.join(args)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;)</span><br><span class="line">&#39;earth&#x2F;mars&#x2F;venus&#39;</span><br><span class="line">&gt;&gt;&gt; concat(&quot;earth&quot;, &quot;mars&quot;, &quot;venus&quot;, sep&#x3D;&quot;.&quot;)</span><br><span class="line">&#39;earth.mars.venus&#39;</span><br></pre></td></tr></table></figure>



<h3 id="4-7-5-解包参数列表"><a href="#4-7-5-解包参数列表" class="headerlink" title="4.7.5. 解包参数列表"></a>4.7.5. 解包参数列表</h3><p>当参数已经在列表或元组中但要为需要单独位置参数的函数调用解包时，会发生相反的情况。例如，内置的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a> 函数需要单独的 <em>start</em> 和 <em>stop</em> 参数。如果它们不能单独使用，可以使用 <code>*</code>-操作符 来编写函数调用以便从列表或元组中解包参数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(3, 6))            # normal call with separate arguments</span><br><span class="line">[3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; args &#x3D; [3, 6]</span><br><span class="line">&gt;&gt;&gt; list(range(*args))            # call with arguments unpacked from a list</span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></table></figure>

<p>同样的方式，字典可使用 <code>**</code> 操作符 来提供关键字参数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def parrot(voltage, state&#x3D;&#39;a stiff&#39;, action&#x3D;&#39;voom&#39;):</span><br><span class="line">...     print(&quot;-- This parrot wouldn&#39;t&quot;, action, end&#x3D;&#39; &#39;)</span><br><span class="line">...     print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;, end&#x3D;&#39; &#39;)</span><br><span class="line">...     print(&quot;E&#39;s&quot;, state, &quot;!&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&quot;voltage&quot;: &quot;four million&quot;, &quot;state&quot;: &quot;bleedin&#39; demised&quot;, &quot;action&quot;: &quot;VOOM&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; parrot(**d)</span><br><span class="line">-- This parrot wouldn&#39;t VOOM if you put four million volts through it. E&#39;s bleedin&#39; demised !</span><br></pre></td></tr></table></figure>



<h3 id="4-7-6-Lambda-表达式"><a href="#4-7-6-Lambda-表达式" class="headerlink" title="4.7.6. Lambda 表达式"></a>4.7.6. Lambda 表达式</h3><p>可以用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 关键字来创建一个小的匿名函数。这个函数返回两个参数的和： <code>lambda a, b: a+b</code> 。Lambda函数可以在需要函数对象的任何地方使用。它们在语法上限于单个表达式。从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，lambda函数可以引用所包含域的变量:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def make_incrementor(n):</span><br><span class="line">...     return lambda x: x + n</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f &#x3D; make_incrementor(42)</span><br><span class="line">&gt;&gt;&gt; f(0)</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt; f(1)</span><br><span class="line">43</span><br></pre></td></tr></table></figure>

<p>上面的例子使用一个lambda表达式来返回一个函数。另一个用法是传递一个小函数作为参数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pairs &#x3D; [(1, &#39;one&#39;), (2, &#39;two&#39;), (3, &#39;three&#39;), (4, &#39;four&#39;)]</span><br><span class="line">&gt;&gt;&gt; pairs.sort(key&#x3D;lambda pair: pair[1])</span><br><span class="line">&gt;&gt;&gt; pairs</span><br><span class="line">[(4, &#39;four&#39;), (1, &#39;one&#39;), (3, &#39;three&#39;), (2, &#39;two&#39;)]</span><br></pre></td></tr></table></figure>



<h3 id="4-7-7-文档字符串"><a href="#4-7-7-文档字符串" class="headerlink" title="4.7.7. 文档字符串"></a>4.7.7. 文档字符串</h3><p>以下是有关文档字符串的内容和格式的一些约定。</p>
<p>第一行应该是对象目的的简要概述。为简洁起见，它不应显式声明对象的名称或类型，因为这些可通过其他方式获得（除非名称恰好是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。</p>
<p>如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。后面几行应该是一个或多个段落，描述对象的调用约定，它的副作用等。</p>
<p>Python 解析器不会从 Python 中删除多行字符串文字的缩进，因此处理文档的工具必须在需要时删除缩进。 这是使用以下约定完成的。 文档字符串第一行 <em>之后</em> 的第一个非空行确定整个文档字符串的缩进量。（我们不能使用第一行，因为它通常与字符串的开头引号相邻，因此它的缩进在字符串文字中不明显。）然后从字符串的所有行的开头剥离与该缩进 “等效” 的空格。 缩进更少的行不应该出现，但是如果它们出现，则应该剥离它们的所有前导空格。 应在转化制表符为空格后测试空格的等效性（通常转化为8个空格）。</p>
<p>下面是一个多行文档字符串的例子:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def my_function():</span><br><span class="line">...     &quot;&quot;&quot;Do nothing, but document it.</span><br><span class="line">...</span><br><span class="line">...     No, really, it doesn&#39;t do anything.</span><br><span class="line">...     &quot;&quot;&quot;</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(my_function.__doc__)</span><br><span class="line">Do nothing, but document it.</span><br><span class="line"></span><br><span class="line">    No, really, it doesn&#39;t do anything.</span><br></pre></td></tr></table></figure>



<h3 id="4-7-8-函数标注"><a href="#4-7-8-函数标注" class="headerlink" title="4.7.8. 函数标注"></a>4.7.8. 函数标注</h3><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#function" target="_blank" rel="noopener">函数标注</a> 是关于用户自定义函数中使用的类型的完全可选元数据信息（有关详情请参阅 <a href="https://www.python.org/dev/peps/pep-3107" target="_blank" rel="noopener"><strong>PEP 3107</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> ）。</p>
<p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-function-annotation" target="_blank" rel="noopener">函数标注</a> 以字典的形式存放在函数的 <code>__annotations__</code> 属性中，并且不会影响函数的任何其他部分。 形参标注的定义方式是在形参名称后加上冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加上一个组合符号 <code>-&gt;</code>，后面跟一个表达式，该标注位于形参列表和表示 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> 语句结束的冒号之间。 下面的示例有一个位置参数，一个关键字参数以及返回值带有相应标注:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(ham: str, eggs: str &#x3D; &#39;eggs&#39;) -&gt; str:</span><br><span class="line">...     print(&quot;Annotations:&quot;, f.__annotations__)</span><br><span class="line">...     print(&quot;Arguments:&quot;, ham, eggs)</span><br><span class="line">...     return ham + &#39; and &#39; + eggs</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f(&#39;spam&#39;)</span><br><span class="line">Annotations: &#123;&#39;ham&#39;: &lt;class &#39;str&#39;&gt;, &#39;return&#39;: &lt;class &#39;str&#39;&gt;, &#39;eggs&#39;: &lt;class &#39;str&#39;&gt;&#125;</span><br><span class="line">Arguments: spam eggs</span><br><span class="line">&#39;spam and eggs&#39;</span><br></pre></td></tr></table></figure>



<h2 id="4-8-小插曲：编码风格"><a href="#4-8-小插曲：编码风格" class="headerlink" title="4.8. 小插曲：编码风格"></a>4.8. 小插曲：编码风格</h2><p>现在你将要写更长，更复杂的 Python 代码，是时候讨论一下 <em>代码风格</em> 了。 大多数语言都能以不同的风格被编写（或更准确地说，被格式化）；有些比其他的更具有可读性。 能让其他人轻松阅读你的代码总是一个好主意，采用一种好的编码风格对此有很大帮助。</p>
<p>对于Python，<a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> 已经成为大多数项目所遵循的风格指南；它促进了一种非常易读且令人赏心悦目的编码风格。每个Python开发人员都应该在某个时候阅读它；以下是为你提取的最重要的几个要点：</p>
<ul>
<li><p>使用4个空格缩进，不要使用制表符。</p>
<p>4个空格是一个在小缩进（允许更大的嵌套深度）和大缩进（更容易阅读）的一种很好的折中方案。制表符会引入混乱，最好不要使用它。</p>
</li>
<li><p>换行，使一行不超过79个字符。</p>
<p>这有助于使用小型显示器的用户，并且可以在较大的显示器上并排放置多个代码文件。</p>
</li>
<li><p>使用空行分隔函数和类，以及函数内的较大的代码块。</p>
</li>
<li><p>如果可能，把注释放到单独的一行。</p>
</li>
<li><p>使用文档字符串。</p>
</li>
<li><p>在运算符前后和逗号后使用空格，但不能直接在括号内使用： <code>a = f(1, 2) + g(3, 4)</code>。</p>
</li>
<li><p>以一致的规则为你的类和函数命名；按照惯例应使用 <code>UpperCamelCase</code> 来命名类，而以 <code>lowercase_with_underscores</code> 来命名函数和方法。 始终应使用 <code>self</code> 来命名第一个方法参数 (有关类和方法的更多信息请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-firstclasses" target="_blank" rel="noopener">初探类</a>)。</p>
</li>
<li><p>如果你的代码旨在用于国际环境，请不要使用花哨的编码。Python 默认的 UTF-8 或者纯 ASCII 在任何情况下都能有最好的表现。</p>
</li>
<li><p>同样，哪怕只有很小的可能，遇到说不同语言的人阅读或维护代码，也不要在标识符中使用非ASCII字符。</p>
</li>
</ul>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#id1" target="_blank" rel="noopener">1</a></p>
<p>实际上，<em>通过对象引用调用</em> 会是一个更好的表述，因为如果传递的是可变对象，则调用者将看到被调用者对其做出的任何更改（插入到列表中的元素）。</p>
</li>
</ul>
<h1 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5. 数据结构"></a>5. 数据结构</h1><p>本章将详细介绍一些您已经了解的内容，并添加了一些新内容。</p>
<h2 id="5-1-列表的更多特性"><a href="#5-1-列表的更多特性" class="headerlink" title="5.1. 列表的更多特性"></a>5.1. 列表的更多特性</h2><p>列表数据类型还有很多的方法。这里是列表对象方法的清单：</p>
<ul>
<li><p><code>list.``append</code>(<em>x</em>)</p>
<p>在列表的末尾添加一个元素。相当于 <code>a[len(a):] = [x]</code> 。</p>
</li>
<li><p><code>list.``extend</code>(<em>iterable</em>)</p>
<p>使用可迭代对象中的所有元素来扩展列表。相当于 <code>a[len(a):] = iterable</code> 。</p>
</li>
<li><p><code>list.``insert</code>(<em>i</em>, <em>x</em>)</p>
<p>在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 <code>a.insert(0, x)</code> 插入列表头部， <code>a.insert(len(a), x)</code> 等同于 <code>a.append(x)</code> 。</p>
</li>
<li><p><code>list.``remove</code>(<em>x</em>)</p>
<p>移除列表中第一个值为 <em>x</em> 的元素。如果没有这样的元素，则抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p>
</li>
<li><p><code>list.``pop</code>([<em>i</em>])</p>
<p>删除列表中给定位置的元素并返回它。如果没有给定位置，<code>a.pop()</code> 将会删除并返回列表中的最后一个元素。（ 方法签名中 <em>i</em> 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法)。</p>
</li>
<li><p><code>list.``clear</code>()</p>
<p>删除列表中所有的元素。相当于 <code>del a[:]</code> 。</p>
</li>
<li><p><code>list.``index</code>(<em>x</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回列表中第一个值为 <em>x</em> 的元素的从零开始的索引。如果没有这样的元素将会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。可选参数 <em>start</em> 和 <em>end</em> 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 <em>start</em> 参数。</p>
</li>
<li><p><code>list.``count</code>(<em>x</em>)</p>
<p>返回元素 <em>x</em> 在列表中出现的次数。</p>
</li>
<li><p><code>list.``sort</code>(<em>key=None</em>, <em>reverse=False</em>)</p>
<p>对列表中的元素进行排序（参数可用于自定义排序，解释请参见 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a>）。</p>
</li>
<li><p><code>list.``reverse</code>()</p>
<p>反转列表中的元素。</p>
</li>
<li><p><code>list.``copy</code>()</p>
<p>返回列表的一个浅拷贝。相当于 <code>a[:]</code> 。</p>
</li>
</ul>
<p>列表方法示例：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruits &#x3D; [&#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;, &#39;kiwi&#39;, &#39;apple&#39;, &#39;banana&#39;]</span><br><span class="line">&gt;&gt;&gt; fruits.count(&#39;apple&#39;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; fruits.count(&#39;tangerine&#39;)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; fruits.index(&#39;banana&#39;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; fruits.index(&#39;banana&#39;, 4)  # Find next banana starting a position 4</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; fruits.reverse()</span><br><span class="line">&gt;&gt;&gt; fruits</span><br><span class="line">[&#39;banana&#39;, &#39;apple&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;]</span><br><span class="line">&gt;&gt;&gt; fruits.append(&#39;grape&#39;)</span><br><span class="line">&gt;&gt;&gt; fruits</span><br><span class="line">[&#39;banana&#39;, &#39;apple&#39;, &#39;kiwi&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;grape&#39;]</span><br><span class="line">&gt;&gt;&gt; fruits.sort()</span><br><span class="line">&gt;&gt;&gt; fruits</span><br><span class="line">[&#39;apple&#39;, &#39;apple&#39;, &#39;banana&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;kiwi&#39;, &#39;orange&#39;, &#39;pear&#39;]</span><br><span class="line">&gt;&gt;&gt; fruits.pop()</span><br><span class="line">&#39;pear&#39;</span><br></pre></td></tr></table></figure>

<p>你可能已经注意到，像 <code>insert</code> ，<code>remove</code> 或者 <code>sort</code> 方法，只修改列表，没有打印出返回值——它们返回默认值 <code>None</code> 。<a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#id2" target="_blank" rel="noopener">1</a> 这是Python中所有可变数据结构的设计原则。</p>
<p>你可能会注意到的另一件事是并非所有数据或可以排序或比较。 例如，<code>[None, &#39;hello&#39;, 10]</code> 就不可排序，因为整数不能与字符串比较，而 <em>None</em> 不能与其他类型比较。 并且还存在一些没有定义顺序关系的类型。 例如，<code>3+4j &lt; 5+7j</code> 就不是一个合法的比较。</p>
<h3 id="5-1-1-列表作为栈使用"><a href="#5-1-1-列表作为栈使用" class="headerlink" title="5.1.1. 列表作为栈使用"></a>5.1.1. 列表作为栈使用</h3><p>列表方法使得列表作为堆栈非常容易，最后一个插入，最先取出（“后进先出”）。要添加一个元素到堆栈的顶端，使用 <code>append()</code> 。要从堆栈顶部取出一个元素，使用 <code>pop()</code> ，不用指定索引。例如</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; stack &#x3D; [3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; stack.append(6)</span><br><span class="line">&gt;&gt;&gt; stack.append(7)</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3, 4, 5, 6, 7]</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3, 4]</span><br></pre></td></tr></table></figure>



<h3 id="5-1-2-列表作为队列使用"><a href="#5-1-2-列表作为队列使用" class="headerlink" title="5.1.2. 列表作为队列使用"></a>5.1.2. 列表作为队列使用</h3><p>列表也可以用作队列，其中先添加的元素被最先取出 (“先进先出”)；然而列表用作这个目的相当低效。因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹出元素却很慢 (因为所有的其他元素都必须移动一位)。</p>
<p>若要实现一个队列， <a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.deque" target="_blank" rel="noopener"><code>collections.deque</code></a> 被设计用于快速地从两端操作。例如</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; queue &#x3D; deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])</span><br><span class="line">&gt;&gt;&gt; queue.append(&quot;Terry&quot;)           # Terry arrives</span><br><span class="line">&gt;&gt;&gt; queue.append(&quot;Graham&quot;)          # Graham arrives</span><br><span class="line">&gt;&gt;&gt; queue.popleft()                 # The first to arrive now leaves</span><br><span class="line">&#39;Eric&#39;</span><br><span class="line">&gt;&gt;&gt; queue.popleft()                 # The second to arrive now leaves</span><br><span class="line">&#39;John&#39;</span><br><span class="line">&gt;&gt;&gt; queue                           # Remaining queue in order of arrival</span><br><span class="line">deque([&#39;Michael&#39;, &#39;Terry&#39;, &#39;Graham&#39;])</span><br></pre></td></tr></table></figure>



<h3 id="5-1-3-列表推导式"><a href="#5-1-3-列表推导式" class="headerlink" title="5.1.3. 列表推导式"></a>5.1.3. 列表推导式</h3><p>列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。</p>
<p>例如，假设我们想创建一个平方列表，像这样</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squares &#x3D; []</span><br><span class="line">&gt;&gt;&gt; for x in range(10):</span><br><span class="line">...     squares.append(x**2)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; squares</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>

<p>注意这里创建（或被重写）的名为 <code>x</code> 的变量在for循环后仍然存在。我们可以计算平方列表的值而不会产生任何副作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares &#x3D; list(map(lambda x: x**2, range(10)))</span><br></pre></td></tr></table></figure>

<p>或者，等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares &#x3D; [x**2 for x in range(10)]</span><br></pre></td></tr></table></figure>

<p>上面这种写法更加简洁易读。</p>
<p>列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 <code>for</code> 子句，然后是零个或多个 <code>for</code> 或 <code>if</code> 子句。 其结果将是一个新列表，由对表达式依据后面的 <code>for</code> 和 <code>if</code> 子句的内容进行求值计算而得出。 举例来说，以下列表推导式会将两个列表中不相等的元素组合起来:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x !&#x3D; y]</span><br><span class="line">[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</span><br></pre></td></tr></table></figure>

<p>而它等价于</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; combs &#x3D; []</span><br><span class="line">&gt;&gt;&gt; for x in [1,2,3]:</span><br><span class="line">...     for y in [3,1,4]:</span><br><span class="line">...         if x !&#x3D; y:</span><br><span class="line">...             combs.append((x, y))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; combs</span><br><span class="line">[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</span><br></pre></td></tr></table></figure>

<p>注意在上面两个代码片段中， <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 的顺序是相同的。</p>
<p>如果表达式是一个元组（例如上面的 <code>(x, y)</code>），那么就必须加上括号</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; vec &#x3D; [-4, -2, 0, 2, 4]</span><br><span class="line">&gt;&gt;&gt; # create a new list with the values doubled</span><br><span class="line">&gt;&gt;&gt; [x*2 for x in vec]</span><br><span class="line">[-8, -4, 0, 4, 8]</span><br><span class="line">&gt;&gt;&gt; # filter the list to exclude negative numbers</span><br><span class="line">&gt;&gt;&gt; [x for x in vec if x &gt;&#x3D; 0]</span><br><span class="line">[0, 2, 4]</span><br><span class="line">&gt;&gt;&gt; # apply a function to all the elements</span><br><span class="line">&gt;&gt;&gt; [abs(x) for x in vec]</span><br><span class="line">[4, 2, 0, 2, 4]</span><br><span class="line">&gt;&gt;&gt; # call a method on each element</span><br><span class="line">&gt;&gt;&gt; freshfruit &#x3D; [&#39;  banana&#39;, &#39;  loganberry &#39;, &#39;passion fruit  &#39;]</span><br><span class="line">&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]</span><br><span class="line">[&#39;banana&#39;, &#39;loganberry&#39;, &#39;passion fruit&#39;]</span><br><span class="line">&gt;&gt;&gt; # create a list of 2-tuples like (number, square)</span><br><span class="line">&gt;&gt;&gt; [(x, x**2) for x in range(6)]</span><br><span class="line">[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</span><br><span class="line">&gt;&gt;&gt; # the tuple must be parenthesized, otherwise an error is raised</span><br><span class="line">&gt;&gt;&gt; [x, x**2 for x in range(6)]</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    [x, x**2 for x in range(6)]</span><br><span class="line">               ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; # flatten a list using a listcomp with two &#39;for&#39;</span><br><span class="line">&gt;&gt;&gt; vec &#x3D; [[1,2,3], [4,5,6], [7,8,9]]</span><br><span class="line">&gt;&gt;&gt; [num for elem in vec for num in elem]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>列表推导式可以使用复杂的表达式和嵌套函数</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from math import pi</span><br><span class="line">&gt;&gt;&gt; [str(round(pi, i)) for i in range(1, 6)]</span><br><span class="line">[&#39;3.1&#39;, &#39;3.14&#39;, &#39;3.142&#39;, &#39;3.1416&#39;, &#39;3.14159&#39;]</span><br></pre></td></tr></table></figure>

<h3 id="5-1-4-嵌套的列表推导式"><a href="#5-1-4-嵌套的列表推导式" class="headerlink" title="5.1.4. 嵌套的列表推导式"></a>5.1.4. 嵌套的列表推导式</h3><p>列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式。</p>
<p>考虑下面这个 3x4的矩阵，它由3个长度为4的列表组成</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix &#x3D; [</span><br><span class="line">...     [1, 2, 3, 4],</span><br><span class="line">...     [5, 6, 7, 8],</span><br><span class="line">...     [9, 10, 11, 12],</span><br><span class="line">... ]</span><br></pre></td></tr></table></figure>

<p>下面的列表推导式将交换其行和列</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)]</span><br><span class="line">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>

<p>如上节所示，嵌套的列表推导式是基于跟随其后的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 进行求值的，所以这个例子等价于:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; transposed &#x3D; []</span><br><span class="line">&gt;&gt;&gt; for i in range(4):</span><br><span class="line">...     transposed.append([row[i] for row in matrix])</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; transposed</span><br><span class="line">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>

<p>反过来说，也等价于</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; transposed &#x3D; []</span><br><span class="line">&gt;&gt;&gt; for i in range(4):</span><br><span class="line">...     # the following 3 lines implement the nested listcomp</span><br><span class="line">...     transposed_row &#x3D; []</span><br><span class="line">...     for row in matrix:</span><br><span class="line">...         transposed_row.append(row[i])</span><br><span class="line">...     transposed.append(transposed_row)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; transposed</span><br><span class="line">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>

<p>实际应用中，你应该会更喜欢使用内置函数去组成复杂的流程语句。 <a href="https://docs.python.org/zh-cn/3/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 函数将会很好地处理这种情况</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(zip(*matrix))</span><br><span class="line">[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]</span><br></pre></td></tr></table></figure>

<p>关于本行中星号的详细说明，参见 <a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#tut-unpacking-arguments" target="_blank" rel="noopener">解包参数列表</a>。</p>
<h2 id="5-2-del-语句"><a href="#5-2-del-语句" class="headerlink" title="5.2. del 语句"></a>5.2. <code>del</code> 语句</h2><p>有一种方式可以从列表按照给定的索引而不是值来移除一个元素: 那就是 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句。 它不同于会返回一个值的 <code>pop()</code> 方法。 <code>del</code> 语句也可以用来从列表中移除切片或者清空整个列表（我们之前用过的方式是将一个空列表赋值给指定的切片）。 例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [-1, 1, 66.25, 333, 333, 1234.5]</span><br><span class="line">&gt;&gt;&gt; del a[0]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 66.25, 333, 333, 1234.5]</span><br><span class="line">&gt;&gt;&gt; del a[2:4]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 66.25, 1234.5]</span><br><span class="line">&gt;&gt;&gt; del a[:]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 也可以被用来删除整个变量</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del a</span><br></pre></td></tr></table></figure>

<p>此后再引用 <code>a</code> 时会报错（直到另一个值被赋给它）。我们会在后面了解到 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 的其他用法。</p>
<h2 id="5-3-元组和序列"><a href="#5-3-元组和序列" class="headerlink" title="5.3. 元组和序列"></a>5.3. 元组和序列</h2><p>我们看到列表和字符串有很多共同特性，例如索引和切片操作。他们是 <em>序列</em> 数据类型（参见 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typesseq" target="_blank" rel="noopener">序列类型 — list, tuple, range</a>）中的两种。随着 Python 语言的发展，其他的序列类型也会被加入其中。这里介绍另一种标准序列类型: <em>元组</em>。</p>
<p>一个元组由几个被逗号隔开的值组成，例如</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; 12345, 54321, &#39;hello!&#39;</span><br><span class="line">&gt;&gt;&gt; t[0]</span><br><span class="line">12345</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(12345, 54321, &#39;hello!&#39;)</span><br><span class="line">&gt;&gt;&gt; # Tuples may be nested:</span><br><span class="line">... u &#x3D; t, (1, 2, 3, 4, 5)</span><br><span class="line">&gt;&gt;&gt; u</span><br><span class="line">((12345, 54321, &#39;hello!&#39;), (1, 2, 3, 4, 5))</span><br><span class="line">&gt;&gt;&gt; # Tuples are immutable:</span><br><span class="line">... t[0] &#x3D; 88888</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#39;tuple&#39; object does not support item assignment</span><br><span class="line">&gt;&gt;&gt; # but they can contain mutable objects:</span><br><span class="line">... v &#x3D; ([1, 2, 3], [3, 2, 1])</span><br><span class="line">&gt;&gt;&gt; v</span><br><span class="line">([1, 2, 3], [3, 2, 1])</span><br></pre></td></tr></table></figure>

<p>如你所见，元组在输出时总是被圆括号包围的，以便正确表示嵌套元组。输入时圆括号可有可无，不过经常会是必须的（如果这个元组是一个更大的表达式的一部分）。给元组中的一个单独的元素赋值是不允许的，当然你可以创建包含可变对象的元组，例如列表。</p>
<p>虽然元组可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。元组是 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-immutable" target="_blank" rel="noopener">immutable</a> （不可变的），其序列通常包含不同种类的元素，并且通过解包（这一节下面会解释）或者索引来访问（如果是 <a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuples</code></a> 的话甚至还可以通过属性访问）。列表是 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable" target="_blank" rel="noopener">mutable</a> （可变的），并且列表中的元素一般是同种类型的，并且通过迭代访问。</p>
<p>一个特殊的问题是构造包含0个或1个元素的元组：为了适应这种情况，语法有一些额外的改变。空元组可以直接被一对空圆括号创建，含有一个元素的元组可以通过在这个元素后添加一个逗号来构建（圆括号里只有一个值的话不够明确）。丑陋，但是有效。例如</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; empty &#x3D; ()</span><br><span class="line">&gt;&gt;&gt; singleton &#x3D; &#39;hello&#39;,    # &lt;-- note trailing comma</span><br><span class="line">&gt;&gt;&gt; len(empty)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; len(singleton)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; singleton</span><br><span class="line">(&#39;hello&#39;,)</span><br></pre></td></tr></table></figure>

<p>语句 <code>t = 12345, 54321, &#39;hello!&#39;</code> 是 <em>元组打包</em> 的一个例子：值 <code>12345</code>, <code>54321</code> 和 <code>&#39;hello!&#39;</code> 被打包进元组。其逆操作也是允许的</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y, z &#x3D; t</span><br></pre></td></tr></table></figure>

<p>这被称为 <em>序列解包</em> 也是很恰当的，因为解包操作的等号右侧可以是任何序列。序列解包要求等号左侧的变量数与右侧序列里所含的元素数相同。注意多重赋值其实也只是元组打包和序列解包的组合。</p>
<h2 id="5-4-集合"><a href="#5-4-集合" class="headerlink" title="5.4. 集合"></a>5.4. 集合</h2><p>Python也包含有 <em>集合</em> 类型。集合是由不重复元素组成的无序的集。它的基本用法包括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。</p>
<p>花括号或 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set()</code></a> 函数可以用来创建集合。注意：要创建一个空集合你只能用 <code>set()</code> 而不能用 <code>{}</code>，因为后者是创建一个空字典，这种数据结构我们会在下一节进行讨论。</p>
<p>以下是一些简单的示例：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; basket &#x3D; &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; print(basket)                      # show that duplicates have been removed</span><br><span class="line">&#123;&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; &#39;orange&#39; in basket                 # fast membership testing</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#39;crabgrass&#39; in basket</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # Demonstrate set operations on unique letters from two words</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a &#x3D; set(&#39;abracadabra&#39;)</span><br><span class="line">&gt;&gt;&gt; b &#x3D; set(&#39;alacazam&#39;)</span><br><span class="line">&gt;&gt;&gt; a                                  # unique letters in a</span><br><span class="line">&#123;&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a - b                              # letters in a but not in b</span><br><span class="line">&#123;&#39;r&#39;, &#39;d&#39;, &#39;b&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a | b                              # letters in a or b or both</span><br><span class="line">&#123;&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a &amp; b                              # letters in both a and b</span><br><span class="line">&#123;&#39;a&#39;, &#39;c&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a ^ b                              # letters in a or b but not both</span><br><span class="line">&#123;&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>类似于 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-listcomps" target="_blank" rel="noopener">列表推导式</a>，集合也支持推导式形式</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#123;x for x in &#39;abracadabra&#39; if x not in &#39;abc&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;r&#39;, &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-5-字典"><a href="#5-5-字典" class="headerlink" title="5.5. 字典"></a>5.5. 字典</h2><p>另一个非常有用的 Python 內置数据类型是 <em>字典</em> (参见 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typesmapping" target="_blank" rel="noopener">映射类型 — dict</a>)。字典在其他语言里可能会被叫做 <em>联合内存</em> 或 <em>联合数组*。与以连续整数为索引的序列不同，字典是以 *关键字</em> 为索引的，关键字可以是任意不可变类型，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。列表不能用作关键字，因为列表可以通过索引、切片或 <code>append()</code> 和 <code>extend()</code> 之类的方法来改变。</p>
<p>理解字典的最好方式，就是将它看做是一个 <em>键: 值</em> 对的集合，键必须是唯一的（在一个字典中）。一对花括号可以创建一个空字典：<code>{}</code> 。另一种初始化字典的方式是在一对花括号里放置一些以逗号分隔的键值对，而这也是字典输出的方式。</p>
<p>字典主要的操作是使用关键字存储和解析值。也可以用 <code>del</code> 来删除一个键值对。如果你使用了一个已经存在的关键字来存储值，那么之前与这个关键字关联的值就会被遗忘。用一个不存在的键来取值则会报错。</p>
<p>对一个字典执行 <code>list(d)</code> 将返回包含该字典中所有键的列表，按插入次序排列 (如需其他排序，则要使用 <code>sorted(d)</code>)。要检查字典中是否存在一个特定键，可使用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 关键字。</p>
<p>以下是使用字典的一些简单示例</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tel &#x3D; &#123;&#39;jack&#39;: 4098, &#39;sape&#39;: 4139&#125;</span><br><span class="line">&gt;&gt;&gt; tel[&#39;guido&#39;] &#x3D; 4127</span><br><span class="line">&gt;&gt;&gt; tel</span><br><span class="line">&#123;&#39;jack&#39;: 4098, &#39;sape&#39;: 4139, &#39;guido&#39;: 4127&#125;</span><br><span class="line">&gt;&gt;&gt; tel[&#39;jack&#39;]</span><br><span class="line">4098</span><br><span class="line">&gt;&gt;&gt; del tel[&#39;sape&#39;]</span><br><span class="line">&gt;&gt;&gt; tel[&#39;irv&#39;] &#x3D; 4127</span><br><span class="line">&gt;&gt;&gt; tel</span><br><span class="line">&#123;&#39;jack&#39;: 4098, &#39;guido&#39;: 4127, &#39;irv&#39;: 4127&#125;</span><br><span class="line">&gt;&gt;&gt; list(tel)</span><br><span class="line">[&#39;jack&#39;, &#39;guido&#39;, &#39;irv&#39;]</span><br><span class="line">&gt;&gt;&gt; sorted(tel)</span><br><span class="line">[&#39;guido&#39;, &#39;irv&#39;, &#39;jack&#39;]</span><br><span class="line">&gt;&gt;&gt; &#39;guido&#39; in tel</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#39;jack&#39; not in tel</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict()</code></a> 构造函数可以直接从键值对序列里创建字典。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])</span><br><span class="line">&#123;&#39;sape&#39;: 4139, &#39;guido&#39;: 4127, &#39;jack&#39;: 4098&#125;</span><br></pre></td></tr></table></figure>

<p>此外，字典推导式可以从任意的键值表达式中创建字典</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br></pre></td></tr></table></figure>

<p>当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict(sape&#x3D;4139, guido&#x3D;4127, jack&#x3D;4098)</span><br><span class="line">&#123;&#39;sape&#39;: 4139, &#39;guido&#39;: 4127, &#39;jack&#39;: 4098&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-6-循环的技巧"><a href="#5-6-循环的技巧" class="headerlink" title="5.6. 循环的技巧"></a>5.6. 循环的技巧</h2><p>当在字典中循环时，用 <code>items()</code> 方法可将关键字和对应的值同时取出</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; knights &#x3D; &#123;&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; for k, v in knights.items():</span><br><span class="line">...     print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>

<p>当在序列中循环时，用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 函数可以将索引位置和其对应的值同时取出</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):</span><br><span class="line">...     print(i, v)</span><br><span class="line">...</span><br><span class="line">0 tic</span><br><span class="line">1 tac</span><br><span class="line">2 toe</span><br></pre></td></tr></table></figure>

<p>当同时在两个或更多序列中循环时，可以用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 函数将其内元素一一匹配。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; questions &#x3D; [&#39;name&#39;, &#39;quest&#39;, &#39;favorite color&#39;]</span><br><span class="line">&gt;&gt;&gt; answers &#x3D; [&#39;lancelot&#39;, &#39;the holy grail&#39;, &#39;blue&#39;]</span><br><span class="line">&gt;&gt;&gt; for q, a in zip(questions, answers):</span><br><span class="line">...     print(&#39;What is your &#123;0&#125;?  It is &#123;1&#125;.&#39;.format(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure>

<p>当逆向循环一个序列时，先正向定位序列，然后调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#reversed" target="_blank" rel="noopener"><code>reversed()</code></a> 函数</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>如果要按某个指定顺序循环一个序列，可以用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; basket &#x3D; [&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;]</span><br><span class="line">&gt;&gt;&gt; for f in sorted(set(basket)):</span><br><span class="line">...     print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure>

<p>有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; raw_data &#x3D; [56.2, float(&#39;NaN&#39;), 51.7, 55.3, 52.5, float(&#39;NaN&#39;), 47.8]</span><br><span class="line">&gt;&gt;&gt; filtered_data &#x3D; []</span><br><span class="line">&gt;&gt;&gt; for value in raw_data:</span><br><span class="line">...     if not math.isnan(value):</span><br><span class="line">...         filtered_data.append(value)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; filtered_data</span><br><span class="line">[56.2, 51.7, 55.3, 52.5, 47.8]</span><br></pre></td></tr></table></figure>



<h2 id="5-7-深入条件控制"><a href="#5-7-深入条件控制" class="headerlink" title="5.7. 深入条件控制"></a>5.7. 深入条件控制</h2><p><code>while</code> 和 <code>if</code> 条件句中可以使用任意操作，而不仅仅是比较操作。</p>
<p>比较操作符 <code>in</code> 和 <code>not in</code> 校验一个值是否在（或不在）一个序列里。操作符 <code>is</code> 和 <code>is not</code> 比较两个对象是不是同一个对象，这只对像列表这样的可变对象比较重要。所有的比较操作符都有相同的优先级，且这个优先级比数值运算符低。</p>
<p>比较操作可以传递。例如 <code>a &lt; b == c</code> 会校验是否 <code>a</code> 小于 <code>b</code> 并且 <code>b</code> 等于 <code>c</code>。</p>
<p>比较操作可以通过布尔运算符 <code>and</code> 和 <code>or</code> 来组合，并且比较操作（或其他任何布尔运算）的结果都可以用 <code>not</code> 来取反。这些操作符的优先级低于比较操作符；在它们之中，<code>not</code> 优先级最高， <code>or</code> 优先级最低，因此 <code>A and not B or C</code> 等价于 <code>(A and (not B)) or C</code>。和之前一样，你也可以在这种式子里使用圆括号。</p>
<p>布尔运算符 <code>and</code> 和 <code>or</code> 也被称为 <em>短路</em> 运算符：它们的参数从左至右解析，一旦可以确定结果解析就会停止。例如，如果 <code>A</code> 和 <code>C</code> 为真而 <code>B</code> 为假，那么 <code>A and B and C</code> 不会解析 <code>C</code>。当用作普通值而非布尔值时，短路操作符的返回值通常是最后一个变量。</p>
<p>也可以把比较操作或者逻辑表达式的结果赋值给一个变量，例如</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; string1, string2, string3 &#x3D; &#39;&#39;, &#39;Trondheim&#39;, &#39;Hammer Dance&#39;</span><br><span class="line">&gt;&gt;&gt; non_null &#x3D; string1 or string2 or string3</span><br><span class="line">&gt;&gt;&gt; non_null</span><br><span class="line">&#39;Trondheim&#39;</span><br></pre></td></tr></table></figure>

<p>请注意 Python 与 C 不同，在表达式内部赋值必须显式地使用 <a href="https://docs.python.org/zh-cn/3/faq/design.html#why-can-t-i-use-an-assignment-in-an-expression" target="_blank" rel="noopener">海象运算符</a> <code>:=</code> 来完成。 这避免了 C 程序中常见的一种问题：想要在表达式中写 <code>==</code> 时却写成了 <code>=</code>。</p>
<h2 id="5-8-序列和其它类型的比较"><a href="#5-8-序列和其它类型的比较" class="headerlink" title="5.8. 序列和其它类型的比较"></a>5.8. 序列和其它类型的比较</h2><p>序列对象通常可以与相同序列类型的其他对象比较。 这种比较使用 <em>字典式</em> 顺序：首先比较开头的两个对应元素，如果两者不相等则比较结果就由此确定；如果两者相等则比较之后的两个元素，以此类推，直到有一个序列被耗尽。 如果要比较的两个元素本身又是相同类型的序列，则会递归地执行字典式顺序比较。 如果两个序列中所有的对应元素都相等，则两个序列也将被视为相等。 如果一个序列是另一个的初始子序列，则较短的序列就被视为较小（较少）。 对于字符串来说，字典式顺序是使用 Unicode 码位序号对单个字符排序。 下面是一些相同类型序列之间比较的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1, 2, 3)              &lt; (1, 2, 4)</span><br><span class="line">[1, 2, 3]              &lt; [1, 2, 4]</span><br><span class="line">&#39;ABC&#39; &lt; &#39;C&#39; &lt; &#39;Pascal&#39; &lt; &#39;Python&#39;</span><br><span class="line">(1, 2, 3, 4)           &lt; (1, 2, 4)</span><br><span class="line">(1, 2)                 &lt; (1, 2, -1)</span><br><span class="line">(1, 2, 3)             &#x3D;&#x3D; (1.0, 2.0, 3.0)</span><br><span class="line">(1, 2, (&#39;aa&#39;, &#39;ab&#39;))   &lt; (1, 2, (&#39;abc&#39;, &#39;a&#39;), 4)</span><br></pre></td></tr></table></figure>

<p>注意对不同类型对象来说，只要待比较对象提供了合适的比较方法，就可以使用 <code>&lt;</code> 和 <code>&gt;</code> 来比较。例如，混合数值类型是通过他们的数值进行比较的，所以 0 等于 0.0，等等。否则，解释器将抛出一个 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常，而不是随便给出一个结果。</p>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#id1" target="_blank" rel="noopener">1</a></p>
<p>别的语言可能会返回一个可变对象，他们允许方法连续执行，例如 <code>d-&gt;insert(&quot;a&quot;)-&gt;remove(&quot;b&quot;)-&gt;sort();</code>。</p>
</li>
</ul>
<h1 id="6-模块"><a href="#6-模块" class="headerlink" title="6. 模块"></a>6. 模块</h1><p>如果你从Python解释器退出并再次进入，之前的定义（函数和变量）都会丢失。因此，如果你想编写一个稍长些的程序，最好使用文本编辑器为解释器准备输入并将该文件作为输入运行。这被称作编写 <em>脚本</em> 。随着程序变得越来越长，你或许会想把它拆分成几个文件，以方便维护。你亦或想在不同的程序中使用一个便捷的函数， 而不必把这个函数复制到每一个程序中去。</p>
<p>为支持这些，Python有一种方法可以把定义放在一个文件里，并在脚本或解释器的交互式实例中使用它们。这样的文件被称作 <em>模块</em> ；模块中的定义可以 <em>导入</em> 到其它模块或者 <em>主</em> 模块（你在顶级和计算器模式下执行的脚本中可以访问的变量集合）。</p>
<p>模块是一个包含Python定义和语句的文件。文件名就是模块名后跟文件后缀 <code>.py</code> 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 <code>__name__</code> 的值获得。例如，使用你最喜爱的文本编辑器在当前目录下创建一个名为 <code>fibo.py</code> 的文件， 文件中含有以下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Fibonacci numbers module</span><br><span class="line"></span><br><span class="line">def fib(n):    # write Fibonacci series up to n</span><br><span class="line">    a, b &#x3D; 0, 1</span><br><span class="line">    while a &lt; n:</span><br><span class="line">        print(a, end&#x3D;&#39; &#39;)</span><br><span class="line">        a, b &#x3D; b, a+b</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">def fib2(n):   # return Fibonacci series up to n</span><br><span class="line">    result &#x3D; []</span><br><span class="line">    a, b &#x3D; 0, 1</span><br><span class="line">    while a &lt; n:</span><br><span class="line">        result.append(a)</span><br><span class="line">        a, b &#x3D; b, a+b</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<p>现在进入Python解释器，并用以下命令导入该模块:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import fibo</span><br></pre></td></tr></table></figure>

<p>在当前的符号表中，这并不会直接进入到定义在 <code>fibo</code> 函数内的名称；它只是进入到模块名 <code>fibo</code> 中。你可以用模块名访问这些函数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fibo.fib(1000)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</span><br><span class="line">&gt;&gt;&gt; fibo.fib2(100)</span><br><span class="line">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span><br><span class="line">&gt;&gt;&gt; fibo.__name__</span><br><span class="line">&#39;fibo&#39;</span><br></pre></td></tr></table></figure>

<p>如果你想经常使用某个函数，你可以把它赋值给一个局部变量:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fib &#x3D; fibo.fib</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>



<h2 id="6-1-有关模块的更多信息"><a href="#6-1-有关模块的更多信息" class="headerlink" title="6.1. 有关模块的更多信息"></a>6.1. 有关模块的更多信息</h2><p>模块可以包含可执行的语句以及函数定义。这些语句用于初始化模块。它们仅在模块 <em>第一次</em> 在 import 语句中被导入时才执行。 <a href="https://docs.python.org/zh-cn/3/tutorial/modules.html#id2" target="_blank" rel="noopener">1</a> (当文件被当作脚本运行时，它们也会执行。)</p>
<p>每个模块都有它自己的私有符号表，该表用作模块中定义的所有函数的全局符号表。因此，模块的作者可以在模块内使用全局变量，而不必担心与用户的全局变量发生意外冲突。另一方面，如果你知道自己在做什么，则可以用跟访问模块内的函数的同样标记方法，去访问一个模块的全局变量，<code>modname.itemname</code>。</p>
<p>模块可以导入其它模块。习惯上但不要求把所有 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句放在模块（或脚本）的开头。被导入的模块名存放在调入模块的全局符号表中。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句有一个变体，它可以把名字从一个被调模块内直接导入到现模块的符号表里。例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from fibo import fib, fib2</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>这并不会把被调模块名引入到局部变量表里（因此在这个例子里，<code>fibo</code> 是未被定义的）。</p>
<p>还有一个变体甚至可以导入模块内定义的所有名称:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from fibo import *</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>这会调入所有非以下划线（<code>_</code>）开头的名称。 在多数情况下，Python程序员都不会使用这个功能，因为它在解释器中引入了一组未知的名称，而它们很可能会覆盖一些你已经定义过的东西。</p>
<p>注意通常情况下从一个模块或者包内调入 <code>*</code> 的做法是不太被接受的， 因为这通常会导致代码的可读性很差。不过，在交互式编译器中为了节省打字可以这么用。</p>
<p>如果模块名称之后带有 <code>as</code>，则跟在 <code>as</code> 之后的名称将直接绑定到所导入的模块。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import fibo as fib</span><br><span class="line">&gt;&gt;&gt; fib.fib(500)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>这会和 <code>import fibo</code> 方式一样有效地调入模块， 唯一的区别是它以 <code>fib</code> 的名称存在的。</p>
<p>这种方式也可以在用到 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 的时候使用，并会有类似的效果:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from fibo import fib as fibonacci</span><br><span class="line">&gt;&gt;&gt; fibonacci(500)</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>注解</p>
<p>出于效率的考虑，每个模块在每个解释器会话中只被导入一次。因此，如果你更改了你的模块，则必须重新启动解释器， 或者，如果它只是一个要交互式地测试的模块，请使用 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.reload" target="_blank" rel="noopener"><code>importlib.reload()</code></a>，例如 <code>import importlib; importlib.reload(modulename)</code>。</p>
<h3 id="6-1-1-以脚本的方式执行模块"><a href="#6-1-1-以脚本的方式执行模块" class="headerlink" title="6.1.1. 以脚本的方式执行模块"></a>6.1.1. 以脚本的方式执行模块</h3><p>当你用下面方式运行一个Python模块:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python fibo.py &lt;arguments&gt;</span><br></pre></td></tr></table></figure>

<p>模块里的代码会被执行，就好像你导入了模块一样，但是 <code>__name__</code> 被赋值为 <code>&quot;__main__&quot;</code>。 这意味着通过在你的模块末尾添加这些代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    import sys</span><br><span class="line">    fib(int(sys.argv[1]))</span><br></pre></td></tr></table></figure>

<p>你既可以把这个文件当作脚本又可当作一个可调入的模块来使用， 因为那段解析命令行的代码只有在当模块是以“main”文件的方式执行的时候才会运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python fibo.py 50</span><br><span class="line">0 1 1 2 3 5 8 13 21 34</span><br></pre></td></tr></table></figure>

<p>如果模块是被导入的，那些代码是不运行的:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import fibo</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这经常用于为模块提供一个方便的用户接口，或用于测试（以脚本的方式运行模块从而执行一些测试套件）。</p>
<h3 id="6-1-2-模块搜索路径"><a href="#6-1-2-模块搜索路径" class="headerlink" title="6.1.2. 模块搜索路径"></a>6.1.2. 模块搜索路径</h3><p>当一个名为 <code>spam</code> 的模块被导入的时候，解释器首先寻找具有该名称的内置模块。如果没有找到，然后解释器从 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 变量给出的目录列表里寻找名为 <code>spam.py</code> 的文件。<a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a> 初始有这些目录地址:</p>
<ul>
<li>包含输入脚本的目录（或者未指定文件时的当前目录）。</li>
<li><a href="https://docs.python.org/zh-cn/3/using/cmdline.html#envvar-PYTHONPATH" target="_blank" rel="noopener"><code>PYTHONPATH</code></a> （一个包含目录名称的列表，它和shell变量 <code>PATH</code> 有一样的语法）。</li>
<li>取决于安装的默认设置</li>
</ul>
<p>注解</p>
<p>在支持符号链接的文件系统上，包含输入脚本的目录是在追加符号链接后才计算出来的。换句话说，包含符号链接的目录并 <strong>没有</strong> 被添加到模块的搜索路径上。</p>
<p>在初始化后，Python程序可以更改 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.path" target="_blank" rel="noopener"><code>sys.path</code></a>。包含正在运行脚本的文件目录被放在搜索路径的开头处， 在标准库路径之前。这意味着将加载此目录里的脚本，而不是标准库中的同名模块。 除非有意更换，否则这是错误。更多信息请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/modules.html#tut-standardmodules" target="_blank" rel="noopener">标准模块</a>。</p>
<h3 id="6-1-3-“编译过的”Python文件"><a href="#6-1-3-“编译过的”Python文件" class="headerlink" title="6.1.3. “编译过的”Python文件"></a>6.1.3. “编译过的”Python文件</h3><p>为了加速模块载入，Python在 <code>__pycache__</code> 目录里缓存了每个模块的编译后版本，名称为 <code>module.*version*.pyc</code> ，其中名称中的版本字段对编译文件的格式进行编码； 它一般使用Python版本号。例如，在CPython版本3.3中，spam.py的编译版本将被缓存为 <code>__pycache__/spam.cpython-33.pyc</code>。此命名约定允许来自不同发行版和不同版本的Python的已编译模块共存。</p>
<p>Python根据编译版本检查源的修改日期，以查看它是否已过期并需要重新编译。这是一个完全自动化的过程。此外，编译的模块与平台无关，因此可以在具有不同体系结构的系统之间共享相同的库。</p>
<p>Python在两种情况下不会检查缓存。首先，对于从命令行直接载入的模块，它从来都是重新编译并且不存储编译结果；其次，如果没有源模块，它不会检查缓存。为了支持无源文件（仅编译）发行版本， 编译模块必须是在源目录下，并且绝对不能有源模块。</p>
<p>给专业人士的一些小建议:</p>
<ul>
<li>你可以在Python命令中使用 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-o" target="_blank" rel="noopener"><code>-O</code></a> 或者 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-oo" target="_blank" rel="noopener"><code>-OO</code></a> 开关， 以减小编译后模块的大小。 <code>-O</code> 开关去除断言语句，<code>-OO</code> 开关同时去除断言语句和 <strong>doc</strong> 字符串。由于有些程序可能依赖于这些，你应当只在清楚自己在做什么时才使用这个选项。“优化过的”模块有一个 <code>opt-</code> 标签并且通常小些。将来的发行版本或许会更改优化的效果。</li>
<li>一个从 <code>.pyc</code> 文件读出的程序并不会比它从 <code>.py</code> 读出时运行的更快，<code>.pyc</code> 文件唯一快的地方在于载入速度。</li>
<li><a href="https://docs.python.org/zh-cn/3/library/compileall.html#module-compileall" target="_blank" rel="noopener"><code>compileall</code></a> 模块可以为一个目录下的所有模块创建.pyc文件。</li>
<li>关于这个过程，<a href="https://www.python.org/dev/peps/pep-3147" target="_blank" rel="noopener"><strong>PEP 3147</strong></a> 中有更多细节，包括一个决策流程图。</li>
</ul>
<h2 id="6-2-标准模块"><a href="#6-2-标准模块" class="headerlink" title="6.2. 标准模块"></a>6.2. 标准模块</h2><p>Python附带了一个标准模块库，在单独的文档Python库参考（以下称为“库参考”）中进行了描述。一些模块内置于解释器中；它们提供对不属于语言核心但仍然内置的操作的访问，以提高效率或提供对系统调用等操作系统原语的访问。这些模块的集合是一个配置选项，它也取决于底层平台。例如，<a href="https://docs.python.org/zh-cn/3/library/winreg.html#module-winreg" target="_blank" rel="noopener"><code>winreg</code></a> 模块只在Windows操作系统上提供。一个特别值得注意的模块 <a href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" target="_blank" rel="noopener"><code>sys</code></a>，它被内嵌到每一个Python解释器中。变量 <code>sys.ps1</code> 和 <code>sys.ps2</code> 定义用作主要和辅助提示的字符串:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.ps1</span><br><span class="line">&#39;&gt;&gt;&gt; &#39;</span><br><span class="line">&gt;&gt;&gt; sys.ps2</span><br><span class="line">&#39;... &#39;</span><br><span class="line">&gt;&gt;&gt; sys.ps1 &#x3D; &#39;C&gt; &#39;</span><br><span class="line">C&gt; print(&#39;Yuck!&#39;)</span><br><span class="line">Yuck!</span><br><span class="line">C&gt;</span><br></pre></td></tr></table></figure>

<p>这两个变量只有在编译器是交互模式下才被定义。</p>
<p><code>sys.path</code> 变量是一个字符串列表，用于确定解释器的模块搜索路径。该变量被初始化为从环境变量 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#envvar-PYTHONPATH" target="_blank" rel="noopener"><code>PYTHONPATH</code></a> 获取的默认路径，或者如果 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#envvar-PYTHONPATH" target="_blank" rel="noopener"><code>PYTHONPATH</code></a> 未设置，则从内置默认路径初始化。你可以使用标准列表操作对其进行修改:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#39;&#x2F;ufs&#x2F;guido&#x2F;lib&#x2F;python&#39;)</span><br></pre></td></tr></table></figure>



<h2 id="6-3-dir-函数"><a href="#6-3-dir-函数" class="headerlink" title="6.3. dir() 函数"></a>6.3. <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 函数</h2><p>内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 用于查找模块定义的名称。 它返回一个排序过的字符串列表:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import fibo, sys</span><br><span class="line">&gt;&gt;&gt; dir(fibo)</span><br><span class="line">[&#39;__name__&#39;, &#39;fib&#39;, &#39;fib2&#39;]</span><br><span class="line">&gt;&gt;&gt; dir(sys)  </span><br><span class="line">[&#39;__displayhook__&#39;, &#39;__doc__&#39;, &#39;__excepthook__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;,</span><br><span class="line"> &#39;__package__&#39;, &#39;__stderr__&#39;, &#39;__stdin__&#39;, &#39;__stdout__&#39;,</span><br><span class="line"> &#39;_clear_type_cache&#39;, &#39;_current_frames&#39;, &#39;_debugmallocstats&#39;, &#39;_getframe&#39;,</span><br><span class="line"> &#39;_home&#39;, &#39;_mercurial&#39;, &#39;_xoptions&#39;, &#39;abiflags&#39;, &#39;api_version&#39;, &#39;argv&#39;,</span><br><span class="line"> &#39;base_exec_prefix&#39;, &#39;base_prefix&#39;, &#39;builtin_module_names&#39;, &#39;byteorder&#39;,</span><br><span class="line"> &#39;call_tracing&#39;, &#39;callstats&#39;, &#39;copyright&#39;, &#39;displayhook&#39;,</span><br><span class="line"> &#39;dont_write_bytecode&#39;, &#39;exc_info&#39;, &#39;excepthook&#39;, &#39;exec_prefix&#39;,</span><br><span class="line"> &#39;executable&#39;, &#39;exit&#39;, &#39;flags&#39;, &#39;float_info&#39;, &#39;float_repr_style&#39;,</span><br><span class="line"> &#39;getcheckinterval&#39;, &#39;getdefaultencoding&#39;, &#39;getdlopenflags&#39;,</span><br><span class="line"> &#39;getfilesystemencoding&#39;, &#39;getobjects&#39;, &#39;getprofile&#39;, &#39;getrecursionlimit&#39;,</span><br><span class="line"> &#39;getrefcount&#39;, &#39;getsizeof&#39;, &#39;getswitchinterval&#39;, &#39;gettotalrefcount&#39;,</span><br><span class="line"> &#39;gettrace&#39;, &#39;hash_info&#39;, &#39;hexversion&#39;, &#39;implementation&#39;, &#39;int_info&#39;,</span><br><span class="line"> &#39;intern&#39;, &#39;maxsize&#39;, &#39;maxunicode&#39;, &#39;meta_path&#39;, &#39;modules&#39;, &#39;path&#39;,</span><br><span class="line"> &#39;path_hooks&#39;, &#39;path_importer_cache&#39;, &#39;platform&#39;, &#39;prefix&#39;, &#39;ps1&#39;,</span><br><span class="line"> &#39;setcheckinterval&#39;, &#39;setdlopenflags&#39;, &#39;setprofile&#39;, &#39;setrecursionlimit&#39;,</span><br><span class="line"> &#39;setswitchinterval&#39;, &#39;settrace&#39;, &#39;stderr&#39;, &#39;stdin&#39;, &#39;stdout&#39;,</span><br><span class="line"> &#39;thread_info&#39;, &#39;version&#39;, &#39;version_info&#39;, &#39;warnoptions&#39;]</span><br></pre></td></tr></table></figure>

<p>如果没有参数，<a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 会列出你当前定义的名称:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; import fibo</span><br><span class="line">&gt;&gt;&gt; fib &#x3D; fibo.fib</span><br><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&#39;__builtins__&#39;, &#39;__name__&#39;, &#39;a&#39;, &#39;fib&#39;, &#39;fibo&#39;, &#39;sys&#39;]</span><br></pre></td></tr></table></figure>

<p>注意：它列出所有类型的名称：变量，模块，函数，等等。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 不会列出内置函数和变量的名称。如果你想要这些，它们的定义是在标准模块 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 中:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import builtins</span><br><span class="line">&gt;&gt;&gt; dir(builtins)  </span><br><span class="line">[&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;,</span><br><span class="line"> &#39;BlockingIOError&#39;, &#39;BrokenPipeError&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;,</span><br><span class="line"> &#39;ChildProcessError&#39;, &#39;ConnectionAbortedError&#39;, &#39;ConnectionError&#39;,</span><br><span class="line"> &#39;ConnectionRefusedError&#39;, &#39;ConnectionResetError&#39;, &#39;DeprecationWarning&#39;,</span><br><span class="line"> &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;,</span><br><span class="line"> &#39;FileExistsError&#39;, &#39;FileNotFoundError&#39;, &#39;FloatingPointError&#39;,</span><br><span class="line"> &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;,</span><br><span class="line"> &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;InterruptedError&#39;,</span><br><span class="line"> &#39;IsADirectoryError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;,</span><br><span class="line"> &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotADirectoryError&#39;, &#39;NotImplemented&#39;,</span><br><span class="line"> &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;,</span><br><span class="line"> &#39;PendingDeprecationWarning&#39;, &#39;PermissionError&#39;, &#39;ProcessLookupError&#39;,</span><br><span class="line"> &#39;ReferenceError&#39;, &#39;ResourceWarning&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;,</span><br><span class="line"> &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;,</span><br><span class="line"> &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;TimeoutError&#39;, &#39;True&#39;, &#39;TypeError&#39;,</span><br><span class="line"> &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;,</span><br><span class="line"> &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;,</span><br><span class="line"> &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;_&#39;, &#39;__build_class__&#39;,</span><br><span class="line"> &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;abs&#39;,</span><br><span class="line"> &#39;all&#39;, &#39;any&#39;, &#39;ascii&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;,</span><br><span class="line"> &#39;chr&#39;, &#39;classmethod&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;,</span><br><span class="line"> &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;exec&#39;, &#39;exit&#39;,</span><br><span class="line"> &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;,</span><br><span class="line"> &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;,</span><br><span class="line"> &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;,</span><br><span class="line"> &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;,</span><br><span class="line"> &#39;quit&#39;, &#39;range&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;,</span><br><span class="line"> &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;vars&#39;,</span><br><span class="line"> &#39;zip&#39;]</span><br></pre></td></tr></table></figure>



<h2 id="6-4-包"><a href="#6-4-包" class="headerlink" title="6.4. 包"></a>6.4. 包</h2><p>包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 <code>A.B</code> 表示 <code>A</code> 包中名为 <code>B</code> 的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称一样，使用加点的模块名可以使得 NumPy 或 Pillow 等多模块软件包的作者不必担心彼此的模块名称一样。</p>
<p>假设你想为声音文件和声音数据的统一处理，设计一个模块集合（一个“包”）。由于存在很多不同的声音文件格式（通常由它们的扩展名来识别，例如：<code>.wav</code>， <code>.aiff</code>， <code>.au</code>），因此为了不同文件格式间的转换，你可能需要创建和维护一个不断增长的模块集合。 你可能还想对声音数据还做很多不同的处理（例如，混声，添加回声，使用均衡器功能，创造人工立体声效果）， 因此为了实现这些处理，你将另外写一个无穷尽的模块流。这是你的包的可能结构（以分层文件系统的形式表示）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sound&#x2F;                          Top-level package</span><br><span class="line">      __init__.py               Initialize the sound package</span><br><span class="line">      formats&#x2F;                  Subpackage for file format conversions</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects&#x2F;                  Subpackage for sound effects</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters&#x2F;                  Subpackage for filters</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>

<p>当导入这个包时，Python搜索 <code>sys.path</code> 里的目录，查找包的子目录。</p>
<p>必须要有 <code>__init__.py</code> 文件才能让 Python 将包含该文件的目录当作包。 这样可以防止具有通常名称例如 <code>string</code> 的目录在无意中隐藏稍后在模块搜索路径上出现的有效模块。 在最简单的情况下，<code>__init__.py</code> 可以只是一个空文件，但它也可以执行包的初始化代码或设置 <code>__all__</code> 变量，具体将在后文介绍。</p>
<p>包的用户可以从包中导入单个模块，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import sound.effects.echo</span><br></pre></td></tr></table></figure>

<p>这会加载子模块 <code>sound.effects.echo</code> 。但引用它时必须使用它的全名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sound.effects.echo.echofilter(input, output, delay&#x3D;0.7, atten&#x3D;4)</span><br></pre></td></tr></table></figure>

<p>导入子模块的另一种方法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from sound.effects import echo</span><br></pre></td></tr></table></figure>

<p>这也会加载子模块 <code>echo</code> ，并使其在没有包前缀的情况下可用，因此可以按如下方式使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo.echofilter(input, output, delay&#x3D;0.7, atten&#x3D;4)</span><br></pre></td></tr></table></figure>

<p>另一种形式是直接导入所需的函数或变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from sound.effects.echo import echofilter</span><br></pre></td></tr></table></figure>

<p>同样，这也会加载子模块 <code>echo</code>，但这会使其函数 <code>echofilter()</code> 直接可用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echofilter(input, output, delay&#x3D;0.7, atten&#x3D;4)</span><br></pre></td></tr></table></figure>

<p>请注意，当使用 <code>from package import item</code> 时，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 <code>import</code> 语句首先测试是否在包中定义了item；如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 异常。</p>
<p>相反，当使用 <code>import item.subitem.subsubitem</code> 这样的语法时，除了最后一项之外的每一项都必须是一个包；最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。</p>
<h3 id="6-4-1-从包中导入"><a href="#6-4-1-从包中导入" class="headerlink" title="6.4.1. 从包中导入 *"></a>6.4.1. 从包中导入 *</h3><p>当用户写 <code>from sound.effects import *</code> 会发生什么？理想情况下，人们希望这会以某种方式传递给文件系统，找到包中存在哪些子模块，并将它们全部导入。这可能需要很长时间，导入子模块可能会产生不必要的副作用，这种副作用只有在显式导入子模块时才会发生。</p>
<p>唯一的解决方案是让包作者提供一个包的显式索引。<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句使用下面的规范：如果一个包的 <code>__init__.py</code> 代码定义了一个名为 <code>__all__</code> 的列表，它会被视为在遇到 <code>from package import *</code> 时应该导入的模块名列表。在发布该包的新版本时，包作者可以决定是否让此列表保持更新。包作者如果认为从他们的包中导入 * 的操作没有必要被使用，也可以决定不支持此列表。例如，文件 <code>sound/effects/__init__.py</code> 可以包含以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ &#x3D; [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</span><br></pre></td></tr></table></figure>

<p>这意味着 <code>from sound.effects import *</code> 将导入 <code>sound</code> 包的三个命名子模块。</p>
<p>如果没有定义 <code>__all__</code>，<code>from sound.effects import *</code> 语句 <em>不</em> 会从包 <code>sound.effects</code> 中导入所有子模块到当前命名空间；它只确保导入了包 <code>sound.effects</code> （可能运行任何在 <code>__init__.py</code> 中的初始化代码），然后导入包中定义的任何名称。这包括 <code>__init__.py`` 定义的任何名称（以及显式加载的子模块）。它还包括由之前的 [</code>import`](<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import</a>) 语句显式加载的包的任何子模块。思考下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sound.effects.echo</span><br><span class="line">import sound.effects.surround</span><br><span class="line">from sound.effects import *</span><br></pre></td></tr></table></figure>

<p>在这个例子中， <code>echo</code> 和 <code>surround</code> 模块是在执行 <code>from...import</code> 语句时导入到当前命名空间中的，因为它们定义在 <code>sound.effects</code> 包中。（这在定义了 <code>__all__</code> 时也有效。）</p>
<p>虽然某些模块被设计为在使用 <code>import *</code> 时只导出遵循某些模式的名称，但在生产代码中它仍然被认为是不好的做法。</p>
<p>请记住，使用 <code>from package import specific_submodule</code> 没有任何问题！ 实际上，除非导入的模块需要使用来自不同包的同名子模块，否则这是推荐的表示法。</p>
<h3 id="6-4-2-子包参考"><a href="#6-4-2-子包参考" class="headerlink" title="6.4.2. 子包参考"></a>6.4.2. 子包参考</h3><p>当包被构造成子包时（与示例中的 <code>sound</code> 包一样），你可以使用绝对导入来引用兄弟包的子模块。例如，如果模块 <code>sound.filters.vocoder</code> 需要在 <code>sound.effects</code> 包中使用 <code>echo</code> 模块，它可以使用 <code>from sound.effects import echo</code> 。</p>
<p>你还可以使用import语句的 <code>from module import name</code> 形式编写相对导入。这些导入使用前导点来指示相对导入中涉及的当前包和父包。例如，从 <code>surround</code> 模块，你可以使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from . import echo</span><br><span class="line">from .. import formats</span><br><span class="line">from ..filters import equalizer</span><br></pre></td></tr></table></figure>

<p>请注意，相对导入是基于当前模块的名称进行导入的。由于主模块的名称总是 <code>&quot;__main__&quot;</code> ，因此用作Python应用程序主模块的模块必须始终使用绝对导入。</p>
<h3 id="6-4-3-多个目录中的包"><a href="#6-4-3-多个目录中的包" class="headerlink" title="6.4.3. 多个目录中的包"></a>6.4.3. 多个目录中的包</h3><p>包支持另一个特殊属性， <a href="https://docs.python.org/zh-cn/3/reference/import.html#__path__" target="_blank" rel="noopener"><code>__path__</code></a> 。它被初始化为一个列表，其中包含在执行该文件中的代码之前保存包的文件 <code>__init__.py</code> 的目录的名称。这个变量可以修改；这样做会影响将来对包中包含的模块和子包的搜索。</p>
<p>虽然通常不需要此功能，但它可用于扩展程序包中的模块集。</p>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/modules.html#id1" target="_blank" rel="noopener">1</a></p>
<p>实际上，函数定义也是“被执行”的“语句”；模块级函数定义的执行在模块的全局符号表中输入该函数名。</p>
</li>
</ul>
<h1 id="7-输入输出"><a href="#7-输入输出" class="headerlink" title="7. 输入输出"></a>7. 输入输出</h1><p>有几种方法可以显示程序的输出；数据可以以人类可读的形式打印出来，或者写入文件以供将来使用。本章将讨论一些可能性。</p>
<h2 id="7-1-更漂亮的输出格式"><a href="#7-1-更漂亮的输出格式" class="headerlink" title="7.1. 更漂亮的输出格式"></a>7.1. 更漂亮的输出格式</h2><p>到目前为止，我们遇到了两种写入值的方法：<em>表达式语句</em> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数。（第三种是使用文件对象的 <code>write()</code> 方法；标准输出文件可以作为 <code>sys.stdout</code> 引用。更多相关信息可参考标准库指南。）</p>
<p>通常，你需要更多地控制输出的格式，而不仅仅是打印空格分隔的值。有几种格式化输出的方法。</p>
<ul>
<li><p>要使用 <a href="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#tut-f-strings" target="_blank" rel="noopener">格式化字符串字面值</a> ，请在字符串的开始引号或三引号之前加上一个 <code>f</code> 或 <code>F</code> 。在此字符串中，你可以在 <code>{</code> 和 <code>}</code> 字符之间写可以引用的变量或字面值的 Python 表达式。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; year &#x3D; 2016</span><br><span class="line">&gt;&gt;&gt; event &#x3D; &#39;Referendum&#39;</span><br><span class="line">&gt;&gt;&gt; f&#39;Results of the &#123;year&#125; &#123;event&#125;&#39;</span><br><span class="line">&#39;Results of the 2016 Referendum&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 方法需要更多的手动操作。你仍将使用 <code>{</code> 和 <code>}</code> 来标记变量将被替换的位置，并且可以提供详细的格式化指令，但你还需要提供要格式化的信息。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; yes_votes &#x3D; 42_572_654</span><br><span class="line">&gt;&gt;&gt; no_votes &#x3D; 43_132_495</span><br><span class="line">&gt;&gt;&gt; percentage &#x3D; yes_votes &#x2F; (yes_votes + no_votes)</span><br><span class="line">&gt;&gt;&gt; &#39;&#123;:-9&#125; YES votes  &#123;:2.2%&#125;&#39;.format(yes_votes, percentage)</span><br><span class="line">&#39; 42572654 YES votes  49.67%&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，你可以使用字符串切片和连接操作自己完成所有的字符串处理，以创建你可以想象的任何布局。字符串类型有一些方法可以执行将字符串填充到给定列宽的有用操作。</p>
</li>
</ul>
<p>当你不需要花哨的输出而只是想快速显示某些变量以进行调试时，可以使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> or <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 函数将任何值转化为字符串。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 函数是用于返回人类可读的值的表示，而 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 是用于生成解释器可读的表示（如果没有等效的语法，则会强制执行 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>）对于没有人类可读性的表示的对象， <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 将返回和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 一样的值。很多值使用任一函数都具有相同的表示，比如数字或类似列表和字典的结构。特殊的是字符串有两个不同的表示。</p>
<p>几个例子:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &#39;Hello, world.&#39;</span><br><span class="line">&gt;&gt;&gt; str(s)</span><br><span class="line">&#39;Hello, world.&#39;</span><br><span class="line">&gt;&gt;&gt; repr(s)</span><br><span class="line">&quot;&#39;Hello, world.&#39;&quot;</span><br><span class="line">&gt;&gt;&gt; str(1&#x2F;7)</span><br><span class="line">&#39;0.14285714285714285&#39;</span><br><span class="line">&gt;&gt;&gt; x &#x3D; 10 * 3.25</span><br><span class="line">&gt;&gt;&gt; y &#x3D; 200 * 200</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;The value of x is &#39; + repr(x) + &#39;, and y is &#39; + repr(y) + &#39;...&#39;</span><br><span class="line">&gt;&gt;&gt; print(s)</span><br><span class="line">The value of x is 32.5, and y is 40000...</span><br><span class="line">&gt;&gt;&gt; # The repr() of a string adds string quotes and backslashes:</span><br><span class="line">... hello &#x3D; &#39;hello, world\n&#39;</span><br><span class="line">&gt;&gt;&gt; hellos &#x3D; repr(hello)</span><br><span class="line">&gt;&gt;&gt; print(hellos)</span><br><span class="line">&#39;hello, world\n&#39;</span><br><span class="line">&gt;&gt;&gt; # The argument to repr() may be any Python object:</span><br><span class="line">... repr((x, y, (&#39;spam&#39;, &#39;eggs&#39;)))</span><br><span class="line">&quot;(32.5, 40000, (&#39;spam&#39;, &#39;eggs&#39;))&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/string.html#module-string" target="_blank" rel="noopener"><code>string</code></a> 模块包含一个 <a href="https://docs.python.org/zh-cn/3/library/string.html#string.Template" target="_blank" rel="noopener"><code>Template</code></a> 类，它提供了另一种将值替换为字符串的方法，使用类似 <code>$x</code> 的占位符并用字典中的值替换它们，但对格式的控制要少的多。</p>
<h3 id="7-1-1-格式化字符串文字"><a href="#7-1-1-格式化字符串文字" class="headerlink" title="7.1.1. 格式化字符串文字"></a>7.1.1. 格式化字符串文字</h3><p><a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings" target="_blank" rel="noopener">格式化字符串字面值</a> （常简称为 f-字符串）能让你在字符串前加上 <code>f</code> 和 <code>F</code> 并将表达式写成 <code>{expression}</code> 来在字符串中包含 Python 表达式的值。</p>
<p>可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。以下示例将pi舍入到小数点后三位:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; print(f&#39;The value of pi is approximately &#123;math.pi:.3f&#125;.&#39;)</span><br><span class="line">The value of pi is approximately 3.142.</span><br></pre></td></tr></table></figure>

<p>在 <code>&#39;:&#39;</code> 后传递一个整数可以让该字段成为最小字符宽度。这在使列对齐时很有用。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; table &#x3D; &#123;&#39;Sjoerd&#39;: 4127, &#39;Jack&#39;: 4098, &#39;Dcab&#39;: 7678&#125;</span><br><span class="line">&gt;&gt;&gt; for name, phone in table.items():</span><br><span class="line">...     print(f&#39;&#123;name:10&#125; &#x3D;&#x3D;&gt; &#123;phone:10d&#125;&#39;)</span><br><span class="line">...</span><br><span class="line">Sjoerd     &#x3D;&#x3D;&gt;       4127</span><br><span class="line">Jack       &#x3D;&#x3D;&gt;       4098</span><br><span class="line">Dcab       &#x3D;&#x3D;&gt;       7678</span><br></pre></td></tr></table></figure>

<p>其他的修饰符可用于在格式化之前转化值。 <code>&#39;!a&#39;</code> 应用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#ascii" target="_blank" rel="noopener"><code>ascii()</code></a> ，<code>&#39;!s&#39;</code> 应用 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，还有 <code>&#39;!r&#39;</code> 应用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; animals &#x3D; &#39;eels&#39;</span><br><span class="line">&gt;&gt;&gt; print(f&#39;My hovercraft is full of &#123;animals&#125;.&#39;)</span><br><span class="line">My hovercraft is full of eels.</span><br><span class="line">&gt;&gt;&gt; print(f&#39;My hovercraft is full of &#123;animals!r&#125;.&#39;)</span><br><span class="line">My hovercraft is full of &#39;eels&#39;.</span><br></pre></td></tr></table></figure>

<p>有关这些格式规范的参考，请参阅参考指南 <a href="https://docs.python.org/zh-cn/3/library/string.html#formatspec" target="_blank" rel="noopener">格式规格迷你语言</a>。</p>
<h3 id="7-1-2-字符串的-format-方法"><a href="#7-1-2-字符串的-format-方法" class="headerlink" title="7.1.2. 字符串的 format() 方法"></a>7.1.2. 字符串的 format() 方法</h3><p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 方法的基本用法如下所示:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#39;We are the &#123;&#125; who say &quot;&#123;&#125;!&quot;&#39;.format(&#39;knights&#39;, &#39;Ni&#39;))</span><br><span class="line">We are the knights who say &quot;Ni!&quot;</span><br></pre></td></tr></table></figure>

<p>花括号和其中的字符（称为格式字段）将替换为传递给 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 方法的对象。花括号中的数字可用来表示传递给 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 方法的对象的位置。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#39;&#123;0&#125; and &#123;1&#125;&#39;.format(&#39;spam&#39;, &#39;eggs&#39;))</span><br><span class="line">spam and eggs</span><br><span class="line">&gt;&gt;&gt; print(&#39;&#123;1&#125; and &#123;0&#125;&#39;.format(&#39;spam&#39;, &#39;eggs&#39;))</span><br><span class="line">eggs and spam</span><br></pre></td></tr></table></figure>

<p>如果在 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 方法中使用关键字参数，则使用参数的名称引用它们的值。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#39;This &#123;food&#125; is &#123;adjective&#125;.&#39;.format(</span><br><span class="line">...       food&#x3D;&#39;spam&#39;, adjective&#x3D;&#39;absolutely horrible&#39;))</span><br><span class="line">This spam is absolutely horrible.</span><br></pre></td></tr></table></figure>

<p>位置和关键字参数可以任意组合:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#39;The story of &#123;0&#125;, &#123;1&#125;, and &#123;other&#125;.&#39;.format(&#39;Bill&#39;, &#39;Manfred&#39;,</span><br><span class="line">                                                       other&#x3D;&#39;Georg&#39;))</span><br><span class="line">The story of Bill, Manfred, and Georg.</span><br></pre></td></tr></table></figure>

<p>如果你有一个非常长的格式字符串，你不想把它拆开，那么你最好按名称而不是位置引用变量来进行格式化。这可以通过简单地传递字典和使用方括号 <code>&#39;[]&#39;</code> 访问键来完成:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; table &#x3D; &#123;&#39;Sjoerd&#39;: 4127, &#39;Jack&#39;: 4098, &#39;Dcab&#39;: 8637678&#125;</span><br><span class="line">&gt;&gt;&gt; print(&#39;Jack: &#123;0[Jack]:d&#125;; Sjoerd: &#123;0[Sjoerd]:d&#125;; &#39;</span><br><span class="line">...       &#39;Dcab: &#123;0[Dcab]:d&#125;&#39;.format(table))</span><br><span class="line">Jack: 4098; Sjoerd: 4127; Dcab: 8637678</span><br></pre></td></tr></table></figure>

<p>这也可以通过使用 ‘**’ 符号将 table 作为关键字参数传递。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; table &#x3D; &#123;&#39;Sjoerd&#39;: 4127, &#39;Jack&#39;: 4098, &#39;Dcab&#39;: 8637678&#125;</span><br><span class="line">&gt;&gt;&gt; print(&#39;Jack: &#123;Jack:d&#125;; Sjoerd: &#123;Sjoerd:d&#125;; Dcab: &#123;Dcab:d&#125;&#39;.format(**table))</span><br><span class="line">Jack: 4098; Sjoerd: 4127; Dcab: 8637678</span><br></pre></td></tr></table></figure>

<p>这在与内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#vars" target="_blank" rel="noopener"><code>vars()</code></a> 结合使用时非常有用，它会返回包含所有局部变量的字典。</p>
<p>例如，下面几行代码生成一组整齐的列，其中包含给定的整数和它的平方以及立方:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...     print(&#39;&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;&#39;.format(x, x*x, x*x*x))</span><br><span class="line">...</span><br><span class="line"> 1   1    1</span><br><span class="line"> 2   4    8</span><br><span class="line"> 3   9   27</span><br><span class="line"> 4  16   64</span><br><span class="line"> 5  25  125</span><br><span class="line"> 6  36  216</span><br><span class="line"> 7  49  343</span><br><span class="line"> 8  64  512</span><br><span class="line"> 9  81  729</span><br><span class="line">10 100 1000</span><br></pre></td></tr></table></figure>

<p>关于使用 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 进行字符串格式化的完整概述，请参阅 <a href="https://docs.python.org/zh-cn/3/library/string.html#formatstrings" target="_blank" rel="noopener">格式字符串语法</a> 。</p>
<h3 id="7-1-3-手动格式化字符串"><a href="#7-1-3-手动格式化字符串" class="headerlink" title="7.1.3. 手动格式化字符串"></a>7.1.3. 手动格式化字符串</h3><p>这是同一个平方和立方的表，手动格式化的:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...     print(repr(x).rjust(2), repr(x*x).rjust(3), end&#x3D;&#39; &#39;)</span><br><span class="line">...     # Note use of &#39;end&#39; on previous line</span><br><span class="line">...     print(repr(x*x*x).rjust(4))</span><br><span class="line">...</span><br><span class="line"> 1   1    1</span><br><span class="line"> 2   4    8</span><br><span class="line"> 3   9   27</span><br><span class="line"> 4  16   64</span><br><span class="line"> 5  25  125</span><br><span class="line"> 6  36  216</span><br><span class="line"> 7  49  343</span><br><span class="line"> 8  64  512</span><br><span class="line"> 9  81  729</span><br><span class="line">10 100 1000</span><br></pre></td></tr></table></figure>

<p>（注意每列之间的一个空格是通过使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 的方式添加的：它总是在其参数间添加空格。）</p>
<p>字符串对象的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.rjust" target="_blank" rel="noopener"><code>str.rjust()</code></a> 方法通过在左侧填充空格来对给定宽度的字段中的字符串进行右对齐。类似的方法还有 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.ljust" target="_blank" rel="noopener"><code>str.ljust()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.center" target="_blank" rel="noopener"><code>str.center()</code></a> 。这些方法不会写入任何东西，它们只是返回一个新的字符串，如果输入的字符串太长，它们不会截断字符串，而是原样返回；这虽然会弄乱你的列布局，但这通常比另一种方法好，后者会在显示值时可能不准确（如果你真的想截断，你可以添加一个切片操作，例如 <code>x.ljust(n)[:n]</code> 。）</p>
<p>还有另外一个方法，<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.zfill" target="_blank" rel="noopener"><code>str.zfill()</code></a> ，它会在数字字符串的左边填充零。它能识别正负号:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;12&#39;.zfill(5)</span><br><span class="line">&#39;00012&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;-3.14&#39;.zfill(7)</span><br><span class="line">&#39;-003.14&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;3.14159265359&#39;.zfill(5)</span><br><span class="line">&#39;3.14159265359&#39;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-4-旧的字符串格式化方法"><a href="#7-1-4-旧的字符串格式化方法" class="headerlink" title="7.1.4. 旧的字符串格式化方法"></a>7.1.4. 旧的字符串格式化方法</h3><p><code>%</code> 操作符也可以用作字符串格式化。它将左边的参数解释为一个很像 <code>sprintf()</code> 风格 的格式字符串，应用到右边的参数，并返回一个由此格式化操作产生的字符串。例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; print(&#39;The value of pi is approximately %5.3f.&#39; % math.pi)</span><br><span class="line">The value of pi is approximately 3.142.</span><br></pre></td></tr></table></figure>

<p>可在 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#old-string-formatting" target="_blank" rel="noopener">printf 风格的字符串格式化</a> 部分找到更多信息。</p>
<h2 id="7-2-读写文件"><a href="#7-2-读写文件" class="headerlink" title="7.2. 读写文件"></a>7.2. 读写文件</h2><p><a href="https://docs.python.org/zh-cn/3/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 返回一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>，最常用的有两个参数： <code>open(filename, mode)</code>。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;workfile&#39;, &#39;w&#39;)</span><br></pre></td></tr></table></figure>

<p>第一个参数是包含文件名的字符串。第二个参数是另一个字符串，其中包含一些描述文件使用方式的字符。<em>mode</em> 可以是 <code>&#39;r&#39;</code> ，表示文件只能读取，<code>&#39;w&#39;</code> 表示只能写入（已存在的同名文件会被删除），还有 <code>&#39;a&#39;</code> 表示打开文件以追加内容；任何写入的数据会自动添加到文件的末尾。<code>&#39;r+&#39;</code> 表示打开文件进行读写。<em>mode</em> 参数是可选的；省略时默认为 <code>&#39;r&#39;</code>。</p>
<p>通常文件是以 <em>text mode</em> 打开的，这意味着从文件中读取或写入字符串时，都会以指定的编码方式进行编码。如果未指定编码格式，默认值与平台相关 (参见 <a href="https://docs.python.org/zh-cn/3/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>)。在mode 中追加的 <code>&#39;b&#39;</code> 则以 <em>binary mode</em> 打开文件：现在数据是以字节对象的形式进行读写的。这个模式应该用于所有不包含文本的文件。</p>
<p>在文本模式下读取时，默认会把平台特定的行结束符 (Unix 上的 <code>\n</code>, Windows 上的 <code>\r\n</code>) 转换为 <code>\n</code>。在文本模式下写入时，默认会把出现的 <code>\n</code> 转换回平台特定的结束符。这样在幕后修改文件数据对文本文件来说没有问题，但是会破坏二进制数据例如 <code>JPEG</code> 或 <code>EXE</code> 文件中的数据。请一定要注意在读写此类文件时应使用二进制模式。</p>
<p>在处理文件对象时，最好使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 关键字。 优点是当子句体结束后文件会正确关闭，即使在某个时刻引发了异常。 而且使用 <code>with</code> 相比等效的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a>-<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 代码块要简短得多:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&#39;workfile&#39;) as f:</span><br><span class="line">...     read_data &#x3D; f.read()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # We can check that the file has been automatically closed.</span><br><span class="line">&gt;&gt;&gt; f.closed</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>如果你没有使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 关键字，那么你应该调用 <code>f.close()</code> 来关闭文件并立即释放它使用的所有系统资源。如果你没有显式地关闭文件，Python的垃圾回收器最终将销毁该对象并为你关闭打开的文件，但这个文件可能会保持打开状态一段时间。另外一个风险是不同的Python实现会在不同的时间进行清理。</p>
<p>通过 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句或者调用 <code>f.close()</code> 关闭文件对象后，尝试使用该文件对象将自动失败。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: I&#x2F;O operation on closed file.</span><br></pre></td></tr></table></figure>



<h3 id="7-2-1-文件对象的方法"><a href="#7-2-1-文件对象的方法" class="headerlink" title="7.2.1. 文件对象的方法"></a>7.2.1. 文件对象的方法</h3><p>本节中剩下的例子将假定你已创建名为 <code>f</code> 的文件对象。</p>
<p>要读取文件内容，请调用 <code>f.read(size)</code>，它会读取一些数据并将其作为字符串（在文本模式下）或字节串对象（在二进制模式下）返回。 <em>size</em> 是一个可选的数值参数。 当 <em>size</em> 被省略或者为负数时，将读取并返回整个文件的内容；如果文件的大小是你的机器内存的两倍就会出现问题。 当取其他值时，将读取并返回至多 <em>size</em> 个字符（在文本模式下）或 <em>size</em> 个字节（在二进制模式下）。 如果已到达文件末尾，<code>f.read()</code> 将返回一个空字符串 (<code>&#39;&#39;</code>)。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&#39;This is the entire file.\n&#39;</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&#39;&#39;</span><br></pre></td></tr></table></figure>

<p><code>f.readline()</code> 从文件中读取一行；换行符（<code>\n</code>）留在字符串的末尾，如果文件不以换行符结尾，则在文件的最后一行省略。这使得返回值明确无误；如果 <code>f.readline()</code> 返回一个空的字符串，则表示已经到达了文件末尾，而空行使用 <code>&#39;\n&#39;</code> 表示，该字符串只包含一个换行符。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&#39;This is the first line of the file.\n&#39;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&#39;Second line of the file\n&#39;</span><br><span class="line">&gt;&gt;&gt; f.readline()</span><br><span class="line">&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>要从文件中读取行，你可以循环遍历文件对象。这是内存高效，快速的，并简化代码:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for line in f:</span><br><span class="line">...     print(line, end&#x3D;&#39;&#39;)</span><br><span class="line">...</span><br><span class="line">This is the first line of the file.</span><br><span class="line">Second line of the file</span><br></pre></td></tr></table></figure>

<p>如果你想以列表的形式读取文件中的所有行，你也可以使用 <code>list(f)</code> 或 <code>f.readlines()</code>。</p>
<p><code>f.write(string)</code> 会把 <em>string</em> 的内容写入到文件中，并返回写入的字符数。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.write(&#39;This is a test\n&#39;)</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>在写入其他类型的对象之前，需要先把它们转化为字符串（在文本模式下）或者字节对象（在二进制模式下）:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; value &#x3D; (&#39;the answer&#39;, 42)</span><br><span class="line">&gt;&gt;&gt; s &#x3D; str(value)  # convert the tuple to string</span><br><span class="line">&gt;&gt;&gt; f.write(s)</span><br><span class="line">18</span><br></pre></td></tr></table></figure>

<p><code>f.tell()</code> 返回一个整数，给出文件对象在文件中的当前位置，表示为二进制模式下时从文件开始的字节数，以及文本模式下的意义不明的数字。</p>
<p>要改变文件对象的位置，请使用 <code>f.seek(offset, whence)</code>。 通过向一个参考点添加 <em>offset</em> 来计算位置；参考点由 <em>whence</em> 参数指定。 <em>whence</em> 的 0 值表示从文件开头起算，1 表示使用当前文件位置，2 表示使用文件末尾作为参考点。 <em>whence</em> 如果省略则默认值为 0，即使用文件开头作为参考点。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; open(&#39;workfile&#39;, &#39;rb+&#39;)</span><br><span class="line">&gt;&gt;&gt; f.write(b&#39;0123456789abcdef&#39;)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; f.seek(5)      # Go to the 6th byte in the file</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; f.read(1)</span><br><span class="line">b&#39;5&#39;</span><br><span class="line">&gt;&gt;&gt; f.seek(-3, 2)  # Go to the 3rd byte before the end</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; f.read(1)</span><br><span class="line">b&#39;d&#39;</span><br></pre></td></tr></table></figure>

<p>在文本文件（那些在模式字符串中没有 <code>b</code> 的打开的文件）中，只允许相对于文件开头搜索（使用 <code>seek(0, 2)</code> 搜索到文件末尾是个例外）并且唯一有效的 <em>offset</em> 值是那些能从 <code>f.tell()</code> 中返回的或者是零。其他 <em>offset</em> 值都会产生未定义的行为。</p>
<p>文件对象有一些额外的方法，例如 <code>isatty()</code> 和 <code>truncate()</code> ，它们使用频率较低；有关文件对象的完整指南请参阅库参考。</p>
<h3 id="7-2-2-使用-json-保存结构化数据"><a href="#7-2-2-使用-json-保存结构化数据" class="headerlink" title="7.2.2. 使用 json 保存结构化数据"></a>7.2.2. 使用 <a href="https://docs.python.org/zh-cn/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 保存结构化数据</h3><p>字符串可以很轻松地写入文件并从文件中读取出来。数字可能会费点劲，因为 <code>read()</code> 方法只能返回字符串，这些字符串必须传递给类似 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a> 的函数，它会接受类似 <code>&#39;123&#39;</code> 这样的字符串并返回其数字值 123。当你想保存诸如嵌套列表和字典这样更复杂的数据类型时，手动解析和序列化会变得复杂。</p>
<p>Python 允许你使用称为 <a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a> 的流行数据交换格式，而不是让用户不断的编写和调试代码以将复杂的数据类型保存到文件中。名为 <a href="https://docs.python.org/zh-cn/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 的标准模块可以采用 Python 数据层次结构，并将它们转化为字符串表示形式；这个过程称为 <em>serializing</em> 。从字符串表示中重建数据称为 <em>deserializing</em> 。在序列化和反序列化之间，表示对象的字符串可能已存储在文件或数据中，或通过网络连接发送到某个远程机器。</p>
<p>注解</p>
<p>JSON格式通常被现代应用程序用于允许数据交换。许多程序员已经熟悉它，这使其成为互操作性的良好选择。</p>
<p>如果你有一个对象 <code>x</code> ，你可以用一行简单的代码来查看它的 JSON 字符串表示:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; json.dumps([1, &#39;simple&#39;, &#39;list&#39;])</span><br><span class="line">&#39;[1, &quot;simple&quot;, &quot;list&quot;]&#39;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/json.html#json.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数的另一个变体叫做 <a href="https://docs.python.org/zh-cn/3/library/json.html#json.dump" target="_blank" rel="noopener"><code>dump()</code></a> ，它只是将对象序列化为 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file" target="_blank" rel="noopener">text file</a> 。因此，如果 <code>f</code> 是一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file" target="_blank" rel="noopener">text file</a> 对象，我们可以这样做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.dump(x, f)</span><br></pre></td></tr></table></figure>

<p>要再次解码对象，如果 <code>f</code> 是一个打开的以供阅读的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-text-file" target="_blank" rel="noopener">text file</a> 对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; json.load(f)</span><br></pre></td></tr></table></figure>

<p>这种简单的序列化技术可以处理列表和字典，但是在JSON中序列化任意类的实例需要额外的努力。 <a href="https://docs.python.org/zh-cn/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 模块的参考包含对此的解释。</p>
<p>参见</p>
<p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> - 封存模块</p>
<p>与 <a href="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#tut-json" target="_blank" rel="noopener">JSON</a> 不同，<em>pickle</em> 是一种允许对任意复杂 Python 对象进行序列化的协议。因此，它为 Python 所特有，不能用于与其他语言编写的应用程序通信。默认情况下它也是不安全的：如果数据是由熟练的攻击者精心设计的，则反序列化来自不受信任来源的 pickle 数据可以执行任意代码。</p>
<h1 id="8-错误和异常"><a href="#8-错误和异常" class="headerlink" title="8. 错误和异常"></a>8. 错误和异常</h1><p>到目前为止，我们还没有提到错误消息，但是如果你已经尝试过那些例子，你可能已经看过了一些错误消息。 目前（至少）有两种可区分的错误：<em>语法错误</em> 和 <em>异常</em>。</p>
<h2 id="8-1-语法错误"><a href="#8-1-语法错误" class="headerlink" title="8.1. 语法错误"></a>8.1. 语法错误</h2><p>语法错误又称解析错误，可能是你在学习Python 时最容易遇到的错误:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True print(&#39;Hello world&#39;)</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    while True print(&#39;Hello world&#39;)</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到第一个错误。 错误是由箭头指示的位置 <em>上面</em> 的 token 引起的（或者至少是在这里被检测出的）：在示例中，在 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 这个函数中检测到了错误，因为在它前面少了个冒号 (<code>&#39;:&#39;</code>) 。文件名和行号也会被输出，以便输入来自脚本文件时你能知道去哪检查。</p>
<h2 id="8-2-异常"><a href="#8-2-异常" class="headerlink" title="8.2. 异常"></a>8.2. 异常</h2><p>即使语句或表达式在语法上是正确的，但在尝试执行时，它仍可能会引发错误。 在执行时检测到的错误被称为<em>异常</em>，异常不一定会导致严重后果：你将很快学会如何在Python程序中处理它们。 但是，大多数异常并不会被程序处理，此时会显示如下所示的错误信息:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 * (1&#x2F;0)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line">&gt;&gt;&gt; 4 + spam*3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &#39;spam&#39; is not defined</span><br><span class="line">&gt;&gt;&gt; &#39;2&#39; + 2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: Can&#39;t convert &#39;int&#39; object to str implicitly</span><br></pre></td></tr></table></figure>

<p>错误信息的最后一行告诉我们程序遇到了什么类型的错误。异常有不同的类型，而其类型名称将会作为错误信息的一部分中打印出来：上述示例中的异常类型依次是：<a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>， <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这是一个有用的规范）。标准的异常类型是内置的标识符（而不是保留关键字）。</p>
<p>这一行的剩下的部分根据异常类型及其原因提供详细信息。</p>
<p>错误信息的前一部分以堆栈回溯的形式显示发生异常时的上下文。通常它包含列出源代码行的堆栈回溯；但是它不会显示从标准输入中读取的行。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/exceptions.html#bltin-exceptions" target="_blank" rel="noopener">内置异常</a> 列出了内置异常和它们的含义。</p>
<h2 id="8-3-处理异常"><a href="#8-3-处理异常" class="headerlink" title="8.3. 处理异常"></a>8.3. 处理异常</h2><p>可以编写处理所选异常的程序。请看下面的例子，它会要求用户一直输入，直到输入的是一个有效的整数，但允许用户中断程序（使用 Control-C 或操作系统支持的其他操作）；请注意用户引起的中断可以通过引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常来指示。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     try:</span><br><span class="line">...         x &#x3D; int(input(&quot;Please enter a number: &quot;))</span><br><span class="line">...         break</span><br><span class="line">...     except ValueError:</span><br><span class="line">...         print(&quot;Oops!  That was no valid number.  Try again...&quot;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的工作原理如下。</p>
<ul>
<li>首先，执行 <em>try 子句</em> （<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 关键字之间的（多行）语句）。</li>
<li>如果没有异常发生，则跳过 <em>except 子句</em> 并完成 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的执行。</li>
<li>如果在执行try 子句时发生了异常，则跳过该子句中剩下的部分。然后，如果异常的类型和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 关键字后面的异常匹配，则执行 except 子句 ，然后继续执行 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句之后的代码。</li>
<li>如果发生的异常和 except 子句中指定的异常不匹配，则将其传递到外部的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中；如果没有找到处理程序，则它是一个 <em>未处理异常</em>，执行将停止并显示如上所示的消息。</li>
</ul>
<p>一个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句可能有多个 except 子句，以指定不同异常的处理程序。 最多会执行一个处理程序。 处理程序只处理相应的 try 子句中发生的异常，而不处理同一 <code>try</code> 语句内其他处理程序中的异常。 一个 except 子句可以将多个异常命名为带括号的元组，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... except (RuntimeError, TypeError, NameError):</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure>

<p>如果发生的异常和 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句中的类是同一个类或者是它的基类，则异常和 except 子句中的类是兼容的（但反过来则不成立 — 列出派生类的 except 子句与基类不兼容）。 例如，下面的代码将依次打印 B, C, D</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class B(Exception):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class C(B):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class D(C):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">for cls in [B, C, D]:</span><br><span class="line">    try:</span><br><span class="line">        raise cls()</span><br><span class="line">    except D:</span><br><span class="line">        print(&quot;D&quot;)</span><br><span class="line">    except C:</span><br><span class="line">        print(&quot;C&quot;)</span><br><span class="line">    except B:</span><br><span class="line">        print(&quot;B&quot;)</span><br></pre></td></tr></table></figure>

<p>请注意如果 except 子句被颠倒（把 <code>except B</code> 放到第一个），它将打印 B，B，B — 即第一个匹配的 except 子句被触发。</p>
<p>最后的 except 子句可以省略异常名，以用作通配符。但请谨慎使用，因为以这种方式很容易掩盖真正的编程错误！它还可用于打印错误消息，然后重新引发异常（同样允许调用者处理异常）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    f &#x3D; open(&#39;myfile.txt&#39;)</span><br><span class="line">    s &#x3D; f.readline()</span><br><span class="line">    i &#x3D; int(s.strip())</span><br><span class="line">except OSError as err:</span><br><span class="line">    print(&quot;OS error: &#123;0&#125;&quot;.format(err))</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;Could not convert data to an integer.&quot;)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])</span><br><span class="line">    raise</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 语句有一个可选的 <em>else 子句</em>，在使用时必须放在所有的 except 子句后面。对于在try 子句不引发异常时必须执行的代码来说很有用。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for arg in sys.argv[1:]:</span><br><span class="line">    try:</span><br><span class="line">        f &#x3D; open(arg, &#39;r&#39;)</span><br><span class="line">    except OSError:</span><br><span class="line">        print(&#39;cannot open&#39;, arg)</span><br><span class="line">    else:</span><br><span class="line">        print(arg, &#39;has&#39;, len(f.readlines()), &#39;lines&#39;)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<p>使用 <code>else</code> 子句比向 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 子句添加额外的代码要好，因为它避免了意外捕获由 <code>try</code> … <code>except</code> 语句保护的代码未引发的异常。</p>
<p>发生异常时，它可能具有关联值，也称为异常 <em>参数</em> 。参数的存在和类型取决于异常类型。</p>
<p>except 子句可以在异常名称后面指定一个变量。这个变量和一个异常实例绑定，它的参数存储在 <code>instance.args</code> 中。为了方便起见，异常实例定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a> ，因此可以直接打印参数而无需引用 <code>.args</code> 。也可以在抛出之前首先实例化异常，并根据需要向其添加任何属性。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     raise Exception(&#39;spam&#39;, &#39;eggs&#39;)</span><br><span class="line">... except Exception as inst:</span><br><span class="line">...     print(type(inst))    # the exception instance</span><br><span class="line">...     print(inst.args)     # arguments stored in .args</span><br><span class="line">...     print(inst)          # __str__ allows args to be printed directly,</span><br><span class="line">...                          # but may be overridden in exception subclasses</span><br><span class="line">...     x, y &#x3D; inst.args     # unpack args</span><br><span class="line">...     print(&#39;x &#x3D;&#39;, x)</span><br><span class="line">...     print(&#39;y &#x3D;&#39;, y)</span><br><span class="line">...</span><br><span class="line">&lt;class &#39;Exception&#39;&gt;</span><br><span class="line">(&#39;spam&#39;, &#39;eggs&#39;)</span><br><span class="line">(&#39;spam&#39;, &#39;eggs&#39;)</span><br><span class="line">x &#x3D; spam</span><br><span class="line">y &#x3D; eggs</span><br></pre></td></tr></table></figure>

<p>如果异常有参数，则它们将作为未处理异常的消息的最后一部分（’详细信息’）打印。</p>
<p>异常处理程序不仅处理 try 子句中遇到的异常，还处理 try 子句中调用（即使是间接地）的函数内部发生的异常。例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def this_fails():</span><br><span class="line">...     x &#x3D; 1&#x2F;0</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     this_fails()</span><br><span class="line">... except ZeroDivisionError as err:</span><br><span class="line">...     print(&#39;Handling run-time error:&#39;, err)</span><br><span class="line">...</span><br><span class="line">Handling run-time error: division by zero</span><br></pre></td></tr></table></figure>



<h2 id="8-4-抛出异常"><a href="#8-4-抛出异常" class="headerlink" title="8.4. 抛出异常"></a>8.4. 抛出异常</h2><p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 语句允许程序员强制发生指定的异常。例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise NameError(&#39;HiThere&#39;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 唯一的参数就是要抛出的异常。这个参数必须是一个异常实例或者是一个异常类（派生自 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的类）。如果传递的是一个异常类，它将通过调用没有参数的构造函数来隐式实例化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise ValueError  # shorthand for &#39;raise ValueError()&#39;</span><br></pre></td></tr></table></figure>

<p>如果你需要确定是否引发了异常但不打算处理它，则可以使用更简单的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 语句形式重新引发异常</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     raise NameError(&#39;HiThere&#39;)</span><br><span class="line">... except NameError:</span><br><span class="line">...     print(&#39;An exception flew by!&#39;)</span><br><span class="line">...     raise</span><br><span class="line">...</span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;</span><br><span class="line">NameError: HiThere</span><br></pre></td></tr></table></figure>



<h2 id="8-5-用户自定义异常"><a href="#8-5-用户自定义异常" class="headerlink" title="8.5. 用户自定义异常"></a>8.5. 用户自定义异常</h2><p>程序可以通过创建新的异常类来命名它们自己的异常（有关Python 类的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-classes" target="_blank" rel="noopener">类</a>）。异常通常应该直接或间接地从 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 类派生。</p>
<p>可以定义异常类，它可以执行任何其他类可以执行的任何操作，但通常保持简单，通常只提供许多属性，这些属性允许处理程序为异常提取有关错误的信息。在创建可能引发多个不同错误的模块时，通常的做法是为该模块定义的异常创建基类，并为不同错误条件创建特定异常类的子类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Error(Exception):</span><br><span class="line">    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class InputError(Error):</span><br><span class="line">    &quot;&quot;&quot;Exception raised for errors in the input.</span><br><span class="line"></span><br><span class="line">    Attributes:</span><br><span class="line">        expression -- input expression in which the error occurred</span><br><span class="line">        message -- explanation of the error</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, expression, message):</span><br><span class="line">        self.expression &#x3D; expression</span><br><span class="line">        self.message &#x3D; message</span><br><span class="line"></span><br><span class="line">class TransitionError(Error):</span><br><span class="line">    &quot;&quot;&quot;Raised when an operation attempts a state transition that&#39;s not</span><br><span class="line">    allowed.</span><br><span class="line"></span><br><span class="line">    Attributes:</span><br><span class="line">        previous -- state at beginning of transition</span><br><span class="line">        next -- attempted new state</span><br><span class="line">        message -- explanation of why the specific transition is not allowed</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, previous, next, message):</span><br><span class="line">        self.previous &#x3D; previous</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line">        self.message &#x3D; message</span><br></pre></td></tr></table></figure>

<p>大多数异常都定义为名称以“Error”结尾，类似于标准异常的命名。</p>
<p>许多标准模块定义了它们自己的异常，以报告它们定义的函数中可能出现的错误。有关类的更多信息，请参见类 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-classes" target="_blank" rel="noopener">类</a>。</p>
<h2 id="8-6-定义清理操作"><a href="#8-6-定义清理操作" class="headerlink" title="8.6. 定义清理操作"></a>8.6. 定义清理操作</h2><p><a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句有另一个可选子句，用于定义必须在所有情况下执行的清理操作。例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     raise KeyboardInterrupt</span><br><span class="line">... finally:</span><br><span class="line">...     print(&#39;Goodbye, world!&#39;)</span><br><span class="line">...</span><br><span class="line">Goodbye, world!</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;</span><br></pre></td></tr></table></figure>

<p>如果存在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句，则 <code>finally</code> 子句将作为 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句结束前的最后一项任务被执行。 <code>finally</code> 子句不论 <code>try</code> 语句是否产生了异常都会被执行。 以下几点讨论了当异常发生时一些更复杂的情况：</p>
<ul>
<li>如果在执行 <code>try</code> 子句期间发生了异常，该异常可由一个 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句进行处理。 如果异常没有被某个 <code>except</code> 子句所处理，则该异常会在 <code>finally</code> 子句执行之后被重新引发。</li>
<li>异常也可能在 <code>except</code> 或 <code>else</code> 子句执行期间发生。 同样地，该异常会在 <code>finally</code> 子句执行之后被重新引发。</li>
<li>如果在执行 <code>try</code> 语句时遇到一个 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a>, <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 语句，则 <code>finally</code> 子句将在执行 <code>break</code>, <code>continue</code> 或 <code>return</code> 语句之前被执行。</li>
<li>如果 <code>finally</code> 子句中包含一个 <code>return</code> 语句，则返回值将来自 <code>finally</code> 子句的某个 <code>return</code> 语句的返回值，而非来自 <code>try</code> 子句的 <code>return</code> 语句的返回值。</li>
</ul>
<p>例如</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def bool_return():</span><br><span class="line">...     try:</span><br><span class="line">...         return True</span><br><span class="line">...     finally:</span><br><span class="line">...         return False</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; bool_return()</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>一个更为复杂的例子:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def divide(x, y):</span><br><span class="line">...     try:</span><br><span class="line">...         result &#x3D; x &#x2F; y</span><br><span class="line">...     except ZeroDivisionError:</span><br><span class="line">...         print(&quot;division by zero!&quot;)</span><br><span class="line">...     else:</span><br><span class="line">...         print(&quot;result is&quot;, result)</span><br><span class="line">...     finally:</span><br><span class="line">...         print(&quot;executing finally clause&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; divide(2, 1)</span><br><span class="line">result is 2.0</span><br><span class="line">executing finally clause</span><br><span class="line">&gt;&gt;&gt; divide(2, 0)</span><br><span class="line">division by zero!</span><br><span class="line">executing finally clause</span><br><span class="line">&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)</span><br><span class="line">executing finally clause</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in divide</span><br><span class="line">TypeError: unsupported operand type(s) for &#x2F;: &#39;str&#39; and &#39;str&#39;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句在任何情况下都会被执行。 两个字符串相除所引发的 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 不会由 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句处理，因此会在 <code>finally</code> 子句执行后被重新引发。</p>
<p>在实际应用程序中，<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源。</p>
<h2 id="8-7-预定义的清理操作"><a href="#8-7-预定义的清理操作" class="headerlink" title="8.7. 预定义的清理操作"></a>8.7. 预定义的清理操作</h2><p>某些对象定义了在不再需要该对象时要执行的标准清理操作，无论使用该对象的操作是成功还是失败。请查看下面的示例，它尝试打开一个文件并把其内容打印到屏幕上。:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for line in open(&quot;myfile.txt&quot;):</span><br><span class="line">    print(line, end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>这个代码的问题在于，它在这部分代码执行完后，会使文件在一段不确定的时间内处于打开状态。这在简单脚本中不是问题，但对于较大的应用程序来说可能是个问题。 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句允许像文件这样的对象能够以一种确保它们得到及时和正确的清理的方式使用。:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;myfile.txt&quot;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line, end&#x3D;&quot;&quot;)</span><br></pre></td></tr></table></figure>

<p>执行完语句后，即使在处理行时遇到问题，文件 <em>f</em> 也始终会被关闭。和文件一样，提供预定义清理操作的对象将在其文档中指出这一点。</p>
<h1 id="9-类"><a href="#9-类" class="headerlink" title="9. 类"></a>9. 类</h1><p>类提供了一种组合数据和功能的方法。 创建一个新类意味着创建一个新的对象 <em>类型*，从而允许创建一个该类型的新 *实例</em> 。 每个类的实例可以拥有保存自己状态的属性。 一个类的实例也可以有改变自己状态的（定义在类中的）方法。</p>
<p>和其他编程语言相比，Python 用非常少的新语法和语义将类加入到语言中。它是 C++ 和 Modula-3 中类机制的结合。Python 的类提供了面向对象编程的所有标准特性：类继承机制允许多个基类，派生类可以覆盖它基类的任何方法，一个方法可以调用基类中相同名称的的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：它们在运行时创建，可以在创建后修改。</p>
<p>在 C++ 术语中，通常类成员（包括数据成员）是 <em>public</em> (例外见下文 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-private" target="_blank" rel="noopener">私有变量</a>)，所有成员函数都是 <em>virtual</em>。 与在 Modula-3 中一样，没有用于从其方法引用对象成员的简写：方法函数使用表示对象的显式第一个参数声明，该参数由调用隐式提供。 与 Smalltalk 一样，类本身也是对象。 这为导入和重命名提供了语义。 与 C++ 和 Modula-3 不同，内置类型可以用作用户扩展的基类。 此外，与 C++ 一样，大多数具有特殊语法（算术运算符，下标等）的内置运算符都可以为类实例而重新定义。</p>
<p>（由于缺乏关于类的公认术语，我会偶尔使用 Smalltalk 和 C++ 的用辞。 我还会使用 Modula-3 的术语，因为其面向对象的语义比 C++ 更接近 Python，但我预计少有读者听说过它。）</p>
<h2 id="9-1-名称和对象"><a href="#9-1-名称和对象" class="headerlink" title="9.1. 名称和对象"></a>9.1. 名称和对象</h2><p>对象具有个性，多个名称（在多个作用域内）可以绑定到同一个对象。这在其他语言中称为别名。乍一看Python时通常不会理解这一点，在处理不可变的基本类型（数字，字符串，元组）时可以安全地忽略它。但是，别名对涉及可变对象，如列表，字典和大多数其他类型，的Python代码的语义可能会产生惊人的影响。这通常用于程序的好处，因为别名在某些方面表现得像指针。例如，传递一个对象很便宜，因为实现只传递一个指针；如果函数修改了作为参数传递的对象，调用者将看到更改 — 这就不需要像 Pascal 中那样使用两个不同的参数传递机制。</p>
<h2 id="9-2-Python-作用域和命名空间"><a href="#9-2-Python-作用域和命名空间" class="headerlink" title="9.2. Python 作用域和命名空间"></a>9.2. Python 作用域和命名空间</h2><p>在介绍类之前，我首先要告诉你一些Python的作用域规则。类定义对命名空间有一些巧妙的技巧，你需要知道作用域和命名空间如何工作才能完全理解正在发生的事情。顺便说一下，关于这个主题的知识对任何高级Python程序员都很有用。</p>
<p>让我们从一些定义开始。</p>
<p><em>namespace</em> （命名空间）是一个从名字到对象的映射。 大部分命名空间当前都由 Python 字典实现，但一般情况下基本不会去关注它们（除了要面对性能问题时），而且也有可能在将来更改。 下面是几个命名空间的例子：存放内置函数的集合（包含 <a href="https://docs.python.org/zh-cn/3/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a> 这样的函数，和内建的异常等）；模块中的全局名称；函数调用中的局部名称。 从某种意义上说，对象的属性集合也是一种命名空间的形式。 关于命名空间的重要一点是，不同命名空间中的名称之间绝对没有关系；例如，两个不同的模块都可以定义一个 <code>maximize</code> 函数而不会产生混淆 — 模块的用户必须在其前面加上模块名称。</p>
<p>顺便说明一下，我把任何跟在一个点号之后的名称都称为 <em>属性</em> — 例如，在表达式 <code>z.real</code> 中，<code>real</code> 是对象 <code>z</code> 的一个属性。按严格的说法，对模块中名称的引用属于属性引用：在表达式 <code>modname.funcname</code> 中，<code>modname</code> 是一个模块对象而 <code>funcname</code> 是它的一个属性。在此情况下在模块的属性和模块中定义的全局名称之间正好存在一个直观的映射：它们共享相同的命名空间！ <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#id2" target="_blank" rel="noopener">1</a></p>
<p>属性可以是只读或者可写的。如果为后者，那么对属性的赋值是可行的。模块属性是可以写，你可以写出 <code>modname.the_answer = 42</code> 。可写的属性同样可以用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句删除。例如， <code>del modname.the_answer</code> 将会从名为 <code>modname</code> 的对象中移除 <code>the_answer</code> 属性。</p>
<p>在不同时刻创建的命名空间拥有不同的生存期。包含内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。模块的全局命名空间在模块定义被读入时创建；通常，模块命名空间也会持续到解释器退出。被解释器的顶层调用执行的语句，从一个脚本文件读取或交互式地读取，被认为是 <a href="https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__" target="_blank" rel="noopener"><code>__main__</code></a> 模块调用的一部分，因此它们拥有自己的全局命名空间。（内置名称实际上也存在于一个模块中；这个模块称作 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 。）</p>
<p>一个函数的本地命名空间在这个函数被调用时创建，并在函数返回或抛出一个不在函数内部处理的错误时被删除。（事实上，比起描述到底发生了什么，忘掉它更好。）当然，每次递归调用都会有它自己的本地命名空间。</p>
<p>一个 <em>作用域</em> 是一个命名空间可直接访问的 Python 程序的文本区域。 这里的 “可直接访问” 意味着对名称的非限定引用会尝试在命名空间中查找名称。</p>
<p>作用域被静态确定，但被动态使用。 在程序运行的任何时间，至少有三个命名空间可被直接访问的嵌套作用域：</p>
<ul>
<li>最先搜索的最内部作用域包含局部名称</li>
<li>从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称</li>
<li>倒数第二个作用域包含当前模块的全局名称</li>
<li>最外面的作用域（最后搜索）是包含内置名称的命名空间</li>
</ul>
<p>如果一个名称被声明为全局变量，则所有引用和赋值将直接指向包含该模块的全局名称的中间作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句声明为非本地变量。 如果没有被声明为非本地变量，这些变量将是只读的（尝试写入这样的变量只会在最内层作用域中创建一个 <em>新的</em> 局部变量，而同名的外部变量保持不变）。</p>
<p>通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。 在函数以外，局部作用域将引用与全局作用域相一致的命名空间：模块的命名空间。 类定义将在局部命名空间内再放置另一个命名空间。</p>
<p>重要的是应该意识到作用域是按字面文本来确定的：在一个模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。 另一方面，实际的名称搜索是在运行时动态完成的 — 但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！ （事实上，局部变量已经是被静态确定了。）</p>
<p>Python 的一个特殊规定是这样的 – 如果不存在生效的 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句 – 则对名称的赋值总是会进入最内层作用域。 赋值不会复制数据 — 它们只是将名称绑定到对象。 删除也是如此：语句 <code>del x</code> 会从局部作用域所引用的命名空间中移除对 <code>x</code> 的绑定。 事实上，所有引入新名称的操作都是使用局部作用域：特别地，<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定；<a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定。</p>
<h3 id="9-2-1-作用域和命名空间示例"><a href="#9-2-1-作用域和命名空间示例" class="headerlink" title="9.2.1. 作用域和命名空间示例"></a>9.2.1. 作用域和命名空间示例</h3><p>这个例子演示了如何引用不同作用域和名称空间，以及 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 会如何影响变量绑定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def scope_test():</span><br><span class="line">    def do_local():</span><br><span class="line">        spam &#x3D; &quot;local spam&quot;</span><br><span class="line"></span><br><span class="line">    def do_nonlocal():</span><br><span class="line">        nonlocal spam</span><br><span class="line">        spam &#x3D; &quot;nonlocal spam&quot;</span><br><span class="line"></span><br><span class="line">    def do_global():</span><br><span class="line">        global spam</span><br><span class="line">        spam &#x3D; &quot;global spam&quot;</span><br><span class="line"></span><br><span class="line">    spam &#x3D; &quot;test spam&quot;</span><br><span class="line">    do_local()</span><br><span class="line">    print(&quot;After local assignment:&quot;, spam)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    print(&quot;After nonlocal assignment:&quot;, spam)</span><br><span class="line">    do_global()</span><br><span class="line">    print(&quot;After global assignment:&quot;, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line">print(&quot;In global scope:&quot;, spam)</span><br></pre></td></tr></table></figure>

<p>示例代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">After local assignment: test spam</span><br><span class="line">After nonlocal assignment: nonlocal spam</span><br><span class="line">After global assignment: nonlocal spam</span><br><span class="line">In global scope: global spam</span><br></pre></td></tr></table></figure>

<p>请注意 <em>局部</em> 赋值（这是默认状态）不会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定。 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal" target="_blank" rel="noopener"><code>nonlocal</code></a> 赋值会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定，而 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 赋值会改变模块层级的绑定。</p>
<p>您还可以在 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global" target="_blank" rel="noopener"><code>global</code></a> 赋值之前看到之前没有 <em>spam</em> 的绑定。</p>
<h2 id="9-3-初探类"><a href="#9-3-初探类" class="headerlink" title="9.3. 初探类"></a>9.3. 初探类</h2><p>类引入了一些新语法，三种新对象类型和一些新语义。</p>
<h3 id="9-3-1-类定义语法"><a href="#9-3-1-类定义语法" class="headerlink" title="9.3.1. 类定义语法"></a>9.3.1. 类定义语法</h3><p>最简单的类定义看起来像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ClassName:</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>

<p>类定义与函数定义 (<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> 语句) 一样必须被执行才会起作用。 （你可以尝试将类定义放在 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> 语句的一个分支或是函数的内部。）</p>
<p>在实践中，类定义内的语句通常都是函数定义，但也允许有其他语句，有时还很有用 — 我们会稍后再回来说明这个问题。 在类内部的函数定义通常具有一种特别形式的参数列表，这是方法调用的约定规范所指明的 — 这个问题也将在稍后再说明。</p>
<p>当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 — 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。</p>
<p>当（从结尾处）正常离开类定义时，将创建一个 <em>类对象</em>。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器；我们将在下一节了解有关类对象的更多信息。 原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称 (在这个示例中为 <code>ClassName</code>)。</p>
<h3 id="9-3-2-类对象"><a href="#9-3-2-类对象" class="headerlink" title="9.3.2. 类对象"></a>9.3.2. 类对象</h3><p>类对象支持两种操作：属性引用和实例化。</p>
<p><em>属性引用</em> 使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line">    &quot;&quot;&quot;A simple example class&quot;&quot;&quot;</span><br><span class="line">    i &#x3D; 12345</span><br><span class="line"></span><br><span class="line">    def f(self):</span><br><span class="line">        return &#39;hello world&#39;</span><br></pre></td></tr></table></figure>

<p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 <code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>&quot;A simple example class&quot;</code>。</p>
<p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举例来说（假设使用上述的类）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; MyClass()</span><br></pre></td></tr></table></figure>

<p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p>
<p>实例化操作（“调用”类对象）会创建一个空对象。 许多类喜欢创建带有特定初始状态的自定义实例。 为此类定义可能包含一个名为 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 的特殊方法，就像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.data &#x3D; []</span><br></pre></td></tr></table></figure>

<p>当一个类定义了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法时，类的实例化操作会自动为新创建的类实例发起调用 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a>。 因此在这个示例中，可以通过以下语句获得一个经初始化的新实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; MyClass()</span><br></pre></td></tr></table></figure>

<p>当然，<a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法还可以有额外参数以实现更高灵活性。 在这种情况下，提供给类实例化运算符的参数将被传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a>。 例如，:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Complex:</span><br><span class="line">...     def __init__(self, realpart, imagpart):</span><br><span class="line">...         self.r &#x3D; realpart</span><br><span class="line">...         self.i &#x3D; imagpart</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; x &#x3D; Complex(3.0, -4.5)</span><br><span class="line">&gt;&gt;&gt; x.r, x.i</span><br><span class="line">(3.0, -4.5)</span><br></pre></td></tr></table></figure>



<h3 id="9-3-3-实例对象"><a href="#9-3-3-实例对象" class="headerlink" title="9.3.3. 实例对象"></a>9.3.3. 实例对象</h3><p>现在我们能用实例对象做什么？ 实例对象理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p>
<p><em>数据属性</em> 对应于 Smalltalk 中的“实例变量”，以及 C++ 中的“数据成员”。 数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。 例如，如果 <code>x</code> 是上面创建的 <code>MyClass</code> 的实例，则以下代码段将打印数值 <code>16</code>，且不保留任何追踪信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x.counter &#x3D; 1</span><br><span class="line">while x.counter &lt; 10:</span><br><span class="line">    x.counter &#x3D; x.counter * 2</span><br><span class="line">print(x.counter)</span><br><span class="line">del x.counter</span><br></pre></td></tr></table></figure>

<p>另一类实例属性引用称为 <em>方法</em>。 方法是“从属于”对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明。）</p>
<p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是一个函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 — 它是一个 <em>方法对象</em>，不是函数对象。</p>
<h3 id="9-3-4-方法对象"><a href="#9-3-4-方法对象" class="headerlink" title="9.3.4. 方法对象"></a>9.3.4. 方法对象</h3><p>通常，方法在绑定后立即被调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.f()</span><br></pre></td></tr></table></figure>

<p>在 <code>MyClass</code> 示例中，这将返回字符串 <code>&#39;hello world&#39;</code>。 但是，立即调用一个方法并不是必须的: <code>x.f</code> 是一个方法对象，它可以被保存起来以后再调用。 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xf &#x3D; x.f</span><br><span class="line">while True:</span><br><span class="line">    print(xf())</span><br></pre></td></tr></table></figure>

<p>将继续打印 <code>hello world</code>，直到结束。</p>
<p>当一个方法被调用时到底发生了什么？ 你可能已经注意到上面调用 <code>x.f()</code> 时并没有带参数，虽然 <code>f()</code> 的函数定义指定了一个参数。 这个参数发生了什么事？ 当不带参数地调用一个需要参数的函数时 Python 肯定会引发异常 — 即使参数实际未被使用…</p>
<p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。 总之，调用一个具有 <em>n</em> 个参数的方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之前。</p>
<p>如果你仍然无法理解方法的运作原理，那么查看实现细节可能会澄清问题。 当一个实例的非数据属性被引用时，将搜索实例所属的类。 如果被引用的属性名称表示一个有效的类属性中的函数对象，会通过打包（指向）查找到的实例对象和函数对象到一个抽象对象的方式来创建方法对象：这个抽象对象就是方法对象。 当附带参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。</p>
<h3 id="9-3-5-类和实例变量"><a href="#9-3-5-类和实例变量" class="headerlink" title="9.3.5. 类和实例变量"></a>9.3.5. 类和实例变量</h3><p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line"></span><br><span class="line">    kind &#x3D; &#39;canine&#39;         # class variable shared by all instances</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name    # instance variable unique to each instance</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d &#x3D; Dog(&#39;Fido&#39;)</span><br><span class="line">&gt;&gt;&gt; e &#x3D; Dog(&#39;Buddy&#39;)</span><br><span class="line">&gt;&gt;&gt; d.kind                  # shared by all dogs</span><br><span class="line">&#39;canine&#39;</span><br><span class="line">&gt;&gt;&gt; e.kind                  # shared by all dogs</span><br><span class="line">&#39;canine&#39;</span><br><span class="line">&gt;&gt;&gt; d.name                  # unique to d</span><br><span class="line">&#39;Fido&#39;</span><br><span class="line">&gt;&gt;&gt; e.name                  # unique to e</span><br><span class="line">&#39;Buddy&#39;</span><br></pre></td></tr></table></figure>

<p>正如 <a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object" target="_blank" rel="noopener">名称和对象</a> 中已讨论过的，共享数据可能在涉及 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-mutable" target="_blank" rel="noopener">mutable</a> 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line"></span><br><span class="line">    tricks &#x3D; []             # mistaken use of a class variable</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">    def add_trick(self, trick):</span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d &#x3D; Dog(&#39;Fido&#39;)</span><br><span class="line">&gt;&gt;&gt; e &#x3D; Dog(&#39;Buddy&#39;)</span><br><span class="line">&gt;&gt;&gt; d.add_trick(&#39;roll over&#39;)</span><br><span class="line">&gt;&gt;&gt; e.add_trick(&#39;play dead&#39;)</span><br><span class="line">&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs</span><br><span class="line">[&#39;roll over&#39;, &#39;play dead&#39;]</span><br></pre></td></tr></table></figure>

<p>正确的类设计应该使用实例变量:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Dog:</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.tricks &#x3D; []    # creates a new empty list for each dog</span><br><span class="line"></span><br><span class="line">    def add_trick(self, trick):</span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; d &#x3D; Dog(&#39;Fido&#39;)</span><br><span class="line">&gt;&gt;&gt; e &#x3D; Dog(&#39;Buddy&#39;)</span><br><span class="line">&gt;&gt;&gt; d.add_trick(&#39;roll over&#39;)</span><br><span class="line">&gt;&gt;&gt; e.add_trick(&#39;play dead&#39;)</span><br><span class="line">&gt;&gt;&gt; d.tricks</span><br><span class="line">[&#39;roll over&#39;]</span><br><span class="line">&gt;&gt;&gt; e.tricks</span><br><span class="line">[&#39;play dead&#39;]</span><br></pre></td></tr></table></figure>



<h2 id="9-4-补充说明"><a href="#9-4-补充说明" class="headerlink" title="9.4. 补充说明"></a>9.4. 补充说明</h2><p>如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Warehouse:</span><br><span class="line">        purpose &#x3D; &#39;storage&#39;</span><br><span class="line">        region &#x3D; &#39;west&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; w1 &#x3D; Warehouse()</span><br><span class="line">&gt;&gt;&gt; print(w1.purpose, w1.region)</span><br><span class="line">storage west</span><br><span class="line">&gt;&gt;&gt; w2 &#x3D; Warehouse()</span><br><span class="line">&gt;&gt;&gt; w2.region &#x3D; &#39;east&#39;</span><br><span class="line">&gt;&gt;&gt; print(w2.purpose, w2.region)</span><br><span class="line">storage east</span><br></pre></td></tr></table></figure>

<p>数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 — 它是完全基于约定的。 （而在另一方面，用 C 语言编写的 Python 实现则可以完全隐藏实现细节，并在必要时控制对象的访问；此特性可以通过用 C 编写 Python 扩展来使用。）</p>
<p>客户端应当谨慎地使用数据属性 — 客户端可能通过直接操作数据属性的方式破坏由方法所维护的固定变量。 请注意客户端可以向一个实例对象添加他们自己的数据属性而不会影响方法的可用性，只要保证避免名称冲突 — 再次提醒，在此使用命名约定可以省去许多令人头痛的麻烦。</p>
<p>在方法内部引用数据属性（或其他方法！）并没有简便方式。 我发现这实际上提升了方法的可读性：当浏览一个方法代码时，不会存在混淆局部变量和实例变量的机会。</p>
<p>方法的第一个参数常常被命名为 <code>self</code>。 这也不过就是一个约定: <code>self</code> 这一名称在 Python 中绝对没有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，而且也可以想像一个 <em>类浏览器</em> 程序的编写可能会依赖于这样的约定。</p>
<p>任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Function defined outside the class</span><br><span class="line">def f1(self, x, y):</span><br><span class="line">    return min(x, x+y)</span><br><span class="line"></span><br><span class="line">class C:</span><br><span class="line">    f &#x3D; f1</span><br><span class="line"></span><br><span class="line">    def g(self):</span><br><span class="line">        return &#39;hello world&#39;</span><br><span class="line"></span><br><span class="line">    h &#x3D; g</span><br></pre></td></tr></table></figure>

<p>现在 <code>f</code>, <code>g</code> 和 <code>h</code> 都是 <code>C</code> 类的引用函数对象的属性，因而它们就都是 <code>C</code> 的实例的方法 — 其中 <code>h</code> 完全等同于 <code>g</code>。 但请注意，本示例的做法通常只会令程序的阅读者感到迷惑。</p>
<p>方法可以通过使用 <code>self</code> 参数的方法属性调用其他方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Bag:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data &#x3D; []</span><br><span class="line"></span><br><span class="line">    def add(self, x):</span><br><span class="line">        self.data.append(x)</span><br><span class="line"></span><br><span class="line">    def addtwice(self, x):</span><br><span class="line">        self.add(x)</span><br><span class="line">        self.add(x)</span><br></pre></td></tr></table></figure>

<p>方法可以通过与普通函数相同的方式引用全局名称。 与方法相关联的全局作用域就是包含其定义的模块。 （类永远不会被作为全局作用域。） 虽然我们很少会有充分的理由在方法中使用全局作用域，但全局作用域存在许多合法的使用场景：举个例子，导入到全局作用域的函数和模块可以被方法所使用，在其中定义的函数和类也一样。 通常，包含该方法的类本身是在全局作用域中定义的，而在下一节中我们将会发现为何方法需要引用其所属类的很好的理由。</p>
<p>每个值都是一个对象，因此具有 <em>类</em> （也称为 <em>类型</em>），并存储为 <code>object.__class__</code> 。</p>
<h2 id="9-5-继承"><a href="#9-5-继承" class="headerlink" title="9.5. 继承"></a>9.5. 继承</h2><p>当然，如果不支持继承，语言特性就不值得称为“类”。派生类定义的语法如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(BaseClassName):</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>

<p>名称 <code>BaseClassName</code> 必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。 这有时也可能会用得上，例如，当基类定义在另一个模块中的时候:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(modname.BaseClassName):</span><br></pre></td></tr></table></figure>

<p>派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p>
<p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p>
<p>派生类可能会重载其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。 （对 C++ 程序员的提示：Python 中所有的方法实际上都是 <code>virtual</code> 方法。）</p>
<p>在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用 <code>BaseClassName.methodname(self, arguments)</code>。 有时这对客户端来说也是有用的。 （请注意仅当此基类可在全局作用域中以 <code>BaseClassName</code> 的名称被访问时方可使用此方式。）</p>
<p>Python有两个内置函数可被用于继承机制：</p>
<ul>
<li>使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 或某个派生自 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的类时为 <code>True</code>。</li>
<li>使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a> 是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 不是 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类。</li>
</ul>
<h3 id="9-5-1-多重继承"><a href="#9-5-1-多重继承" class="headerlink" title="9.5.1. 多重继承"></a>9.5.1. 多重继承</h3><p>Python也支持一种多重继承。 带有多个基类的类定义语句如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DerivedClassName(Base1, Base2, Base3):</span><br><span class="line">    &lt;statement-1&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>

<p>对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 <code>DerivedClassName</code> 中未找到，则会到 <code>Base1</code> 中搜索它，然后（递归地）到 <code>Base1</code> 的基类中搜索，如果在那里未找到，再到 <code>Base2</code> 中搜索，依此类推。</p>
<p>真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 <a href="https://docs.python.org/zh-cn/3/library/functions.html#super" target="_blank" rel="noopener"><code>super()</code></a> 的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。</p>
<p>动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 例如，所有类都是继承自 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>，因此任何多重继承的情况都提供了一条以上的路径可以通向 <a href="https://docs.python.org/zh-cn/3/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 <a href="https://www.python.org/download/releases/2.3/mro/。" target="_blank" rel="noopener">https://www.python.org/download/releases/2.3/mro/。</a></p>
<h2 id="9-6-私有变量"><a href="#9-6-私有变量" class="headerlink" title="9.6. 私有变量"></a>9.6. 私有变量</h2><p>那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p>
<p>由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 <em>名称改写</em>。 任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p>
<p>名称改写有助于让子类重载方法而不破坏类内方法调用。例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Mapping:</span><br><span class="line">    def __init__(self, iterable):</span><br><span class="line">        self.items_list &#x3D; []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line"></span><br><span class="line">    def update(self, iterable):</span><br><span class="line">        for item in iterable:</span><br><span class="line">            self.items_list.append(item)</span><br><span class="line"></span><br><span class="line">    __update &#x3D; update   # private copy of original update() method</span><br><span class="line"></span><br><span class="line">class MappingSubclass(Mapping):</span><br><span class="line"></span><br><span class="line">    def update(self, keys, values):</span><br><span class="line">        # provides new signature for update()</span><br><span class="line">        # but does not break __init__()</span><br><span class="line">        for item in zip(keys, values):</span><br><span class="line">            self.items_list.append(item)</span><br></pre></td></tr></table></figure>

<p>上面的示例即使在 <code>MappingSubclass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>Mapping</code> 类中被替换为 <code>_Mapping__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p>
<p>请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器中。</p>
<p>请注意传递给 <code>exec()</code> 或 <code>eval()</code> 的代码不会将发起调用类的类名视作当前类；这类似于 <code>global</code> 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 <code>getattr()</code>, <code>setattr()</code> 和 <code>delattr()</code>，以及对于 <code>__dict__</code> 的直接引用。</p>
<h2 id="9-7-杂项说明"><a href="#9-7-杂项说明" class="headerlink" title="9.7. 杂项说明"></a>9.7. 杂项说明</h2><p>有时会需要使用类似于 Pascal 的“record”或 C 的“struct”这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Employee:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">john &#x3D; Employee()  # Create an empty employee record</span><br><span class="line"></span><br><span class="line"># Fill the fields of the record</span><br><span class="line">john.name &#x3D; &#39;John Doe&#39;</span><br><span class="line">john.dept &#x3D; &#39;computer lab&#39;</span><br><span class="line">john.salary &#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>一段需要特定抽象数据类型的 Python 代码往往可以被传入一个模拟了该数据类型的方法的类作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有 <code>read()</code> 和 <code>readline()</code> 方法从字符串缓存获取数据的类，并将其作为参数传入。</p>
<p>实例方法对象也具有属性: <code>m.__self__</code> 就是带有 <code>m()</code> 方法的实例对象，而 <code>m.__func__</code> 则是该方法所对应的函数对象。</p>
<h2 id="9-8-迭代器"><a href="#9-8-迭代器" class="headerlink" title="9.8. 迭代器"></a>9.8. 迭代器</h2><p>到目前为止，您可能已经注意到大多数容器对象都可以使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 语句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for element in [1, 2, 3]:</span><br><span class="line">    print(element)</span><br><span class="line">for element in (1, 2, 3):</span><br><span class="line">    print(element)</span><br><span class="line">for key in &#123;&#39;one&#39;:1, &#39;two&#39;:2&#125;:</span><br><span class="line">    print(key)</span><br><span class="line">for char in &quot;123&quot;:</span><br><span class="line">    print(char)</span><br><span class="line">for line in open(&quot;myfile.txt&quot;):</span><br><span class="line">    print(line, end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure>

<p>这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在幕后，<a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 语句会在容器对象上调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#iter" target="_blank" rel="noopener"><code>iter()</code></a>。 该函数返回一个定义了 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常来通知终止 <code>for</code> 循环。 你可以使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 内置函数来调用 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法；这个例子显示了它的运作方式:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &#x3D; &#39;abc&#39;</span><br><span class="line">&gt;&gt;&gt; it &#x3D; iter(s)</span><br><span class="line">&gt;&gt;&gt; it</span><br><span class="line">&lt;iterator object at 0x00A1DB50&gt;</span><br><span class="line">&gt;&gt;&gt; next(it)</span><br><span class="line">&#39;a&#39;</span><br><span class="line">&gt;&gt;&gt; next(it)</span><br><span class="line">&#39;b&#39;</span><br><span class="line">&gt;&gt;&gt; next(it)</span><br><span class="line">&#39;c&#39;</span><br><span class="line">&gt;&gt;&gt; next(it)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(it)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 定义一个 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法来返回一个带有 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法的对象。 如果类已定义了 <code>__next__()</code>，则 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 可以简单地返回 <code>self</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Reverse:</span><br><span class="line">    &quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data &#x3D; data</span><br><span class="line">        self.index &#x3D; len(data)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &#x3D;&#x3D; 0:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        self.index &#x3D; self.index - 1</span><br><span class="line">        return self.data[self.index]</span><br></pre></td></tr></table></figure>

<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rev &#x3D; Reverse(&#39;spam&#39;)</span><br><span class="line">&gt;&gt;&gt; iter(rev)</span><br><span class="line">&lt;__main__.Reverse object at 0x00A1DB50&gt;</span><br><span class="line">&gt;&gt;&gt; for char in rev:</span><br><span class="line">...     print(char)</span><br><span class="line">...</span><br><span class="line">m</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure>



<h2 id="9-9-生成器"><a href="#9-9-生成器" class="headerlink" title="9.9. 生成器"></a>9.9. 生成器</h2><p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-generator" target="_blank" rel="noopener">Generator</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield" target="_blank" rel="noopener"><code>yield</code></a> 语句。 每次对生成器调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 时，它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。 显示如何非常容易地创建生成器的示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def reverse(data):</span><br><span class="line">    for index in range(len(data)-1, -1, -1):</span><br><span class="line">        yield data[index]</span><br></pre></td></tr></table></figure>

<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for char in reverse(&#39;golf&#39;):</span><br><span class="line">...     print(char)</span><br><span class="line">...</span><br><span class="line">f</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">g</span><br></pre></td></tr></table></figure>

<p>可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法。</p>
<p>另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 <code>self.index</code> 和 <code>self.data</code> 这种实例变量的方式更易编写且更为清晰。</p>
<p>除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。</p>
<h2 id="9-10-生成器表达式"><a href="#9-10-生成器表达式" class="headerlink" title="9.10. 生成器表达式"></a>9.10. 生成器表达式</h2><p>某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，将外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。</p>
<p>例如:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(i*i for i in range(10))                 # sum of squares</span><br><span class="line">285</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; xvec &#x3D; [10, 20, 30]</span><br><span class="line">&gt;&gt;&gt; yvec &#x3D; [7, 5, 3]</span><br><span class="line">&gt;&gt;&gt; sum(x*y for x,y in zip(xvec, yvec))         # dot product</span><br><span class="line">260</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; unique_words &#x3D; set(word for line in page  for word in line.split())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; valedictorian &#x3D; max((student.gpa, student.name) for student in graduates)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; data &#x3D; &#39;golf&#39;</span><br><span class="line">&gt;&gt;&gt; list(data[i] for i in range(len(data)-1, -1, -1))</span><br><span class="line">[&#39;f&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;]</span><br></pre></td></tr></table></figure>

<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/classes.html#id1" target="_blank" rel="noopener">1</a></p>
<p>存在一个例外。 模块对象有一个秘密的只读属性 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a>，它返回用于实现模块命名空间的字典；<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 是属性但不是全局名称。 显然，使用这个将违反命名空间实现的抽象，应当仅被用于事后调试器之类的场合。</p>
</li>
</ul>
<h1 id="10-标准库简介"><a href="#10-标准库简介" class="headerlink" title="10. 标准库简介"></a>10. 标准库简介</h1><h2 id="10-1-操作系统接口"><a href="#10-1-操作系统接口" class="headerlink" title="10.1. 操作系统接口"></a>10.1. 操作系统接口</h2><p><a href="https://docs.python.org/zh-cn/3/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块提供了许多与操作系统交互的函数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.getcwd()      # Return the current working directory</span><br><span class="line">&#39;C:\\Python38&#39;</span><br><span class="line">&gt;&gt;&gt; os.chdir(&#39;&#x2F;server&#x2F;accesslogs&#39;)   # Change current working directory</span><br><span class="line">&gt;&gt;&gt; os.system(&#39;mkdir today&#39;)   # Run the command mkdir in the system shell</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>一定要使用 <code>import os</code> 而不是 <code>from os import *</code> 。这将避免内建的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 函数被 <a href="https://docs.python.org/zh-cn/3/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 隐式替换掉，它们的使用方式大不相同。</p>
<p>内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/functions.html#help" target="_blank" rel="noopener"><code>help()</code></a> 函数可用作交互式辅助工具，用于处理大型模块，如 <a href="https://docs.python.org/zh-cn/3/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a>:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; dir(os)</span><br><span class="line">&lt;returns a list of all module functions&gt;</span><br><span class="line">&gt;&gt;&gt; help(os)</span><br><span class="line">&lt;returns an extensive manual page created from the module&#39;s docstrings&gt;</span><br></pre></td></tr></table></figure>

<p>对于日常文件和目录管理任务， <a href="https://docs.python.org/zh-cn/3/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块提供了更易于使用的更高级别的接口:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import shutil</span><br><span class="line">&gt;&gt;&gt; shutil.copyfile(&#39;data.db&#39;, &#39;archive.db&#39;)</span><br><span class="line">&#39;archive.db&#39;</span><br><span class="line">&gt;&gt;&gt; shutil.move(&#39;&#x2F;build&#x2F;executables&#39;, &#39;installdir&#39;)</span><br><span class="line">&#39;installdir&#39;</span><br></pre></td></tr></table></figure>



<h2 id="10-2-文件通配符"><a href="#10-2-文件通配符" class="headerlink" title="10.2. 文件通配符"></a>10.2. 文件通配符</h2><p><a href="https://docs.python.org/zh-cn/3/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob</code></a> 模块提供了一个在目录中使用通配符搜索创建文件列表的函数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import glob</span><br><span class="line">&gt;&gt;&gt; glob.glob(&#39;*.py&#39;)</span><br><span class="line">[&#39;primes.py&#39;, &#39;random.py&#39;, &#39;quote.py&#39;]</span><br></pre></td></tr></table></figure>



<h2 id="10-3-命令行参数"><a href="#10-3-命令行参数" class="headerlink" title="10.3. 命令行参数"></a>10.3. 命令行参数</h2><p>通用实用程序脚本通常需要处理命令行参数。这些参数作为列表存储在 <a href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" target="_blank" rel="noopener"><code>sys</code></a> 模块的 <em>argv</em> 属性中。例如，以下输出来自在命令行运行 <code>python demo.py one two three</code></p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print(sys.argv)</span><br><span class="line">[&#39;demo.py&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;]</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 模块提供了一种更复杂的机制来处理命令行参数。 以下脚本可提取一个或多个文件名，并可选择要显示的行数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">parser &#x3D; argparse.ArgumentParser(prog &#x3D; &#39;top&#39;,</span><br><span class="line">    description &#x3D; &#39;Show top lines from each file&#39;)</span><br><span class="line">parser.add_argument(&#39;filenames&#39;, nargs&#x3D;&#39;+&#39;)</span><br><span class="line">parser.add_argument(&#39;-l&#39;, &#39;--lines&#39;, type&#x3D;int, default&#x3D;10)</span><br><span class="line">args &#x3D; parser.parse_args()</span><br><span class="line">print(args)</span><br></pre></td></tr></table></figure>

<p>当在通过 <code>python top.py --lines=5 alpha.txt beta.txt</code> 在命令行运行时，该脚本会将 <code>args.lines</code> 设为 <code>5</code> 并将 <code>args.filenames</code> 设为 <code>[&#39;alpha.txt&#39;, &#39;beta.txt&#39;]</code>。</p>
<h2 id="10-4-错误输出重定向和程序终止"><a href="#10-4-错误输出重定向和程序终止" class="headerlink" title="10.4. 错误输出重定向和程序终止"></a>10.4. 错误输出重定向和程序终止</h2><p><a href="https://docs.python.org/zh-cn/3/library/sys.html#module-sys" target="_blank" rel="noopener"><code>sys</code></a> 模块还具有 <em>stdin</em> ， <em>stdout</em> 和 <em>stderr</em> 的属性。后者对于发出警告和错误消息非常有用，即使在 <em>stdout</em> 被重定向后也可以看到它们:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sys.stderr.write(&#39;Warning, log file not found starting a new one\n&#39;)</span><br><span class="line">Warning, log file not found starting a new one</span><br></pre></td></tr></table></figure>

<p>终止脚本的最直接方法是使用 <code>sys.exit()</code> 。</p>
<h2 id="10-5-字符串模式匹配"><a href="#10-5-字符串模式匹配" class="headerlink" title="10.5. 字符串模式匹配"></a>10.5. 字符串模式匹配</h2><p><a href="https://docs.python.org/zh-cn/3/library/re.html#module-re" target="_blank" rel="noopener"><code>re</code></a> 模块为高级字符串处理提供正则表达式工具。对于复杂的匹配和操作，正则表达式提供简洁，优化的解决方案:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; re.findall(r&#39;\bf[a-z]*&#39;, &#39;which foot or hand fell fastest&#39;)</span><br><span class="line">[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]</span><br><span class="line">&gt;&gt;&gt; re.sub(r&#39;(\b[a-z]+) \1&#39;, r&#39;\1&#39;, &#39;cat in the the hat&#39;)</span><br><span class="line">&#39;cat in the hat&#39;</span><br></pre></td></tr></table></figure>

<p>当只需要简单的功能时，首选字符串方法因为它们更容易阅读和调试:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;tea for too&#39;.replace(&#39;too&#39;, &#39;two&#39;)</span><br><span class="line">&#39;tea for two&#39;</span><br></pre></td></tr></table></figure>



<h2 id="10-6-数学"><a href="#10-6-数学" class="headerlink" title="10.6. 数学"></a>10.6. 数学</h2><p><a href="https://docs.python.org/zh-cn/3/library/math.html#module-math" target="_blank" rel="noopener"><code>math</code></a> 模块提供对浮点数学的底层C库函数的访问:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; math.cos(math.pi &#x2F; 4)</span><br><span class="line">0.70710678118654757</span><br><span class="line">&gt;&gt;&gt; math.log(1024, 2)</span><br><span class="line">10.0</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/random.html#module-random" target="_blank" rel="noopener"><code>random</code></a> 模块提供了进行随机选择的工具:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import random</span><br><span class="line">&gt;&gt;&gt; random.choice([&#39;apple&#39;, &#39;pear&#39;, &#39;banana&#39;])</span><br><span class="line">&#39;apple&#39;</span><br><span class="line">&gt;&gt;&gt; random.sample(range(100), 10)   # sampling without replacement</span><br><span class="line">[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]</span><br><span class="line">&gt;&gt;&gt; random.random()    # random float</span><br><span class="line">0.17970987693706186</span><br><span class="line">&gt;&gt;&gt; random.randrange(6)    # random integer chosen from range(6)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/statistics.html#module-statistics" target="_blank" rel="noopener"><code>statistics</code></a> 模块计算数值数据的基本统计属性（均值，中位数，方差等）:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import statistics</span><br><span class="line">&gt;&gt;&gt; data &#x3D; [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]</span><br><span class="line">&gt;&gt;&gt; statistics.mean(data)</span><br><span class="line">1.6071428571428572</span><br><span class="line">&gt;&gt;&gt; statistics.median(data)</span><br><span class="line">1.25</span><br><span class="line">&gt;&gt;&gt; statistics.variance(data)</span><br><span class="line">1.3720238095238095</span><br></pre></td></tr></table></figure>

<p>SciPy项目 &lt;<a href="https://scipy.org/" target="_blank" rel="noopener">https://scipy.org</a>&gt; 有许多其他模块用于数值计算。</p>
<h2 id="10-7-互联网访问"><a href="#10-7-互联网访问" class="headerlink" title="10.7. 互联网访问"></a>10.7. 互联网访问</h2><p>有许多模块可用于访问互联网和处理互联网协议。其中两个最简单的 <a href="https://docs.python.org/zh-cn/3/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a> 用于从URL检索数据，以及 <a href="https://docs.python.org/zh-cn/3/library/smtplib.html#module-smtplib" target="_blank" rel="noopener"><code>smtplib</code></a> 用于发送邮件:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from urllib.request import urlopen</span><br><span class="line">&gt;&gt;&gt; with urlopen(&#39;http:&#x2F;&#x2F;tycho.usno.navy.mil&#x2F;cgi-bin&#x2F;timer.pl&#39;) as response:</span><br><span class="line">...     for line in response:</span><br><span class="line">...         line &#x3D; line.decode(&#39;utf-8&#39;)  # Decoding the binary data to text.</span><br><span class="line">...         if &#39;EST&#39; in line or &#39;EDT&#39; in line:  # look for Eastern Time</span><br><span class="line">...             print(line)</span><br><span class="line"></span><br><span class="line">&lt;BR&gt;Nov. 25, 09:43:32 PM EST</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import smtplib</span><br><span class="line">&gt;&gt;&gt; server &#x3D; smtplib.SMTP(&#39;localhost&#39;)</span><br><span class="line">&gt;&gt;&gt; server.sendmail(&#39;soothsayer@example.org&#39;, &#39;jcaesar@example.org&#39;,</span><br><span class="line">... &quot;&quot;&quot;To: jcaesar@example.org</span><br><span class="line">... From: soothsayer@example.org</span><br><span class="line">...</span><br><span class="line">... Beware the Ides of March.</span><br><span class="line">... &quot;&quot;&quot;)</span><br><span class="line">&gt;&gt;&gt; server.quit()</span><br></pre></td></tr></table></figure>

<p>（请注意，第二个示例需要在localhost上运行的邮件服务器。）</p>
<h2 id="10-8-日期和时间"><a href="#10-8-日期和时间" class="headerlink" title="10.8. 日期和时间"></a>10.8. 日期和时间</h2><p><a href="https://docs.python.org/zh-cn/3/library/datetime.html#module-datetime" target="_blank" rel="noopener"><code>datetime</code></a> 模块提供了以简单和复杂的方式操作日期和时间的类。虽然支持日期和时间算法，但实现的重点是有效的成员提取以进行输出格式化和操作。该模块还支持可感知时区的对象。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # dates are easily constructed and formatted</span><br><span class="line">&gt;&gt;&gt; from datetime import date</span><br><span class="line">&gt;&gt;&gt; now &#x3D; date.today()</span><br><span class="line">&gt;&gt;&gt; now</span><br><span class="line">datetime.date(2003, 12, 2)</span><br><span class="line">&gt;&gt;&gt; now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;)</span><br><span class="line">&#39;12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # dates support calendar arithmetic</span><br><span class="line">&gt;&gt;&gt; birthday &#x3D; date(1964, 7, 31)</span><br><span class="line">&gt;&gt;&gt; age &#x3D; now - birthday</span><br><span class="line">&gt;&gt;&gt; age.days</span><br><span class="line">14368</span><br></pre></td></tr></table></figure>



<h2 id="10-9-数据压缩"><a href="#10-9-数据压缩" class="headerlink" title="10.9. 数据压缩"></a>10.9. 数据压缩</h2><p>常见的数据存档和压缩格式由模块直接支持，包括：<a href="https://docs.python.org/zh-cn/3/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a>, <a href="https://docs.python.org/zh-cn/3/library/gzip.html#module-gzip" target="_blank" rel="noopener"><code>gzip</code></a>, <a href="https://docs.python.org/zh-cn/3/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a>, <a href="https://docs.python.org/zh-cn/3/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a>, <a href="https://docs.python.org/zh-cn/3/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a>。:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import zlib</span><br><span class="line">&gt;&gt;&gt; s &#x3D; b&#39;witch which has which witches wrist watch&#39;</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">41</span><br><span class="line">&gt;&gt;&gt; t &#x3D; zlib.compress(s)</span><br><span class="line">&gt;&gt;&gt; len(t)</span><br><span class="line">37</span><br><span class="line">&gt;&gt;&gt; zlib.decompress(t)</span><br><span class="line">b&#39;witch which has which witches wrist watch&#39;</span><br><span class="line">&gt;&gt;&gt; zlib.crc32(s)</span><br><span class="line">226805979</span><br></pre></td></tr></table></figure>



<h2 id="10-10-性能测量"><a href="#10-10-性能测量" class="headerlink" title="10.10. 性能测量"></a>10.10. 性能测量</h2><p>一些Python用户对了解同一问题的不同方法的相对性能产生了浓厚的兴趣。 Python提供了一种可以立即回答这些问题的测量工具。</p>
<p>例如，元组封包和拆包功能相比传统的交换参数可能更具吸引力。<a href="https://docs.python.org/zh-cn/3/library/timeit.html#module-timeit" target="_blank" rel="noopener"><code>timeit</code></a> 模块可以快速演示在运行效率方面一定的优势:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from timeit import Timer</span><br><span class="line">&gt;&gt;&gt; Timer(&#39;t&#x3D;a; a&#x3D;b; b&#x3D;t&#39;, &#39;a&#x3D;1; b&#x3D;2&#39;).timeit()</span><br><span class="line">0.57535828626024577</span><br><span class="line">&gt;&gt;&gt; Timer(&#39;a,b &#x3D; b,a&#39;, &#39;a&#x3D;1; b&#x3D;2&#39;).timeit()</span><br><span class="line">0.54962537085770791</span><br></pre></td></tr></table></figure>

<p>与 <a href="https://docs.python.org/zh-cn/3/library/timeit.html#module-timeit" target="_blank" rel="noopener"><code>timeit</code></a> 的精细粒度级别相反， <a href="https://docs.python.org/zh-cn/3/library/profile.html#module-profile" target="_blank" rel="noopener"><code>profile</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/profile.html#module-pstats" target="_blank" rel="noopener"><code>pstats</code></a> 模块提供了用于在较大的代码块中识别时间关键部分的工具。</p>
<h2 id="10-11-质量控制"><a href="#10-11-质量控制" class="headerlink" title="10.11. 质量控制"></a>10.11. 质量控制</h2><p>开发高质量软件的一种方法是在开发过程中为每个函数编写测试，并在开发过程中经常运行这些测试。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a> 模块提供了一个工具，用于扫描模块并验证程序文档字符串中嵌入的测试。测试构造就像将典型调用及其结果剪切并粘贴到文档字符串一样简单。这通过向用户提供示例来改进文档，并且它允许doctest模块确保代码保持对文档的真实:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def average(values):</span><br><span class="line">    &quot;&quot;&quot;Computes the arithmetic mean of a list of numbers.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; print(average([20, 30, 70]))</span><br><span class="line">    40.0</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return sum(values) &#x2F; len(values)</span><br><span class="line"></span><br><span class="line">import doctest</span><br><span class="line">doctest.testmod()   # automatically validate the embedded tests</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 模块不像 <a href="https://docs.python.org/zh-cn/3/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a> 模块那样易于使用，但它允许在一个单独的文件中维护更全面的测试集:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class TestStatisticalFunctions(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_average(self):</span><br><span class="line">        self.assertEqual(average([20, 30, 70]), 40.0)</span><br><span class="line">        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)</span><br><span class="line">        with self.assertRaises(ZeroDivisionError):</span><br><span class="line">            average([])</span><br><span class="line">        with self.assertRaises(TypeError):</span><br><span class="line">            average(20, 30, 70)</span><br><span class="line"></span><br><span class="line">unittest.main()  # Calling from the command line invokes all tests</span><br></pre></td></tr></table></figure>



<h2 id="10-12-自带电池"><a href="#10-12-自带电池" class="headerlink" title="10.12. 自带电池"></a>10.12. 自带电池</h2><p>Python有“自带电池”的理念。通过其包的复杂和强大功能可以最好地看到这一点。例如:</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3/library/xmlrpc.client.html#module-xmlrpc.client" target="_blank" rel="noopener"><code>xmlrpc.client</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/xmlrpc.server.html#module-xmlrpc.server" target="_blank" rel="noopener"><code>xmlrpc.server</code></a> 模块使远程过程调用实现了几乎无关紧要的任务。尽管有模块名称，但不需要直接了解或处理XML。</li>
<li><a href="https://docs.python.org/zh-cn/3/library/email.html#module-email" target="_blank" rel="noopener"><code>email</code></a> 包是一个用于管理电子邮件的库，包括MIME和其他：基于 <a href="https://tools.ietf.org/html/rfc2822.html" target="_blank" rel="noopener"><strong>RFC 2822</strong></a> 的邮件文档。与 <a href="https://docs.python.org/zh-cn/3/library/smtplib.html#module-smtplib" target="_blank" rel="noopener"><code>smtplib</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/poplib.html#module-poplib" target="_blank" rel="noopener"><code>poplib</code></a> 实际上发送和接收消息不同，电子邮件包具有完整的工具集，用于构建或解码复杂的消息结构（包括附件）以及实现互联网编码和标头协议。</li>
<li><a href="https://docs.python.org/zh-cn/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 包为解析这种流行的数据交换格式提供了强大的支持。 <a href="https://docs.python.org/zh-cn/3/library/csv.html#module-csv" target="_blank" rel="noopener"><code>csv</code></a> 模块支持以逗号分隔值格式直接读取和写入文件，这些格式通常由数据库和电子表格支持。 XML处理由 <a href="https://docs.python.org/zh-cn/3/library/xml.etree.elementtree.html#module-xml.etree.ElementTree" target="_blank" rel="noopener"><code>xml.etree.ElementTree</code></a> ， <a href="https://docs.python.org/zh-cn/3/library/xml.dom.html#module-xml.dom" target="_blank" rel="noopener"><code>xml.dom</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/xml.sax.html#module-xml.sax" target="_blank" rel="noopener"><code>xml.sax</code></a> 包支持。这些模块和软件包共同大大简化了Python应用程序和其他工具之间的数据交换。</li>
<li><a href="https://docs.python.org/zh-cn/3/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块是SQLite数据库库的包装器，提供了一个可以使用稍微非标准的SQL语法更新和访问的持久数据库。</li>
<li>国际化由许多模块支持，包括 <a href="https://docs.python.org/zh-cn/3/library/gettext.html#module-gettext" target="_blank" rel="noopener"><code>gettext</code></a> ， <a href="https://docs.python.org/zh-cn/3/library/locale.html#module-locale" target="_blank" rel="noopener"><code>locale</code></a> ，以及 <a href="https://docs.python.org/zh-cn/3/library/codecs.html#module-codecs" target="_blank" rel="noopener"><code>codecs</code></a> 包。</li>
</ul>
<h1 id="11-标准库简介-——-第二部分"><a href="#11-标准库简介-——-第二部分" class="headerlink" title="11. 标准库简介 —— 第二部分"></a>11. 标准库简介 —— 第二部分</h1><p>第二部分涵盖了专业编程所需要的更高级的模块。这些模块很少用在小脚本中。</p>
<h2 id="11-1-格式化输出"><a href="#11-1-格式化输出" class="headerlink" title="11.1. 格式化输出"></a>11.1. 格式化输出</h2><p><a href="https://docs.python.org/zh-cn/3/library/reprlib.html#module-reprlib" target="_blank" rel="noopener"><code>reprlib</code></a> 模块提供了一个定制化版本的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数，用于缩略显示大型或深层嵌套的容器对象:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import reprlib</span><br><span class="line">&gt;&gt;&gt; reprlib.repr(set(&#39;supercalifragilisticexpialidocious&#39;))</span><br><span class="line">&quot;&#123;&#39;a&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, ...&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint</code></a> 模块提供了更加复杂的打印控制，其输出的内置对象和用户自定义对象能够被解释器直接读取。当输出结果过长而需要折行时，“美化输出机制”会添加换行符和缩进，以更清楚地展示数据结构:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pprint</span><br><span class="line">&gt;&gt;&gt; t &#x3D; [[[[&#39;black&#39;, &#39;cyan&#39;], &#39;white&#39;, [&#39;green&#39;, &#39;red&#39;]], [[&#39;magenta&#39;,</span><br><span class="line">...     &#39;yellow&#39;], &#39;blue&#39;]]]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; pprint.pprint(t, width&#x3D;30)</span><br><span class="line">[[[[&#39;black&#39;, &#39;cyan&#39;],</span><br><span class="line">   &#39;white&#39;,</span><br><span class="line">   [&#39;green&#39;, &#39;red&#39;]],</span><br><span class="line">  [[&#39;magenta&#39;, &#39;yellow&#39;],</span><br><span class="line">   &#39;blue&#39;]]]</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/textwrap.html#module-textwrap" target="_blank" rel="noopener"><code>textwrap</code></a> 模块能够格式化文本段落，以适应给定的屏幕宽度:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import textwrap</span><br><span class="line">&gt;&gt;&gt; doc &#x3D; &quot;&quot;&quot;The wrap() method is just like fill() except that it returns</span><br><span class="line">... a list of strings instead of one big string with newlines to separate</span><br><span class="line">... the wrapped lines.&quot;&quot;&quot;</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(textwrap.fill(doc, width&#x3D;40))</span><br><span class="line">The wrap() method is just like fill()</span><br><span class="line">except that it returns a list of strings</span><br><span class="line">instead of one big string with newlines</span><br><span class="line">to separate the wrapped lines.</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/locale.html#module-locale" target="_blank" rel="noopener"><code>locale</code></a> 模块处理与特定地域文化相关的数据格式。locale 模块的 format 函数包含一个 grouping 属性，可直接将数字格式化为带有组分隔符的样式:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import locale</span><br><span class="line">&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, &#39;English_United States.1252&#39;)</span><br><span class="line">&#39;English_United States.1252&#39;</span><br><span class="line">&gt;&gt;&gt; conv &#x3D; locale.localeconv()          # get a mapping of conventions</span><br><span class="line">&gt;&gt;&gt; x &#x3D; 1234567.8</span><br><span class="line">&gt;&gt;&gt; locale.format(&quot;%d&quot;, x, grouping&#x3D;True)</span><br><span class="line">&#39;1,234,567&#39;</span><br><span class="line">&gt;&gt;&gt; locale.format_string(&quot;%s%.*f&quot;, (conv[&#39;currency_symbol&#39;],</span><br><span class="line">...                      conv[&#39;frac_digits&#39;], x), grouping&#x3D;True)</span><br><span class="line">&#39;$1,234,567.80&#39;</span><br></pre></td></tr></table></figure>



<h2 id="11-2-模板"><a href="#11-2-模板" class="headerlink" title="11.2. 模板"></a>11.2. 模板</h2><p><a href="https://docs.python.org/zh-cn/3/library/string.html#module-string" target="_blank" rel="noopener"><code>string</code></a> 模块包含一个通用的 <a href="https://docs.python.org/zh-cn/3/library/string.html#string.Template" target="_blank" rel="noopener"><code>Template</code></a> 类，具有适用于最终用户的简化语法。它允许用户在不更改应用逻辑的情况下定制自己的应用。</p>
<p>上述格式化操作是通过占位符实现的，占位符由 <code>$</code> 加上合法的 Python 标识符（只能包含字母、数字和下划线）构成。一旦使用花括号将占位符括起来，就可以在后面直接跟上更多的字母和数字而无需空格分割。<code>$$</code> 将被转义成单个字符 <code>$</code>:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from string import Template</span><br><span class="line">&gt;&gt;&gt; t &#x3D; Template(&#39;$&#123;village&#125;folk send $$10 to $cause.&#39;)</span><br><span class="line">&gt;&gt;&gt; t.substitute(village&#x3D;&#39;Nottingham&#39;, cause&#x3D;&#39;the ditch fund&#39;)</span><br><span class="line">&#39;Nottinghamfolk send $10 to the ditch fund.&#39;</span><br></pre></td></tr></table></figure>

<p>如果在字典或关键字参数中未提供某个占位符的值，那么 <a href="https://docs.python.org/zh-cn/3/library/string.html#string.Template.substitute" target="_blank" rel="noopener"><code>substitute()</code></a> 方法将抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。对于邮件合并类型的应用，用户提供的数据有可能是不完整的，此时使用 <a href="https://docs.python.org/zh-cn/3/library/string.html#string.Template.safe_substitute" target="_blank" rel="noopener"><code>safe_substitute()</code></a> 方法更加合适 —— 如果数据缺失，它会直接将占位符原样保留。</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; Template(&#39;Return the $item to $owner.&#39;)</span><br><span class="line">&gt;&gt;&gt; d &#x3D; dict(item&#x3D;&#39;unladen swallow&#39;)</span><br><span class="line">&gt;&gt;&gt; t.substitute(d)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">KeyError: &#39;owner&#39;</span><br><span class="line">&gt;&gt;&gt; t.safe_substitute(d)</span><br><span class="line">&#39;Return the unladen swallow to $owner.&#39;</span><br></pre></td></tr></table></figure>

<p>Template 的子类可以自定义定界符。例如，以下是某个照片浏览器的批量重命名功能，采用了百分号作为日期、照片序号和照片格式的占位符:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import time, os.path</span><br><span class="line">&gt;&gt;&gt; photofiles &#x3D; [&#39;img_1074.jpg&#39;, &#39;img_1076.jpg&#39;, &#39;img_1077.jpg&#39;]</span><br><span class="line">&gt;&gt;&gt; class BatchRename(Template):</span><br><span class="line">...     delimiter &#x3D; &#39;%&#39;</span><br><span class="line">&gt;&gt;&gt; fmt &#x3D; input(&#39;Enter rename style (%d-date %n-seqnum %f-format):  &#39;)</span><br><span class="line">Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t &#x3D; BatchRename(fmt)</span><br><span class="line">&gt;&gt;&gt; date &#x3D; time.strftime(&#39;%d%b%y&#39;)</span><br><span class="line">&gt;&gt;&gt; for i, filename in enumerate(photofiles):</span><br><span class="line">...     base, ext &#x3D; os.path.splitext(filename)</span><br><span class="line">...     newname &#x3D; t.substitute(d&#x3D;date, n&#x3D;i, f&#x3D;ext)</span><br><span class="line">...     print(&#39;&#123;0&#125; --&gt; &#123;1&#125;&#39;.format(filename, newname))</span><br><span class="line"></span><br><span class="line">img_1074.jpg --&gt; Ashley_0.jpg</span><br><span class="line">img_1076.jpg --&gt; Ashley_1.jpg</span><br><span class="line">img_1077.jpg --&gt; Ashley_2.jpg</span><br></pre></td></tr></table></figure>

<p>模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来。这使得对 XML 文件、纯文本报表和 HTML 网络报表使用自定义模板成为可能。</p>
<h2 id="11-3-使用二进制数据记录格式"><a href="#11-3-使用二进制数据记录格式" class="headerlink" title="11.3. 使用二进制数据记录格式"></a>11.3. 使用二进制数据记录格式</h2><p><a href="https://docs.python.org/zh-cn/3/library/struct.html#module-struct" target="_blank" rel="noopener"><code>struct</code></a> 模块提供了 <a href="https://docs.python.org/zh-cn/3/library/struct.html#struct.pack" target="_blank" rel="noopener"><code>pack()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/struct.html#struct.unpack" target="_blank" rel="noopener"><code>unpack()</code></a> 函数，用于处理不定长度的二进制记录格式。下面的例子展示了在不使用 <a href="https://docs.python.org/zh-cn/3/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 模块的情况下，如何循环遍历一个 ZIP 文件的所有头信息。Pack 代码 <code>&quot;H&quot;</code> 和 <code>&quot;I&quot;</code> 分别代表两字节和四字节无符号整数。<code>&quot;&lt;&quot;</code> 代表它们是标准尺寸的小尾型字节序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import struct</span><br><span class="line"></span><br><span class="line">with open(&#39;myfile.zip&#39;, &#39;rb&#39;) as f:</span><br><span class="line">    data &#x3D; f.read()</span><br><span class="line"></span><br><span class="line">start &#x3D; 0</span><br><span class="line">for i in range(3):                      # show the first 3 file headers</span><br><span class="line">    start +&#x3D; 14</span><br><span class="line">    fields &#x3D; struct.unpack(&#39;&lt;IIIHH&#39;, data[start:start+16])</span><br><span class="line">    crc32, comp_size, uncomp_size, filenamesize, extra_size &#x3D; fields</span><br><span class="line"></span><br><span class="line">    start +&#x3D; 16</span><br><span class="line">    filename &#x3D; data[start:start+filenamesize]</span><br><span class="line">    start +&#x3D; filenamesize</span><br><span class="line">    extra &#x3D; data[start:start+extra_size]</span><br><span class="line">    print(filename, hex(crc32), comp_size, uncomp_size)</span><br><span class="line"></span><br><span class="line">    start +&#x3D; extra_size + comp_size     # skip to the next header</span><br></pre></td></tr></table></figure>



<h2 id="11-4-多线程"><a href="#11-4-多线程" class="headerlink" title="11.4. 多线程"></a>11.4. 多线程</h2><p>线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 I/O 和计算运行在两个并行的线程中。</p>
<p>以下代码展示了高阶的 <a href="https://docs.python.org/zh-cn/3/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块如何在后台运行任务，且不影响主程序的继续运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import threading, zipfile</span><br><span class="line"></span><br><span class="line">class AsyncZip(threading.Thread):</span><br><span class="line">    def __init__(self, infile, outfile):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.infile &#x3D; infile</span><br><span class="line">        self.outfile &#x3D; outfile</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        f &#x3D; zipfile.ZipFile(self.outfile, &#39;w&#39;, zipfile.ZIP_DEFLATED)</span><br><span class="line">        f.write(self.infile)</span><br><span class="line">        f.close()</span><br><span class="line">        print(&#39;Finished background zip of:&#39;, self.infile)</span><br><span class="line"></span><br><span class="line">background &#x3D; AsyncZip(&#39;mydata.txt&#39;, &#39;myarchive.zip&#39;)</span><br><span class="line">background.start()</span><br><span class="line">print(&#39;The main program continues to run in foreground.&#39;)</span><br><span class="line"></span><br><span class="line">background.join()    # Wait for the background task to finish</span><br><span class="line">print(&#39;Main program waited until background was done.&#39;)</span><br></pre></td></tr></table></figure>

<p>多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。为此，threading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。</p>
<p>尽管这些工具非常强大，但微小的设计错误却可以导致一些难以复现的问题。因此，实现多任务协作的首选方法是将对资源的所有请求集中到一个线程中，然后使用 <a href="https://docs.python.org/zh-cn/3/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 模块向该线程供应来自其他线程的请求。应用程序使用 <a href="https://docs.python.org/zh-cn/3/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 对象进行线程间通信和协调，更易于设计，更易读，更可靠。</p>
<h2 id="11-5-日志"><a href="#11-5-日志" class="headerlink" title="11.5. 日志"></a>11.5. 日志</h2><p><a href="https://docs.python.org/zh-cn/3/library/logging.html#module-logging" target="_blank" rel="noopener"><code>logging</code></a> 模块提供功能齐全且灵活的日志记录系统。在最简单的情况下，日志消息被发送到文件或 <code>sys.stderr</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.debug(&#39;Debugging information&#39;)</span><br><span class="line">logging.info(&#39;Informational message&#39;)</span><br><span class="line">logging.warning(&#39;Warning:config file %s not found&#39;, &#39;server.conf&#39;)</span><br><span class="line">logging.error(&#39;Error occurred&#39;)</span><br><span class="line">logging.critical(&#39;Critical error -- shutting down&#39;)</span><br></pre></td></tr></table></figure>

<p>这会产生以下输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING:root:Warning:config file server.conf not found</span><br><span class="line">ERROR:root:Error occurred</span><br><span class="line">CRITICAL:root:Critical error -- shutting down</span><br></pre></td></tr></table></figure>

<p>默认情况下，informational 和 debugging 消息被压制，输出会发送到标准错误流。其他输出选项包括将消息转发到电子邮件，数据报，套接字或 HTTP 服务器。新的过滤器可以根据消息优先级选择不同的路由方式：<code>DEBUG</code>，<code>INFO</code>，<code>WARNING</code>，<code>ERROR</code>，和 <code>CRITICAL</code>。</p>
<p>日志系统可以直接从 Python 配置，也可以从用户配置文件加载，以便自定义日志记录而无需更改应用程序。</p>
<h2 id="11-6-弱引用"><a href="#11-6-弱引用" class="headerlink" title="11.6. 弱引用"></a>11.6. 弱引用</h2><p>Python 会自动进行内存管理（对大多数对象进行引用计数并使用 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-garbage-collection" target="_blank" rel="noopener">garbage collection</a> 来清除循环引用）。 当某个对象的最后一个引用被移除后不久就会释放其所占用的内存。</p>
<p>此方式对大多数应用来说都适用，但偶尔也必须在对象持续被其他对象所使用时跟踪它们。 不幸的是，跟踪它们将创建一个会令其永久化的引用。 <a href="https://docs.python.org/zh-cn/3/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块提供的工具可以不必创建引用就能跟踪对象。 当对象不再需要时，它将自动从一个弱引用表中被移除，并为弱引用对象触发一个回调。 典型应用包括对创建开销较大的对象进行缓存:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import weakref, gc</span><br><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     def __init__(self, value):</span><br><span class="line">...         self.value &#x3D; value</span><br><span class="line">...     def __repr__(self):</span><br><span class="line">...         return str(self.value)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a &#x3D; A(10)                   # create a reference</span><br><span class="line">&gt;&gt;&gt; d &#x3D; weakref.WeakValueDictionary()</span><br><span class="line">&gt;&gt;&gt; d[&#39;primary&#39;] &#x3D; a            # does not create a reference</span><br><span class="line">&gt;&gt;&gt; d[&#39;primary&#39;]                # fetch the object if it is still alive</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; del a                       # remove the one reference</span><br><span class="line">&gt;&gt;&gt; gc.collect()                # run garbage collection right away</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; d[&#39;primary&#39;]                # entry was automatically removed</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d[&#39;primary&#39;]                # entry was automatically removed</span><br><span class="line">  File &quot;C:&#x2F;python38&#x2F;lib&#x2F;weakref.py&quot;, line 46, in __getitem__</span><br><span class="line">    o &#x3D; self.data[key]()</span><br><span class="line">KeyError: &#39;primary&#39;</span><br></pre></td></tr></table></figure>



<h2 id="11-7-用于操作列表的工具"><a href="#11-7-用于操作列表的工具" class="headerlink" title="11.7. 用于操作列表的工具"></a>11.7. 用于操作列表的工具</h2><p>许多对于数据结构的需求可以通过内置列表类型来满足。 但是，有时也会需要具有不同效费比的替代实现。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/array.html#module-array" target="_blank" rel="noopener"><code>array</code></a> 模块提供了一种 <a href="https://docs.python.org/zh-cn/3/library/array.html#array.array" target="_blank" rel="noopener"><code>array()</code></a> 对象，它类似于列表，但只能存储类型一致的数据且存储密集更高。 下面的例子演示了一个以两个字节为存储单元的无符号二进制数值的数组 (类型码为 <code>&quot;H&quot;</code>)，而对于普通列表来说，每个条目存储为标准 Python 的 int 对象通常要占用16 个字节:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from array import array</span><br><span class="line">&gt;&gt;&gt; a &#x3D; array(&#39;H&#39;, [4000, 10, 700, 22222])</span><br><span class="line">&gt;&gt;&gt; sum(a)</span><br><span class="line">26932</span><br><span class="line">&gt;&gt;&gt; a[1:3]</span><br><span class="line">array(&#39;H&#39;, [10, 700])</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/collections.html#module-collections" target="_blank" rel="noopener"><code>collections</code></a> 模块提供了一种 <a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.deque" target="_blank" rel="noopener"><code>deque()</code></a> 对象，它类似于列表，但从左端添加和弹出的速度较快，而在中间查找的速度较慢。 此种对象适用于实现队列和广度优先树搜索:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; d &#x3D; deque([&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;])</span><br><span class="line">&gt;&gt;&gt; d.append(&quot;task4&quot;)</span><br><span class="line">&gt;&gt;&gt; print(&quot;Handling&quot;, d.popleft())</span><br><span class="line">Handling task1</span><br><span class="line">unsearched &#x3D; deque([starting_node])</span><br><span class="line">def breadth_first_search(unsearched):</span><br><span class="line">    node &#x3D; unsearched.popleft()</span><br><span class="line">    for m in gen_moves(node):</span><br><span class="line">        if is_goal(m):</span><br><span class="line">            return m</span><br><span class="line">        unsearched.append(m)</span><br></pre></td></tr></table></figure>

<p>在替代的列表实现以外，标准库也提供了其他工具，例如 <a href="https://docs.python.org/zh-cn/3/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect</code></a> 模块具有用于操作排序列表的函数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import bisect</span><br><span class="line">&gt;&gt;&gt; scores &#x3D; [(100, &#39;perl&#39;), (200, &#39;tcl&#39;), (400, &#39;lua&#39;), (500, &#39;python&#39;)]</span><br><span class="line">&gt;&gt;&gt; bisect.insort(scores, (300, &#39;ruby&#39;))</span><br><span class="line">&gt;&gt;&gt; scores</span><br><span class="line">[(100, &#39;perl&#39;), (200, &#39;tcl&#39;), (300, &#39;ruby&#39;), (400, &#39;lua&#39;), (500, &#39;python&#39;)]</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/heapq.html#module-heapq" target="_blank" rel="noopener"><code>heapq</code></a> 模块提供了基于常规列表来实现堆的函数。 最小值的条目总是保持在位置零。 这对于需要重复访问最小元素而不希望运行完整列表排序的应用来说非常有用:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from heapq import heapify, heappop, heappush</span><br><span class="line">&gt;&gt;&gt; data &#x3D; [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]</span><br><span class="line">&gt;&gt;&gt; heapify(data)                      # rearrange the list into heap order</span><br><span class="line">&gt;&gt;&gt; heappush(data, -5)                 # add a new entry</span><br><span class="line">&gt;&gt;&gt; [heappop(data) for i in range(3)]  # fetch the three smallest entries</span><br><span class="line">[-5, 0, 1]</span><br></pre></td></tr></table></figure>



<h2 id="11-8-十进制浮点运算"><a href="#11-8-十进制浮点运算" class="headerlink" title="11.8. 十进制浮点运算"></a>11.8. 十进制浮点运算</h2><p><a href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal" target="_blank" rel="noopener"><code>decimal</code></a> 模块提供了一种 <a href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 数据类型用于十进制浮点运算。 相比内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 二进制浮点实现，该类特别适用于</p>
<ul>
<li>财务应用和其他需要精确十进制表示的用途，</li>
<li>控制精度，</li>
<li>控制四舍五入以满足法律或监管要求，</li>
<li>跟踪有效小数位，或</li>
<li>用户期望结果与手工完成的计算相匹配的应用程序。</li>
</ul>
<p>例如，使用十进制浮点和二进制浮点数计算70美分手机和5％税的总费用，会产生的不同结果。如果结果四舍五入到最接近的分数差异会更大:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from decimal import *</span><br><span class="line">&gt;&gt;&gt; round(Decimal(&#39;0.70&#39;) * Decimal(&#39;1.05&#39;), 2)</span><br><span class="line">Decimal(&#39;0.74&#39;)</span><br><span class="line">&gt;&gt;&gt; round(.70 * 1.05, 2)</span><br><span class="line">0.73</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 表示的结果会保留尾部的零，并根据具有两个有效位的被乘数自动推出四个有效位。 Decimal 可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题。</p>
<p>精确表示特性使得 <a href="https://docs.python.org/zh-cn/3/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 类能够执行对于二进制浮点数来说不适用的模运算和相等性检测:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Decimal(&#39;1.00&#39;) % Decimal(&#39;.10&#39;)</span><br><span class="line">Decimal(&#39;0.00&#39;)</span><br><span class="line">&gt;&gt;&gt; 1.00 % 0.10</span><br><span class="line">0.09999999999999995</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sum([Decimal(&#39;0.1&#39;)]*10) &#x3D;&#x3D; Decimal(&#39;1.0&#39;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; sum([0.1]*10) &#x3D;&#x3D; 1.0</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal" target="_blank" rel="noopener"><code>decimal</code></a> 模块提供了运算所需要的足够精度:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getcontext().prec &#x3D; 36</span><br><span class="line">&gt;&gt;&gt; Decimal(1) &#x2F; Decimal(7)</span><br><span class="line">Decimal(&#39;0.142857142857142857142857142857142857&#39;)</span><br></pre></td></tr></table></figure>

<h1 id="12-虚拟环境和包"><a href="#12-虚拟环境和包" class="headerlink" title="12. 虚拟环境和包"></a>12. 虚拟环境和包</h1><h2 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1. 概述"></a>12.1. 概述</h2><p>Python应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。</p>
<p>这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版本但应用程序B需要2.0版本，则需求存在冲突，安装版本1.0或2.0将导致某一个应用程序无法运行。</p>
<p>这个问题的解决方案是创建一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-virtual-environment" target="_blank" rel="noopener">virtual environment</a>，一个目录树，其中安装有特定Python版本，以及许多其他包。</p>
<p>然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。</p>
<h2 id="12-2-创建虚拟环境"><a href="#12-2-创建虚拟环境" class="headerlink" title="12.2. 创建虚拟环境"></a>12.2. 创建虚拟环境</h2><p>用于创建和管理虚拟环境的模块称为 <a href="https://docs.python.org/zh-cn/3/library/venv.html#module-venv" target="_blank" rel="noopener"><code>venv</code></a>。<a href="https://docs.python.org/zh-cn/3/library/venv.html#module-venv" target="_blank" rel="noopener"><code>venv</code></a> 通常会安装你可用的最新版本的 Python。如果您的系统上有多个版本的 Python，您可以通过运行 <code>python3</code> 或您想要的任何版本来选择特定的Python版本。</p>
<p>要创建虚拟环境，请确定要放置它的目录，并将 <a href="https://docs.python.org/zh-cn/3/library/venv.html#module-venv" target="_blank" rel="noopener"><code>venv</code></a> 模块作为脚本运行目录路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv tutorial-env</span><br></pre></td></tr></table></figure>

<p>如果它不存在，这将创建 <code>tutorial-env</code> 目录，并在其中创建包含Python解释器，标准库和各种支持文件的副本的目录。</p>
<p>虚拟环境的常用目录位置是 <code>.venv</code>。 这个名称通常会令该目录在你的终端中保持隐藏，从而避免需要对所在目录进行额外解释的一般名称。 它还能防止与某些工具所支持的 <code>.env</code> 环境变量定义文件发生冲突。</p>
<p>创建虚拟环境后，您可以激活它。</p>
<p>在Windows上，运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tutorial-env\Scripts\activate.bat</span><br></pre></td></tr></table></figure>

<p>在Unix或MacOS上，运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source tutorial-env&#x2F;bin&#x2F;activate</span><br></pre></td></tr></table></figure>

<p>（这个脚本是为bash shell编写的。如果你使用 <strong>csh</strong> 或 <strong>fish</strong> shell，你应该改用 <code>activate.csh</code> 或 <code>activate.fish</code> 脚本。）</p>
<p>Activating the virtual environment will change your shell’s prompt to show what virtual environment you’re using, and modify the environment so that running <code>python</code> will get you that particular version and installation of Python. For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ source ~&#x2F;envs&#x2F;tutorial-env&#x2F;bin&#x2F;activate</span><br><span class="line">(tutorial-env) $ python</span><br><span class="line">Python 3.5.1 (default, May  6 2016, 10:59:36)</span><br><span class="line">  ...</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#39;&#39;, &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python35.zip&#39;, ...,</span><br><span class="line">&#39;~&#x2F;envs&#x2F;tutorial-env&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#39;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="12-3-使用pip管理包"><a href="#12-3-使用pip管理包" class="headerlink" title="12.3. 使用pip管理包"></a>12.3. 使用pip管理包</h2><p>你可以使用一个名为 <strong>pip</strong> 的程序来安装、升级和移除软件包。默认情况下 <code>pip</code> 将从 Python Package Index &lt;<a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org</a>&gt; 安装软件包。你可以在浏览器中访问 Python Package Index 或是使用 <code>pip</code> 受限的搜索功能:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip search astronomy</span><br><span class="line">skyfield               - Elegant astronomy for Python</span><br><span class="line">gary                   - Galactic astronomy and gravitational dynamics.</span><br><span class="line">novas                  - The United States Naval Observatory NOVAS astronomy library</span><br><span class="line">astroobs               - Provides astronomy ephemeris to plan telescope observations</span><br><span class="line">PyAstronomy            - A collection of astronomy related tools for Python.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>pip</code> 有许多子命令：“search”、“install”、“uninstall”、“freeze”等等。（请参阅 <a href="https://docs.python.org/zh-cn/3/installing/index.html#installing-index" target="_blank" rel="noopener">安装 Python 模块</a> 指南以了解 <code>pip</code> 的完整文档。）</p>
<p>您可以通过指定包的名称来安装最新版本的包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip install novas</span><br><span class="line">Collecting novas</span><br><span class="line">  Downloading novas-3.1.1.3.tar.gz (136kB)</span><br><span class="line">Installing collected packages: novas</span><br><span class="line">  Running setup.py install for novas</span><br><span class="line">Successfully installed novas-3.1.1.3</span><br></pre></td></tr></table></figure>

<p>您还可以通过提供包名称后跟 <code>==</code> 和版本号来安装特定版本的包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip install requests&#x3D;&#x3D;2.6.0</span><br><span class="line">Collecting requests&#x3D;&#x3D;2.6.0</span><br><span class="line">  Using cached requests-2.6.0-py2.py3-none-any.whl</span><br><span class="line">Installing collected packages: requests</span><br><span class="line">Successfully installed requests-2.6.0</span><br></pre></td></tr></table></figure>

<p>如果你重新运行这个命令，<code>pip</code> 会注意到已经安装了所请求的版本并且什么都不做。您可以提供不同的版本号来获取该版本，或者您可以运行 <code>pip install --upgrade</code> 将软件包升级到最新版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip install --upgrade requests</span><br><span class="line">Collecting requests</span><br><span class="line">Installing collected packages: requests</span><br><span class="line">  Found existing installation: requests 2.6.0</span><br><span class="line">    Uninstalling requests-2.6.0:</span><br><span class="line">      Successfully uninstalled requests-2.6.0</span><br><span class="line">Successfully installed requests-2.7.0</span><br></pre></td></tr></table></figure>

<p><code>pip uninstall</code> 后跟一个或多个包名称将从虚拟环境中删除包。</p>
<p><code>pip show</code> 将显示有关特定包的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip show requests</span><br><span class="line">---</span><br><span class="line">Metadata-Version: 2.0</span><br><span class="line">Name: requests</span><br><span class="line">Version: 2.7.0</span><br><span class="line">Summary: Python HTTP for Humans.</span><br><span class="line">Home-page: http:&#x2F;&#x2F;python-requests.org</span><br><span class="line">Author: Kenneth Reitz</span><br><span class="line">Author-email: me@kennethreitz.com</span><br><span class="line">License: Apache 2.0</span><br><span class="line">Location: &#x2F;Users&#x2F;akuchling&#x2F;envs&#x2F;tutorial-env&#x2F;lib&#x2F;python3.4&#x2F;site-packages</span><br><span class="line">Requires:</span><br></pre></td></tr></table></figure>

<p><code>pip list</code> 将显示虚拟环境中安装的所有软件包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip list</span><br><span class="line">novas (3.1.1.3)</span><br><span class="line">numpy (1.9.2)</span><br><span class="line">pip (7.0.3)</span><br><span class="line">requests (2.7.0)</span><br><span class="line">setuptools (16.0)</span><br></pre></td></tr></table></figure>

<p>pip freeze<code>将生成一个类似的已安装包列表，但输出使用</code>pip install<code>期望的格式。一个常见的约定是将此列表放在</code>requirements.txt` 文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip freeze &gt; requirements.txt</span><br><span class="line">(tutorial-env) $ cat requirements.txt</span><br><span class="line">novas&#x3D;&#x3D;3.1.1.3</span><br><span class="line">numpy&#x3D;&#x3D;1.9.2</span><br><span class="line">requests&#x3D;&#x3D;2.7.0</span><br></pre></td></tr></table></figure>

<p>然后可以将 <code>requirements.txt</code> 提交给版本控制并作为应用程序的一部分提供。然后用户可以使用 <code>install -r</code> 安装所有必需的包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(tutorial-env) $ pip install -r requirements.txt</span><br><span class="line">Collecting novas&#x3D;&#x3D;3.1.1.3 (from -r requirements.txt (line 1))</span><br><span class="line">  ...</span><br><span class="line">Collecting numpy&#x3D;&#x3D;1.9.2 (from -r requirements.txt (line 2))</span><br><span class="line">  ...</span><br><span class="line">Collecting requests&#x3D;&#x3D;2.7.0 (from -r requirements.txt (line 3))</span><br><span class="line">  ...</span><br><span class="line">Installing collected packages: novas, numpy, requests</span><br><span class="line">  Running setup.py install for novas</span><br><span class="line">Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0</span><br></pre></td></tr></table></figure>

<p><code>pip</code> 有更多选择。有关 <code>pip</code> 的完整文档，请参阅 <a href="https://docs.python.org/zh-cn/3/installing/index.html#installing-index" target="_blank" rel="noopener">安装 Python 模块</a> 指南。当您编写一个包并希望在 Python 包索引中使它可用时，请参考 <a href="https://docs.python.org/zh-cn/3/distributing/index.html#distributing-index" target="_blank" rel="noopener">分发 Python 模块</a> 指南。</p>
<h1 id="13-接下来？"><a href="#13-接下来？" class="headerlink" title="13. 接下来？"></a>13. 接下来？</h1><p>阅读本教程可能会增强您对使用Python的兴趣 - 您应该热衷于应用Python来解决您的实际问题。你应该去哪里了解更多？</p>
<p>本教程是Python文档集的一部分。其他文档：</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/library/index.html#library-index" target="_blank" rel="noopener">Python 标准库</a>:</p>
<p>您应该浏览本手册，该手册提供了有关标准库中的类型，功能和模块的完整（尽管简洁）参考资料。标准的Python发行版包含 <em>很多</em> 的附加代码。有些模块可以读取Unix邮箱，通过HTTP检索文档，生成随机数，解析命令行选项，编写CGI程序，压缩数据以及许多其他任务。浏览标准库参考可以了解更多可用的内容。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/installing/index.html#installing-index" target="_blank" rel="noopener">安装 Python 模块</a> 解释了怎么安装由其他Python开发者编写的模块。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3/reference/index.html#reference-index" target="_blank" rel="noopener">Python 语言参考</a>: Python的语法和语义的详细解释。尽管阅读完非常繁重，但作为语言本身的完整指南是有用的。</p>
</li>
</ul>
<p>更多Python资源：</p>
<ul>
<li><a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org</a> ：主要的Python网站。它包含代码，文档以及指向Web上与Python相关的页面的链接。该网站世界很多地区都有镜像，如欧洲，日本和澳大利亚；镜像可能比主站点更快，具体取决于您的地理位置。</li>
<li><a href="https://docs.python.org/" target="_blank" rel="noopener">https://docs.python.org</a> ：快速访问Python的文档。</li>
<li><a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org</a>: The Python Package Index，以前也被昵称为 Cheese Shop <a href="https://docs.python.org/zh-cn/3/tutorial/whatnow.html#id2" target="_blank" rel="noopener">1</a>，是可下载用户自制 Python 模块的索引。 当你要开始发布代码时，你可以在此处进行注册以便其他人能找到它。</li>
<li><a href="https://code.activestate.com/recipes/langs/python/" target="_blank" rel="noopener">https://code.activestate.com/recipes/langs/python/</a> ：Python Cookbook是一个相当大的代码示例集，更多的模块和有用的脚本。特别值得注意的贡献收集在一本名为Python Cookbook（O’Reilly＆Associates，ISBN 0-596-00797-3）的书中。</li>
<li><a href="http://www.pyvideo.org/" target="_blank" rel="noopener">http://www.pyvideo.org</a> 从会议和用户组会议中收集与Python相关的视频的链接。</li>
<li><a href="https://scipy.org/" target="_blank" rel="noopener">https://scipy.org</a> ：Ecientific Python项目包括用于快速阵列计算和操作的模块，以及用于诸如线性代数，傅里叶变换，非线性求解器，随机数分布，统计分析等的一系列包。</li>
</ul>
<p>对于与Python相关的问题和问题报告，您可以发布到新闻组 <em>comp.lang.python</em> ，或者将它们发送到邮件列表python-<a href="mailto:list%40python.org">list@python.org</a>。新闻组和邮件列表是互通的，因此发布到一个地方将自动转发给另一个。每天有数百个帖子，询问（和回答）问题，建议新功能，以及宣布新模块。邮件列表档案可在 <a href="https://mail.python.org/pipermail/" target="_blank" rel="noopener">https://mail.python.org/pipermail/</a> 上找到。</p>
<p>在发问之前，请务必查看以下列表 <a href="https://docs.python.org/zh-cn/3/faq/index.html#faq-index" target="_blank" rel="noopener">常见问题</a> （或简写为 FAQ）。常见问题包含了很多一次又一次问到的问题及答案，并且可能已经包含了您的问题的解决方案。</p>
<p>备注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/whatnow.html#id1" target="_blank" rel="noopener">1</a></p>
<p>“Cheese Shop”是 Monty Python 的一个短剧：一位顾客来到一家奶酪商店，但无论他要哪种奶酪，店员都说没有货。</p>
</li>
</ul>
<h1 id="14-交互式编辑和编辑历史"><a href="#14-交互式编辑和编辑历史" class="headerlink" title="14. 交互式编辑和编辑历史"></a>14. 交互式编辑和编辑历史</h1><p>某些版本的 Python 解释器支持编辑当前输入行和编辑历史记录，类似 Korn shell 和 GNU Bash shell 的功能 。这个功能使用了 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html" target="_blank" rel="noopener">GNU Readline</a> 来实现，一个支持多种编辑方式的库。这个库有它自己的文档，在这里我们就不重复说明了。</p>
<h2 id="14-1-Tab-补全和编辑历史"><a href="#14-1-Tab-补全和编辑历史" class="headerlink" title="14.1. Tab 补全和编辑历史"></a>14.1. Tab 补全和编辑历史</h2><p>在解释器启动的时候，补全变量和模块名的功能将 <a href="https://docs.python.org/zh-cn/3/library/site.html#rlcompleter-config" target="_blank" rel="noopener">自动打开</a>，以便在按下 Tab 键的时候调用补全函数。它会查看 Python 语句名称，当前局部变量和可用的模块名称。处理像 <code>string.a</code> 的表达式，它会求值在最后一个 <code>&#39;.&#39;</code> 之前的表达式，接着根据求值结果对象的属性给出补全建议。如果拥有 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 方法的对象是表达式的一部分，注意这可能会执行程序定义的代码。默认配置下会把编辑历史记录保存在用户目录下名为 <code>.python_history</code> 的文件。在下一次 Python 解释器会话期间，编辑历史记录仍旧可用。</p>
<h2 id="14-2-默认交互式解释器的替代品"><a href="#14-2-默认交互式解释器的替代品" class="headerlink" title="14.2. 默认交互式解释器的替代品"></a>14.2. 默认交互式解释器的替代品</h2><p>Python 解释器与早期版本的相比，向前迈进了一大步；无论怎样，还有些希望的功能：如果能在编辑连续行时建议缩进（解析器知道接下来是否需要缩进符号），那将很棒。补全机制可以使用解释器的符号表。有命令去检查（甚至建议）括号，引号以及其他符号是否匹配。</p>
<p>一个可选的增强型交互式解释器是 <a href="https://ipython.org/" target="_blank" rel="noopener">IPython</a>，它已经存在了有一段时间，它具有 tab 补全，探索对象和高级历史记录管理功能。它还可以彻底定制并嵌入到其他应用程序中。另一个相似的增强型交互式环境是 <a href="https://www.bpython-interpreter.org/" target="_blank" rel="noopener">bpython</a>。</p>
<h1 id="15-浮点算术：争议和限制"><a href="#15-浮点算术：争议和限制" class="headerlink" title="15. 浮点算术：争议和限制"></a>15. 浮点算术：争议和限制</h1><p>浮点数在计算机硬件中表示为以 2 为基数（二进制）的小数。举例而言，十进制的小数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.125</span><br></pre></td></tr></table></figure>

<p>等于 1/10 + 2/100 + 5/1000 ，同理，二进制的小数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.001</span><br></pre></td></tr></table></figure>

<p>等于0/2 + 0/4 + 1/8。这两个小数具有相同的值，唯一真正的区别是第一个是以 10 为基数的小数表示法，第二个则是 2 为基数。</p>
<p>不幸的是，大多数的十进制小数都不能精确地表示为二进制小数。这导致在大多数情况下，你输入的十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中。</p>
<p>用十进制来理解这个问题显得更加容易一些。考虑分数 1/3 。我们可以得到它在十进制下的一个近似值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.3</span><br></pre></td></tr></table></figure>

<p>或者，更近似的，:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.33</span><br></pre></td></tr></table></figure>

<p>或者，更近似的，:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.333</span><br></pre></td></tr></table></figure>

<p>以此类推。结果是无论你写下多少的数字，它都永远不会等于 1/3 ，只是更加更加地接近 1/3 。</p>
<p>同样的道理，无论你使用多少位以 2 为基数的数码，十进制的 0.1 都无法精确地表示为一个以 2 为基数的小数。 在以 2 为基数的情况下， 1/10 是一个无限循环小数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0001100110011001100110011001100110011001100110011...</span><br></pre></td></tr></table></figure>

<p>在任何一个位置停下，你都只能得到一个近似值。因此，在今天的大部分架构上，浮点数都只能近似地使用二进制小数表示，对应分数的分子使用每 8 字节的前 53 位表示，分母则表示为 2 的幂次。在 1/10 这个例子中，相应的二进制分数是 <code>3602879701896397 / 2 ** 55</code> ，它很接近 1/10 ，但并不是 1/10 。</p>
<p>大部分用户都不会意识到这个差异的存在，因为 Python 只会打印计算机中存储的二进制值的十进制近似值。在大部分计算机中，如果 Python 想把 0.1 的二进制对应的精确十进制打印出来，将会变成这样</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0.1</span><br><span class="line">0.1000000000000000055511151231257827021181583404541015625</span><br></pre></td></tr></table></figure>

<p>这比大多数人认为有用的数字更多，因此Python通过显示舍入值来保持可管理的位数</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 &#x2F; 10</span><br><span class="line">0.1</span><br></pre></td></tr></table></figure>

<p>牢记，即使输出的结果看起来好像就是 1/10 的精确值，实际储存的值只是最接近 1/10 的计算机可表示的二进制分数。</p>
<p>有趣的是，有许多不同的十进制数共享相同的最接近的近似二进制小数。例如， <code>0.1</code> 、 <code>0.10000000000000001</code> 、 <code>0.1000000000000000055511151231257827021181583404541015625</code> 全都近似于 <code>3602879701896397 / 2 ** 55</code> 。由于所有这些十进制值都具有相同的近似值，因此可以显示其中任何一个，同时仍然保留不变的 <code>eval(repr(x)) == x</code> 。</p>
<p>在历史上，Python 提示符和内置的 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数会选择具有 17 位有效数字的来显示，即 <code>0.10000000000000001</code>。 从 Python 3.1 开始，Python（在大多数系统上）现在能够选择这些表示中最短的并简单地显示 <code>0.1</code> 。</p>
<p>请注意这种情况是二进制浮点数的本质特性：它不是 Python 的错误，也不是你代码中的错误。 你会在所有支持你的硬件中的浮点运算的语言中发现同样的情况（虽然某些语言在默认状态或所有输出模块下都不会 <em>显示</em> 这种差异）。</p>
<p>想要更美观的输出，你可能会希望使用字符串格式化来产生限定长度的有效位数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; format(math.pi, &#39;.12g&#39;)  # give 12 significant digits</span><br><span class="line">&#39;3.14159265359&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; format(math.pi, &#39;.2f&#39;)   # give 2 digits after the point</span><br><span class="line">&#39;3.14&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; repr(math.pi)</span><br><span class="line">&#39;3.141592653589793&#39;</span><br></pre></td></tr></table></figure>

<p>必须重点了解的是，这在实际上只是一个假象：你只是将真正的机器码值进行了舍入操作再 <em>显示</em> 而已。</p>
<p>一个假象还可能导致另一个假象。 例如，由于这个 0.1 并非真正的 1/10，将三个 0.1 的值相加也不一定能恰好得到 0.3:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; .1 + .1 + .1 &#x3D;&#x3D; .3</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>而且，由于这个 0.1 无法精确表示 1/10 的值而这个 0.3 也无法精确表示 3/10 的值，使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a> 函数进行预先舍入也是没用的:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(.1, 1) + round(.1, 1) + round(.1, 1) &#x3D;&#x3D; round(.3, 1)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>虽然这些小数无法精确表示其所要代表的实际值，<a href="https://docs.python.org/zh-cn/3/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a> 函数还是可以用来“事后舍入”，使得实际的结果值可以做相互比较:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(.1 + .1 + .1, 10) &#x3D;&#x3D; round(.3, 10)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>二进制浮点运算会造成许多这样的“意外”。 有关 “0.1” 的问题会在下面的“表示性错误”一节中更详细地描述。 请参阅 <a href="http://www.lahey.com/float.htm" target="_blank" rel="noopener">浮点数的危险性</a> 一文了解有关其他常见意外现象的更详细介绍。</p>
<p>正如那篇文章的结尾所言，“对此问题并无简单的答案。” 但是也不必过于担心浮点数的问题！ Python 浮点运算中的错误是从浮点运算硬件继承而来，而在大多数机器上每次浮点运算得到的 2**53 数码位都会被作为 1 个整体来处理。 这对大多数任务来说都已足够，但你确实需要记住它并非十进制算术，且每次浮点运算都可能会导致新的舍入错误。</p>
<p>虽然病态的情况确实存在，但对于大多数正常的浮点运算使用来说，你只需简单地将最终显示的结果舍入为你期望的十进制数值即可得到你期望的结果。 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 通常已足够，对于更精度的控制可参看 <a href="https://docs.python.org/zh-cn/3/library/string.html#formatstrings" target="_blank" rel="noopener">格式字符串语法</a> 中 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 方法的格式描述符。</p>
<p>对于需要精确十进制表示的使用场景，请尝试使用 <a href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal" target="_blank" rel="noopener"><code>decimal</code></a> 模块，该模块实现了适合会计应用和高精度应用的十进制运算。</p>
<p>另一种形式的精确运算由 <a href="https://docs.python.org/zh-cn/3/library/fractions.html#module-fractions" target="_blank" rel="noopener"><code>fractions</code></a> 模块提供支持，该模块实现了基于有理数的算术运算（因此可以精确表示像 1/3 这样的数值）。</p>
<p>如果你是浮点运算的重度用户，你应该看一下数值运算 Python 包 NumPy 以及由 SciPy 项目所提供的许多其它数学和统计运算包。 参见 &lt;<a href="https://scipy.org/" target="_blank" rel="noopener">https://scipy.org</a>&gt;。</p>
<p>Python 也提供了一些工具，可以在你真的 <em>想要</em> 知道一个浮点数精确值的少数情况下提供帮助。 例如 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#float.as_integer_ratio" target="_blank" rel="noopener"><code>float.as_integer_ratio()</code></a> 方法会将浮点数表示为一个分数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; 3.14159</span><br><span class="line">&gt;&gt;&gt; x.as_integer_ratio()</span><br><span class="line">(3537115888337719, 1125899906842624)</span><br></pre></td></tr></table></figure>

<p>由于这是一个精确的比值，它可以被用来无损地重建原始值:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D;&#x3D; 3537115888337719 &#x2F; 1125899906842624</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#float.hex" target="_blank" rel="noopener"><code>float.hex()</code></a> 方法会以十六进制（以 16 为基数）来表示浮点数，同样能给出保存在你的计算机中的精确值:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.hex()</span><br><span class="line">&#39;0x1.921f9f01b866ep+1&#39;</span><br></pre></td></tr></table></figure>

<p>这种精确的十六进制表示法可被用来精确地重建浮点值:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D;&#x3D; float.fromhex(&#39;0x1.921f9f01b866ep+1&#39;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>由于这种表示法是精确的，它适用于跨越不同版本（平台无关）的 Python 移植数值，以及与支持相同格式的其他语言（例如 Java 和 C99）交换数据.</p>
<p>另一个有用的工具是 <a href="https://docs.python.org/zh-cn/3/library/math.html#math.fsum" target="_blank" rel="noopener"><code>math.fsum()</code></a> 函数，它有助于减少求和过程中的精度损失。 它会在数值被添加到总计值的时候跟踪“丢失的位”。 这可以很好地保持总计值的精确度， 使得错误不会积累到能影响结果总数的程度:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum([0.1] * 10) &#x3D;&#x3D; 1.0</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; math.fsum([0.1] * 10) &#x3D;&#x3D; 1.0</span><br><span class="line">True</span><br></pre></td></tr></table></figure>



<h2 id="15-1-表示性错误"><a href="#15-1-表示性错误" class="headerlink" title="15.1. 表示性错误"></a>15.1. 表示性错误</h2><p>本小节将详细解释 “0.1” 的例子，并说明你可以怎样亲自对此类情况进行精确分析。 假定前提是已基本熟悉二进制浮点表示法。</p>
<p><em>表示性错误</em> 是指某些（其实是大多数）十进制小数无法以二进制（以 2 为基数的计数制）精确表示这一事实造成的错误。 这就是为什么 Python（或者 Perl、C、C++、Java、Fortran 以及许多其他语言）经常不会显示你所期待的精确十进制数值的主要原因。</p>
<p>为什么会这样？ 1/10 是无法用二进制小数精确表示的。 目前（2000年11月）几乎所有使用 IEEE-754 浮点运算标准的机器以及几乎所有系统平台都会将 Python 浮点数映射为 IEEE-754 “双精度类型”。 754 双精度类型包含 53 位精度，因此在输入时，计算会尽量将 0.1 转换为以 <em>J</em>/2<em>**N</em> 形式所能表示的最接近分数，其中 <em>J</em> 为恰好包含 53 个二进制位的整数。 重新将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F; 10 ~&#x3D; J &#x2F; (2**N)</span><br></pre></td></tr></table></figure>

<p>写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J ~&#x3D; 2**N &#x2F; 10</span><br></pre></td></tr></table></figure>

<p>并且由于 <em>J</em> 恰好有 53 位 (即 <code>&gt;= 2**52</code> 但 <code>&lt; 2**53</code>)，<em>N</em> 的最佳值为 56:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2**52 &lt;&#x3D;  2**56 &#x2F;&#x2F; 10  &lt; 2**53</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>也就是说，56 是唯一的 <em>N</em> 值能令 <em>J</em> 恰好有 53 位。 这样 <em>J</em> 的最佳可能值就是经过舍入的商:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q, r &#x3D; divmod(2**56, 10)</span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>由于余数超过 10 的一半，最佳近似值可通过四舍五入获得:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q+1</span><br><span class="line">7205759403792794</span><br></pre></td></tr></table></figure>

<p>这样在 754 双精度下 1/10 的最佳近似值为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7205759403792794 &#x2F; 2 ** 56</span><br></pre></td></tr></table></figure>

<p>分子和分母都除以二则结果小数为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3602879701896397 &#x2F; 2 ** 55</span><br></pre></td></tr></table></figure>

<p>请注意由于我们做了向上舍入，这个结果实际上略大于 1/10；如果我们没有向上舍入，则商将会略小于 1/10。 但无论如何它都不会是 <em>精确的</em> 1/10！</p>
<p>因此计算永远不会“看到”1/10：它实际看到的就是上面所给出的小数，它所能达到的最佳 754 双精度近似值:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0.1 * 2 ** 55</span><br><span class="line">3602879701896397.0</span><br></pre></td></tr></table></figure>

<p>如果我们将该小数乘以 10**55，我们可以看到该值输出为 55 位的十进制数:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3602879701896397 * 10 ** 55 &#x2F;&#x2F; 2 ** 55</span><br><span class="line">1000000000000000055511151231257827021181583404541015625</span><br></pre></td></tr></table></figure>

<p>这意味着存储在计算机中的确切数值等于十进制数值 0.1000000000000000055511151231257827021181583404541015625。 许多语言（包括较旧版本的 Python）都不会显示这个完整的十进制数值，而是将结果舍入为 17 位有效数字:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; format(0.1, &#39;.17f&#39;)</span><br><span class="line">&#39;0.10000000000000001&#39;</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/zh-cn/3/library/fractions.html#module-fractions" target="_blank" rel="noopener"><code>fractions</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/decimal.html#module-decimal" target="_blank" rel="noopener"><code>decimal</code></a> 模块可令进行此类计算更加容易:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from decimal import Decimal</span><br><span class="line">&gt;&gt;&gt; from fractions import Fraction</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Fraction.from_float(0.1)</span><br><span class="line">Fraction(3602879701896397, 36028797018963968)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; (0.1).as_integer_ratio()</span><br><span class="line">(3602879701896397, 36028797018963968)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Decimal.from_float(0.1)</span><br><span class="line">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; format(Decimal.from_float(0.1), &#39;.17&#39;)</span><br><span class="line">&#39;0.10000000000000001&#39;</span><br></pre></td></tr></table></figure>

<h1 id="16-附录"><a href="#16-附录" class="headerlink" title="16. 附录"></a>16. 附录</h1><h2 id="16-1-交互模式"><a href="#16-1-交互模式" class="headerlink" title="16.1. 交互模式"></a>16.1. 交互模式</h2><h3 id="16-1-1-错误处理"><a href="#16-1-1-错误处理" class="headerlink" title="16.1.1. 错误处理"></a>16.1.1. 错误处理</h3><p>当发生错误时，解释器会打印错误信息和错误堆栈。在交互模式下，将返回到主命令提示符；如果输入内容来自文件，在打印错误堆栈之后，程序会以非零状态退出。（这里所说的错误不包括 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中由 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 所捕获的异常。）有些错误是无条件致命的，会导致程序以非零状态退出；比如内部逻辑矛盾或内存耗尽。所有错误信息都会被写入标准错误流；而命令的正常输出则被写入标准输出流。</p>
<p>将中断字符（通常为 Control-C 或 Delete ）键入主要或辅助提示会取消输入并返回主提示符。 <a href="https://docs.python.org/zh-cn/3/tutorial/appendix.html#id2" target="_blank" rel="noopener">1</a> 在执行命令时键入中断引发的 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常，可以由 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句处理。</p>
<h3 id="16-1-2-可执行的Python脚本"><a href="#16-1-2-可执行的Python脚本" class="headerlink" title="16.1.2. 可执行的Python脚本"></a>16.1.2. 可执行的Python脚本</h3><p>在BSD等类Unix系统上，Python脚本可以直接执行，就像shell脚本一样，第一行添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3.5</span><br></pre></td></tr></table></figure>

<p>（假设解释器位于用户的 <code>PATH</code> ）脚本的开头，并将文件设置为可执行。 <code>#!</code> 必须是文件的前两个字符。在某些平台上，第一行必须以Unix样式的行结尾（<code>&#39;\n&#39;</code>）结束，而不是以Windows（<code>&#39;\r\n&#39;</code>）行结尾。请注意，散列或磅字符 <code>&#39;#&#39;</code> 在Python中代表注释开始。</p>
<p>可以使用 <strong>chmod</strong> 命令为脚本提供可执行模式或权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x myscript.py</span><br></pre></td></tr></table></figure>

<p>在Windows系统上，没有“可执行模式”的概念。 Python安装程序自动将 <code>.py</code> 文件与 <code>python.exe</code> 相关联，这样双击Python文件就会将其作为脚本运行。扩展也可以是 <code>.pyw</code> ，在这种情况下，会隐藏通常出现的控制台窗口。</p>
<h3 id="16-1-3-交互式启动文件"><a href="#16-1-3-交互式启动文件" class="headerlink" title="16.1.3. 交互式启动文件"></a>16.1.3. 交互式启动文件</h3><p>当您以交互方式使用Python时，每次启动解释器时都会执行一些标准命令，这通常很方便。您可以通过将名为 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#envvar-PYTHONSTARTUP" target="_blank" rel="noopener"><code>PYTHONSTARTUP</code></a> 的环境变量设置为包含启动命令的文件名来实现。这类似于Unix shell的 <code>.profile</code> 功能。</p>
<p>This file is only read in interactive sessions, not when Python reads commands from a script, and not when <code>/dev/tty</code> is given as the explicit source of commands (which otherwise behaves like an interactive session). It is executed in the same namespace where interactive commands are executed, so that objects that it defines or imports can be used without qualification in the interactive session. You can also change the prompts <code>sys.ps1</code> and <code>sys.ps2</code> in this file.</p>
<p>如果你想从当前目录中读取一个额外的启动文件，你可以使用像 <code>if os.path.isfile(&#39;.pythonrc.py&#39;): exec(open(&#39;.pythonrc.py&#39;).read())</code> 这样的代码在全局启动文件中对它进行编程。如果要在脚本中使用启动文件，则必须在脚本中显式执行此操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">filename &#x3D; os.environ.get(&#39;PYTHONSTARTUP&#39;)</span><br><span class="line">if filename and os.path.isfile(filename):</span><br><span class="line">    with open(filename) as fobj:</span><br><span class="line">        startup_file &#x3D; fobj.read()</span><br><span class="line">    exec(startup_file)</span><br></pre></td></tr></table></figure>



<h3 id="16-1-4-定制模块"><a href="#16-1-4-定制模块" class="headerlink" title="16.1.4. 定制模块"></a>16.1.4. 定制模块</h3><p>Python提供了两个钩子来让你自定义它：<code>sitecustomize</code> 和 <code>usercustomize</code>。要查看其工作原理，首先需要找到用户site-packages目录的位置。启动Python并运行此代码:</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import site</span><br><span class="line">&gt;&gt;&gt; site.getusersitepackages()</span><br><span class="line">&#39;&#x2F;home&#x2F;user&#x2F;.local&#x2F;lib&#x2F;python3.5&#x2F;site-packages&#39;</span><br></pre></td></tr></table></figure>

<p>现在，您可以在该目录中创建一个名为 <code>usercustomize.py</code> 的文件，并将所需内容放入其中。它会影响Python的每次启动，除非它以 <a href="https://docs.python.org/zh-cn/3/using/cmdline.html#cmdoption-s" target="_blank" rel="noopener"><code>-s</code></a> 选项启动，以禁用自动导入。</p>
<p><code>sitecustomize</code> 以相同的方式工作，但通常由计算机管理员在全局 site-packages 目录中创建，并在 <code>usercustomize</code> 之前被导入。有关详情请参阅 <a href="https://docs.python.org/zh-cn/3/library/site.html#module-site" target="_blank" rel="noopener"><code>site</code></a> 模块的文档。</p>
<p>脚注</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3/tutorial/appendix.html#id1" target="_blank" rel="noopener">1</a></p>
<p>GNU Readline 包的问题可能会阻止这种情况。</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">蕾米亚</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://omimo.ga/2020/b23cbeff.html">http://omimo.ga/2020/b23cbeff.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://omimo.ga" target="_blank">彭彭和丁满</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post_share"></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/d98b1daa.html"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover4.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python语言参考</div></div></a></div><div class="next-post pull_right"><a href="/2020/d5346afd.html"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover5.gif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">20200324疫情信息</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/d98b1daa.html" title="python语言参考"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover4.gif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-24</div><div class="relatedPosts_title">python语言参考</div></div></a></div><div class="relatedPosts_item"><a href="/2020/3c368bb6.html" title="python常用库模块"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/wdsrkrrjmqo.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-12</div><div class="relatedPosts_title">python常用库模块</div></div></a></div><div class="relatedPosts_item"><a href="/2019/4f239c31.html" title="Python Interview"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/朝天门.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-03-03</div><div class="relatedPosts_title">Python Interview</div></div></a></div><div class="relatedPosts_item"><a href="/2017/5c1674cb.html" title="Python—Virtualenv---pyenv简明教程(MAC版)"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/maracle/maracle.github.io@master/pictures/default_cover2.gif"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2017-05-24</div><div class="relatedPosts_title">Python—Virtualenv---pyenv简明教程(MAC版)</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'x8zJ7Nuyh3yChQgtKcdg4zwC-MdYXbMMI',
  appKey: 'pWRle3EfOO23aYlB3O1SyOQs',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2020 By 蕾米亚</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text"><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body></html>